{
  "slug": "graham-scan-functions",
  "name": "Graham Scan Functions",
  "categories": [
    "geometry"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "geometry\\graham_scan_functions.hpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/geometry\\graham_scan_functions.hpp",
      "code": "<span class=\"hljs-comment\">/******************************************************************************\r\n * @file\r\n * @brief Implementation of the [Convex\r\n * Hull](https://en.wikipedia.org/wiki/Convex_hull) implementation using [Graham\r\n * Scan](https://en.wikipedia.org/wiki/Graham_scan)\r\n * @details\r\n * In geometry, the convex hull or convex envelope or convex closure of a shape\r\n * is the smallest convex set that contains it. The convex hull may be defined\r\n * either as the intersection of all convex sets containing a given subset of a\r\n * Euclidean space, or equivalently as the set of all convex combinations of\r\n * points in the subset. For a bounded subset of the plane, the convex hull may\r\n * be visualized as the shape enclosed by a rubber band stretched around the\r\n * subset.\r\n *\r\n * The worst case time complexity of Jarvis’s Algorithm is O(n^2). Using\r\n * Graham’s scan algorithm, we can find Convex Hull in O(nLogn) time.\r\n *\r\n * ### Implementation\r\n *\r\n * Sort points\r\n * We first find the bottom-most point. The idea is to pre-process\r\n * points be sorting them with respect to the bottom-most point. Once the points\r\n * are sorted, they form a simple closed path.\r\n * The sorting criteria is to use the orientation to compare angles without\r\n * actually computing them (See the compare() function below) because\r\n * computation of actual angles would be inefficient since trigonometric\r\n * functions are not simple to evaluate.\r\n *\r\n * Accept or Reject Points\r\n * Once we have the closed path, the next step is to traverse the path and\r\n * remove concave points on this path using orientation. The first two points in\r\n * sorted array are always part of Convex Hull. For remaining points, we keep\r\n * track of recent three points, and find the angle formed by them. Let the\r\n * three points be prev(p), curr(c) and next(n). If orientation of these points\r\n * (considering them in same order) is not counterclockwise, we discard c,\r\n * otherwise we keep it.\r\n *\r\n * @author [Lajat Manekar](https://github.com/Lazeeez)\r\n *\r\n *******************************************************************************/</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span>  <span class=\"hljs-comment\">/// for std::swap</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span>    <span class=\"hljs-comment\">/// for mathematics and datatype conversion</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>   <span class=\"hljs-comment\">/// for IO operations</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span>      <span class=\"hljs-comment\">/// for std::stack</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>     <span class=\"hljs-comment\">/// for std::vector</span></span>\r\n\r\n<span class=\"hljs-comment\">/******************************************************************************\r\n * @namespace geometry\r\n * @brief geometric algorithms\r\n *******************************************************************************/</span>\r\n<span class=\"hljs-keyword\">namespace</span> geometry {\r\n\r\n<span class=\"hljs-comment\">/******************************************************************************\r\n * @namespace graham scan\r\n * @brief convex hull algorithm\r\n *******************************************************************************/</span>\r\n<span class=\"hljs-keyword\">namespace</span> grahamscan {\r\n\r\n<span class=\"hljs-comment\">/******************************************************************************\r\n * @struct Point\r\n * @brief for X and Y co-ordinates of the co-ordinate.\r\n *******************************************************************************/</span>\r\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Point</span> {\r\n    <span class=\"hljs-type\">int</span> x, y;\r\n};\r\n\r\n<span class=\"hljs-comment\">// A global point needed for sorting points with reference</span>\r\n<span class=\"hljs-comment\">// to  the first point Used in compare function of qsort()</span>\r\n\r\nPoint p0;\r\n\r\n<span class=\"hljs-comment\">/******************************************************************************\r\n * @brief A utility function to find next to top in a stack.\r\n * @param S Stack to be used for the process.\r\n * @returns @param Point Co-ordinates of the Point &lt;int, int&gt;\r\n *******************************************************************************/</span>\r\n<span class=\"hljs-function\">Point <span class=\"hljs-title\">nextToTop</span><span class=\"hljs-params\">(std::stack&lt;Point&gt; *S)</span> </span>{\r\n    Point p = S-&gt;<span class=\"hljs-built_in\">top</span>();\r\n    S-&gt;<span class=\"hljs-built_in\">pop</span>();\r\n    Point res = S-&gt;<span class=\"hljs-built_in\">top</span>();\r\n    S-&gt;<span class=\"hljs-built_in\">push</span>(p);\r\n    <span class=\"hljs-keyword\">return</span> res;\r\n}\r\n\r\n<span class=\"hljs-comment\">/******************************************************************************\r\n * @brief A utility function to return square of distance between p1 and p2.\r\n * @param p1 Co-ordinates of Point 1 &lt;int, int&gt;.\r\n * @param p2 Co-ordinates of Point 2 &lt;int, int&gt;.\r\n * @returns @param int distance between p1 and p2.\r\n *******************************************************************************/</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">distSq</span><span class=\"hljs-params\">(Point p1, Point p2)</span> </span>{\r\n    <span class=\"hljs-keyword\">return</span> (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\r\n}\r\n\r\n<span class=\"hljs-comment\">/******************************************************************************\r\n * @brief To find orientation of ordered triplet (p, q, r).\r\n * @param p Co-ordinates of Point p &lt;int, int&gt;.\r\n * @param q Co-ordinates of Point q &lt;int, int&gt;.\r\n * @param r Co-ordinates of Point r &lt;int, int&gt;.\r\n * @returns @param int 0 --&gt; p, q and r are collinear, 1 --&gt; Clockwise,\r\n * 2 --&gt; Counterclockwise\r\n *******************************************************************************/</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">orientation</span><span class=\"hljs-params\">(Point p, Point q, Point r)</span> </span>{\r\n    <span class=\"hljs-type\">int</span> val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\r\n\r\n    <span class=\"hljs-keyword\">if</span> (val == <span class=\"hljs-number\">0</span>) {\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// collinear</span>\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> (val &gt; <span class=\"hljs-number\">0</span>) ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">2</span>;  <span class=\"hljs-comment\">// clock or counter-clock wise</span>\r\n}\r\n\r\n<span class=\"hljs-comment\">/******************************************************************************\r\n * @brief A function used by library function qsort() to sort an array of\r\n * points with respect to the first point\r\n * @param vp1 Co-ordinates of Point 1 &lt;int, int&gt;.\r\n * @param vp2 Co-ordinates of Point 2 &lt;int, int&gt;.\r\n * @returns @param int distance between p1 and p2.\r\n *******************************************************************************/</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span> *vp1, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span> *vp2)</span> </span>{\r\n    <span class=\"hljs-keyword\">auto</span> *p1 = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">const</span> Point *&gt;(vp1);\r\n    <span class=\"hljs-keyword\">auto</span> *p2 = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">const</span> Point *&gt;(vp2);\r\n\r\n    <span class=\"hljs-comment\">// Find orientation</span>\r\n    <span class=\"hljs-type\">int</span> o = <span class=\"hljs-built_in\">orientation</span>(p0, *p1, *p2);\r\n    <span class=\"hljs-keyword\">if</span> (o == <span class=\"hljs-number\">0</span>) {\r\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-built_in\">distSq</span>(p0, *p2) &gt;= <span class=\"hljs-built_in\">distSq</span>(p0, *p1)) ? <span class=\"hljs-number\">-1</span> : <span class=\"hljs-number\">1</span>;\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">return</span> (o == <span class=\"hljs-number\">2</span>) ? <span class=\"hljs-number\">-1</span> : <span class=\"hljs-number\">1</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/******************************************************************************\r\n * @brief Prints convex hull of a set of n points.\r\n * @param points vector of Point&lt;int, int&gt; with co-ordinates.\r\n * @param size Size of the vector.\r\n * @returns @param vector vector of Conver Hull.\r\n *******************************************************************************/</span>\r\n<span class=\"hljs-function\">std::vector&lt;Point&gt; <span class=\"hljs-title\">convexHull</span><span class=\"hljs-params\">(std::vector&lt;Point&gt; points, <span class=\"hljs-type\">uint64_t</span> size)</span> </span>{\r\n    <span class=\"hljs-comment\">// Find the bottom-most point</span>\r\n    <span class=\"hljs-type\">int</span> ymin = points[<span class=\"hljs-number\">0</span>].y, min = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; size; i++) {\r\n        <span class=\"hljs-type\">int</span> y = points[i].y;\r\n\r\n        <span class=\"hljs-comment\">// Pick the bottom-most or chose the left-most point in case of tie</span>\r\n        <span class=\"hljs-keyword\">if</span> ((y &lt; ymin) || (ymin == y &amp;&amp; points[i].x &lt; points[min].x)) {\r\n            ymin = points[i].y, min = i;\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// Place the bottom-most point at first position</span>\r\n    std::<span class=\"hljs-built_in\">swap</span>(points[<span class=\"hljs-number\">0</span>], points[min]);\r\n\r\n    <span class=\"hljs-comment\">// Sort n-1 points with respect to the first point. A point p1 comes</span>\r\n    <span class=\"hljs-comment\">// before p2 in sorted output if p2 has larger polar angle</span>\r\n    <span class=\"hljs-comment\">// (in counterclockwise direction) than p1.</span>\r\n    p0 = points[<span class=\"hljs-number\">0</span>];\r\n    <span class=\"hljs-built_in\">qsort</span>(&amp;points[<span class=\"hljs-number\">1</span>], size - <span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">sizeof</span>(Point), compare);\r\n\r\n    <span class=\"hljs-comment\">// If two or more points make same angle with p0, Remove all but the one</span>\r\n    <span class=\"hljs-comment\">// that is farthest from p0 Remember that, in above sorting, our criteria</span>\r\n    <span class=\"hljs-comment\">// was to keep the farthest point at the end when more than one points have</span>\r\n    <span class=\"hljs-comment\">// same angle.</span>\r\n    <span class=\"hljs-type\">int</span> m = <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">// Initialize size of modified array</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; size; i++) {\r\n        <span class=\"hljs-comment\">// Keep removing i while angle of i and i+1 is same with respect to p0</span>\r\n        <span class=\"hljs-keyword\">while</span> (i &lt; size - <span class=\"hljs-number\">1</span> &amp;&amp; <span class=\"hljs-built_in\">orientation</span>(p0, points[i], points[i + <span class=\"hljs-number\">1</span>]) == <span class=\"hljs-number\">0</span>) {\r\n            i++;\r\n        }\r\n\r\n        points[m] = points[i];\r\n        m++;  <span class=\"hljs-comment\">// Update size of modified array</span>\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// If modified array of points has less than 3 points, convex hull is not</span>\r\n    <span class=\"hljs-comment\">// possible</span>\r\n    <span class=\"hljs-keyword\">if</span> (m &lt; <span class=\"hljs-number\">3</span>) {\r\n        <span class=\"hljs-keyword\">return</span> {};\r\n    };\r\n\r\n    <span class=\"hljs-comment\">// Create an empty stack and push first three points to it.</span>\r\n    std::stack&lt;Point&gt; St;\r\n    St.<span class=\"hljs-built_in\">push</span>(points[<span class=\"hljs-number\">0</span>]);\r\n    St.<span class=\"hljs-built_in\">push</span>(points[<span class=\"hljs-number\">1</span>]);\r\n    St.<span class=\"hljs-built_in\">push</span>(points[<span class=\"hljs-number\">2</span>]);\r\n\r\n    <span class=\"hljs-comment\">// Process remaining n-3 points</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">3</span>; i &lt; m; i++) {\r\n        <span class=\"hljs-comment\">// Keep removing top while the angle formed by</span>\r\n        <span class=\"hljs-comment\">// points next-to-top, top, and points[i] makes</span>\r\n        <span class=\"hljs-comment\">// a non-left turn</span>\r\n        <span class=\"hljs-keyword\">while</span> (St.<span class=\"hljs-built_in\">size</span>() &gt; <span class=\"hljs-number\">1</span> &amp;&amp;\r\n               <span class=\"hljs-built_in\">orientation</span>(<span class=\"hljs-built_in\">nextToTop</span>(&amp;St), St.<span class=\"hljs-built_in\">top</span>(), points[i]) != <span class=\"hljs-number\">2</span>) {\r\n            St.<span class=\"hljs-built_in\">pop</span>();\r\n        }\r\n        St.<span class=\"hljs-built_in\">push</span>(points[i]);\r\n    }\r\n\r\n    std::vector&lt;Point&gt; result;\r\n    <span class=\"hljs-comment\">// Now stack has the output points, push them into the resultant vector</span>\r\n    <span class=\"hljs-keyword\">while</span> (!St.<span class=\"hljs-built_in\">empty</span>()) {\r\n        Point p = St.<span class=\"hljs-built_in\">top</span>();\r\n        result.<span class=\"hljs-built_in\">push_back</span>(p);\r\n        St.<span class=\"hljs-built_in\">pop</span>();\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">return</span> result;  <span class=\"hljs-comment\">// return resultant vector with Convex Hull co-ordinates.</span>\r\n}\r\n}  <span class=\"hljs-comment\">// namespace grahamscan</span>\r\n}  <span class=\"hljs-comment\">// namespace geometry</span>\r\n"
    }
  },
  "contributors": [
    {
      "name": "Lajat5",
      "email": "64376519+Lazeeez@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}