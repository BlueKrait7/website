{
  "slug": "breadth-first-search",
  "name": "Breadth First Search",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "graphs\\breadth_first_search.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/graphs\\breadth_first_search.py",
      "code": "<span class=\"hljs-comment\">#!/usr/bin/python</span>\r\n\r\n<span class=\"hljs-string\">&quot;&quot;&quot; Author: OMKAR PATHAK &quot;&quot;&quot;</span>\r\n<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\r\n\r\n<span class=\"hljs-keyword\">from</span> queue <span class=\"hljs-keyword\">import</span> Queue\r\n\r\n\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span>:\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        self.vertices: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]] = {}\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print_graph</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        prints adjacency list representation of graaph\r\n        &gt;&gt;&gt; g = Graph()\r\n        &gt;&gt;&gt; g.print_graph()\r\n        &gt;&gt;&gt; g.add_edge(0, 1)\r\n        &gt;&gt;&gt; g.print_graph()\r\n        0  :  1\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> self.vertices:\r\n            <span class=\"hljs-built_in\">print</span>(i, <span class=\"hljs-string\">&quot; : &quot;</span>, <span class=\"hljs-string\">&quot; -&gt; &quot;</span>.join([<span class=\"hljs-built_in\">str</span>(j) <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> self.vertices[i]]))\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_edge</span>(<span class=\"hljs-params\">self, from_vertex: <span class=\"hljs-built_in\">int</span>, to_vertex: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        adding the edge between two vertices\r\n        &gt;&gt;&gt; g = Graph()\r\n        &gt;&gt;&gt; g.print_graph()\r\n        &gt;&gt;&gt; g.add_edge(0, 1)\r\n        &gt;&gt;&gt; g.print_graph()\r\n        0  :  1\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">if</span> from_vertex <span class=\"hljs-keyword\">in</span> self.vertices:\r\n            self.vertices[from_vertex].append(to_vertex)\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            self.vertices[from_vertex] = [to_vertex]\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">bfs</span>(<span class=\"hljs-params\">self, start_vertex: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">set</span>[<span class=\"hljs-built_in\">int</span>]:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        &gt;&gt;&gt; g = Graph()\r\n        &gt;&gt;&gt; g.add_edge(0, 1)\r\n        &gt;&gt;&gt; g.add_edge(0, 1)\r\n        &gt;&gt;&gt; g.add_edge(0, 2)\r\n        &gt;&gt;&gt; g.add_edge(1, 2)\r\n        &gt;&gt;&gt; g.add_edge(2, 0)\r\n        &gt;&gt;&gt; g.add_edge(2, 3)\r\n        &gt;&gt;&gt; g.add_edge(3, 3)\r\n        &gt;&gt;&gt; sorted(g.bfs(2))\r\n        [0, 1, 2, 3]\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-comment\"># initialize set for storing already visited vertices</span>\r\n        visited = <span class=\"hljs-built_in\">set</span>()\r\n\r\n        <span class=\"hljs-comment\"># create a first in first out queue to store all the vertices for BFS</span>\r\n        queue: Queue = Queue()\r\n\r\n        <span class=\"hljs-comment\"># mark the source node as visited and enqueue it</span>\r\n        visited.add(start_vertex)\r\n        queue.put(start_vertex)\r\n\r\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">not</span> queue.empty():\r\n            vertex = queue.get()\r\n\r\n            <span class=\"hljs-comment\"># loop through all adjacent vertex and enqueue it if not yet visited</span>\r\n            <span class=\"hljs-keyword\">for</span> adjacent_vertex <span class=\"hljs-keyword\">in</span> self.vertices[vertex]:\r\n                <span class=\"hljs-keyword\">if</span> adjacent_vertex <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> visited:\r\n                    queue.put(adjacent_vertex)\r\n                    visited.add(adjacent_vertex)\r\n        <span class=\"hljs-keyword\">return</span> visited\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    <span class=\"hljs-keyword\">from</span> doctest <span class=\"hljs-keyword\">import</span> testmod\r\n\r\n    testmod(verbose=<span class=\"hljs-literal\">True</span>)\r\n\r\n    g = Graph()\r\n    g.add_edge(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>)\r\n    g.add_edge(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>)\r\n    g.add_edge(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)\r\n    g.add_edge(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>)\r\n    g.add_edge(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)\r\n    g.add_edge(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>)\r\n\r\n    g.print_graph()\r\n    <span class=\"hljs-comment\"># 0  :  1 -&gt; 2</span>\r\n    <span class=\"hljs-comment\"># 1  :  2</span>\r\n    <span class=\"hljs-comment\"># 2  :  0 -&gt; 3</span>\r\n    <span class=\"hljs-comment\"># 3  :  3</span>\r\n\r\n    <span class=\"hljs-keyword\">assert</span> <span class=\"hljs-built_in\">sorted</span>(g.bfs(<span class=\"hljs-number\">2</span>)) == [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\r\n"
    },
    "javascript": {
      "dir": "Graphs\\test\\BreadthFirstSearch.test.js",
      "url": "https://github.com/TheAlgorithms/javascript/tree/master/Graphs\\test\\BreadthFirstSearch.test.js",
      "code": "<span class=\"hljs-keyword\">import</span> { breadthFirstSearch } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;../BreadthFirstSearch&#x27;</span>\r\n\r\n<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&#x27;BreadthFirstSearch&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\r\n  <span class=\"hljs-keyword\">const</span> graph = {\r\n    <span class=\"hljs-attr\">A</span>: [<span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;D&#x27;</span>],\r\n    <span class=\"hljs-attr\">B</span>: [<span class=\"hljs-string\">&#x27;E&#x27;</span>],\r\n    <span class=\"hljs-attr\">C</span>: [<span class=\"hljs-string\">&#x27;D&#x27;</span>],\r\n    <span class=\"hljs-attr\">D</span>: [<span class=\"hljs-string\">&#x27;A&#x27;</span>],\r\n    <span class=\"hljs-attr\">E</span>: [<span class=\"hljs-string\">&#x27;D&#x27;</span>],\r\n    <span class=\"hljs-attr\">F</span>: [<span class=\"hljs-string\">&#x27;G&#x27;</span>],\r\n    <span class=\"hljs-attr\">G</span>: []\r\n  }\r\n  <span class=\"hljs-comment\">/*\r\n        A &lt;-&gt; B\r\n        ÊŒ     |\r\n        |     |\r\n        v     v\r\n  C --&gt; D &lt;-- E\r\n\r\n  F --&gt; G\r\n  */</span>\r\n\r\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;should return the visited nodes&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\r\n    <span class=\"hljs-title function_\">expect</span>(<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-title function_\">breadthFirstSearch</span>(graph, <span class=\"hljs-string\">&#x27;C&#x27;</span>))).<span class=\"hljs-title function_\">toEqual</span>([<span class=\"hljs-string\">&#x27;C&#x27;</span>, <span class=\"hljs-string\">&#x27;D&#x27;</span>, <span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;E&#x27;</span>])\r\n    <span class=\"hljs-title function_\">expect</span>(<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-title function_\">breadthFirstSearch</span>(graph, <span class=\"hljs-string\">&#x27;A&#x27;</span>))).<span class=\"hljs-title function_\">toEqual</span>([<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;D&#x27;</span>, <span class=\"hljs-string\">&#x27;E&#x27;</span>])\r\n    <span class=\"hljs-title function_\">expect</span>(<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-title function_\">breadthFirstSearch</span>(graph, <span class=\"hljs-string\">&#x27;F&#x27;</span>))).<span class=\"hljs-title function_\">toEqual</span>([<span class=\"hljs-string\">&#x27;F&#x27;</span>, <span class=\"hljs-string\">&#x27;G&#x27;</span>])\r\n  })\r\n})\r\n"
    },
    "c-plus-plus": {
      "dir": "graph\\breadth_first_search.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph\\breadth_first_search.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n *\r\n * \\file\r\n * \\brief [Breadth First Search Algorithm\r\n * (Breadth First Search)](https://en.wikipedia.org/wiki/Breadth-first_search)\r\n *\r\n * \\author [Ayaan Khan](https://github.com/ayaankhan98)\r\n * \\author [Aman Kumar Pandey](https://github.com/gpamangkp)\r\n *\r\n *\r\n * \\details\r\n * Breadth First Search also quoted as BFS is a Graph Traversal Algorithm.\r\n * Time Complexity O(|V| + |E|) where V are the number of vertices and E\r\n * are the number of edges in the graph.\r\n *\r\n * Applications of Breadth First Search are\r\n *\r\n * 1. Finding shortest path between two vertices say u and v, with path\r\n *    length measured by number of edges (an advantage over depth first\r\n *    search algorithm)\r\n * 2. Ford-Fulkerson Method for computing the maximum flow in a flow network.\r\n * 3. Testing bipartiteness of a graph.\r\n * 4. Cheney&#x27;s Algorithm, Copying garbage collection.\r\n *\r\n * And there are many more...\r\n *\r\n * &lt;h4&gt;working&lt;/h4&gt;\r\n * In the implementation below we first created a graph using the adjacency\r\n * list representation of graph.\r\n * Breadth First Search Works as follows\r\n * it requires a vertex as a start vertex, Start vertex is that vertex\r\n * from where you want to start traversing the graph.\r\n * We maintain a bool array or a vector to keep track of the vertices\r\n * which we have visited so that we do not traverse the visited vertices\r\n * again and again and eventually fall into an infinite loop. Along with this\r\n * boolen array we use a Queue.\r\n *\r\n * 1. First we mark the start vertex as visited.\r\n * 2. Push this visited vertex in the Queue.\r\n * 3. while the queue is not empty we repeat the following steps\r\n *\r\n *      1. Take out an element from the front of queue\r\n *      2. Explore the adjacency list of this vertex\r\n *         if element in the adjacency list is not visited then we\r\n *         push that element into the queue and mark this as visited\r\n *\r\n */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * \\namespace graph\r\n * \\brief Graph algorithms\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> graph {\r\n<span class=\"hljs-comment\">/* Class Graph definition */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span> {\r\n    <span class=\"hljs-comment\">/**\r\n     *  adjacency_list maps every vertex to the list of its neighbours in the\r\n     * order in which they are added.\r\n     */</span>\r\n    std::map&lt;T, std::list&lt;T&gt; &gt; adjacency_list;\r\n\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-built_in\">Graph</span>() = <span class=\"hljs-keyword\">default</span>;\r\n    ;\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">add_edge</span><span class=\"hljs-params\">(T u, T v, <span class=\"hljs-type\">bool</span> bidir = <span class=\"hljs-literal\">true</span>)</span> </span>{\r\n        <span class=\"hljs-comment\">/**\r\n         *  add_edge(u,v,bidir) is used to add an edge between node u and\r\n         * node v by default , bidir is made true , i.e graph is\r\n         * bidirectional . It means if edge(u,v) is added then u--&gt;v  and\r\n         * v--&gt;u both edges exist.\r\n         *\r\n         *  to make the graph unidirectional pass the third parameter of\r\n         * add_edge as false which will\r\n         */</span>\r\n        adjacency_list[u].<span class=\"hljs-built_in\">push_back</span>(v);  <span class=\"hljs-comment\">// u--&gt;v edge added</span>\r\n        <span class=\"hljs-keyword\">if</span> (bidir == <span class=\"hljs-literal\">true</span>) {\r\n            <span class=\"hljs-comment\">// if graph is bidirectional</span>\r\n            adjacency_list[v].<span class=\"hljs-built_in\">push_back</span>(u);  <span class=\"hljs-comment\">// v--&gt;u edge added</span>\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     *  this function performs the breadth first search on graph and return a\r\n     *  mapping which maps the nodes to a boolean value representing whether the\r\n     *  node was traversed or not.\r\n     */</span>\r\n    <span class=\"hljs-function\">std::map&lt;T, <span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-title\">breadth_first_search</span><span class=\"hljs-params\">(T src)</span> </span>{\r\n        <span class=\"hljs-comment\">/// mapping to keep track of all visited nodes</span>\r\n        std::map&lt;T, <span class=\"hljs-type\">bool</span>&gt; visited;\r\n        <span class=\"hljs-comment\">/// initialise every possible vertex to map to false</span>\r\n        <span class=\"hljs-comment\">/// initially none of the vertices are unvisited</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> <span class=\"hljs-type\">const</span> &amp;adjlist : adjacency_list) {\r\n            visited[adjlist.first] = <span class=\"hljs-literal\">false</span>;\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> <span class=\"hljs-type\">const</span> &amp;node : adjacency_list[adjlist.first]) {\r\n                visited[node] = <span class=\"hljs-literal\">false</span>;\r\n            }\r\n        }\r\n\r\n        <span class=\"hljs-comment\">/// queue to store the nodes which are yet to be traversed</span>\r\n        std::queue&lt;T&gt; tracker;\r\n\r\n        <span class=\"hljs-comment\">/// push the source vertex to queue to begin traversing</span>\r\n        tracker.<span class=\"hljs-built_in\">push</span>(src);\r\n        <span class=\"hljs-comment\">/// mark the source vertex as visited</span>\r\n        visited[src] = <span class=\"hljs-literal\">true</span>;\r\n        <span class=\"hljs-keyword\">while</span> (!tracker.<span class=\"hljs-built_in\">empty</span>()) {\r\n            <span class=\"hljs-comment\">/// traverse the graph till no connected vertex are left</span>\r\n            <span class=\"hljs-comment\">/// extract a node from queue for further traversal</span>\r\n            T node = tracker.<span class=\"hljs-built_in\">front</span>();\r\n            <span class=\"hljs-comment\">/// remove the node from the queue</span>\r\n            tracker.<span class=\"hljs-built_in\">pop</span>();\r\n            <span class=\"hljs-keyword\">for</span> (T <span class=\"hljs-type\">const</span> &amp;neighbour : adjacency_list[node]) {\r\n                <span class=\"hljs-comment\">/// check every vertex connected to the node which are still</span>\r\n                <span class=\"hljs-comment\">/// unvisited</span>\r\n                <span class=\"hljs-keyword\">if</span> (!visited[neighbour]) {\r\n                    <span class=\"hljs-comment\">/// if the neighbour is unvisited , push it into the queue</span>\r\n                    tracker.<span class=\"hljs-built_in\">push</span>(neighbour);\r\n                    <span class=\"hljs-comment\">/// mark the neighbour as visited</span>\r\n                    visited[neighbour] = <span class=\"hljs-literal\">true</span>;\r\n                }\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> visited;\r\n    }\r\n};\r\n<span class=\"hljs-comment\">/* Class definition ends */</span>\r\n}  <span class=\"hljs-comment\">// namespace graph</span>\r\n\r\n<span class=\"hljs-comment\">/** Test function */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">tests</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-comment\">/// Test 1 Begin</span>\r\n    graph::Graph&lt;<span class=\"hljs-type\">int</span>&gt; g;\r\n    std::map&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">bool</span>&gt; correct_result;\r\n    g.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>);\r\n    g.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\r\n    g.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\r\n    correct_result[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-literal\">true</span>;\r\n    correct_result[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-literal\">true</span>;\r\n    correct_result[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-literal\">true</span>;\r\n    correct_result[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-literal\">true</span>;\r\n\r\n    std::map&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">bool</span>&gt; returned_result = g.<span class=\"hljs-built_in\">breadth_first_search</span>(<span class=\"hljs-number\">2</span>);\r\n\r\n    <span class=\"hljs-built_in\">assert</span>(returned_result == correct_result);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1 Passed...&quot;</span> &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-comment\">/// Test 2 Begin</span>\r\n    returned_result = g.<span class=\"hljs-built_in\">breadth_first_search</span>(<span class=\"hljs-number\">0</span>);\r\n\r\n    <span class=\"hljs-built_in\">assert</span>(returned_result == correct_result);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2 Passed...&quot;</span> &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-comment\">/// Test 3 Begins</span>\r\n    graph::Graph&lt;std::string&gt; g2;\r\n\r\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Gorakhpur&quot;</span>, <span class=\"hljs-string\">&quot;Lucknow&quot;</span>, <span class=\"hljs-literal\">false</span>);\r\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Gorakhpur&quot;</span>, <span class=\"hljs-string\">&quot;Kanpur&quot;</span>, <span class=\"hljs-literal\">false</span>);\r\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Lucknow&quot;</span>, <span class=\"hljs-string\">&quot;Agra&quot;</span>, <span class=\"hljs-literal\">false</span>);\r\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Kanpur&quot;</span>, <span class=\"hljs-string\">&quot;Agra&quot;</span>, <span class=\"hljs-literal\">false</span>);\r\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Lucknow&quot;</span>, <span class=\"hljs-string\">&quot;Prayagraj&quot;</span>, <span class=\"hljs-literal\">false</span>);\r\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Agra&quot;</span>, <span class=\"hljs-string\">&quot;Noida&quot;</span>, <span class=\"hljs-literal\">false</span>);\r\n\r\n    std::map&lt;std::string, <span class=\"hljs-type\">bool</span>&gt; correct_res;\r\n    std::map&lt;std::string, <span class=\"hljs-type\">bool</span>&gt; returned_res =\r\n        g2.<span class=\"hljs-built_in\">breadth_first_search</span>(<span class=\"hljs-string\">&quot;Kanpur&quot;</span>);\r\n    correct_res[<span class=\"hljs-string\">&quot;Gorakhpur&quot;</span>] = <span class=\"hljs-literal\">false</span>;\r\n    correct_res[<span class=\"hljs-string\">&quot;Lucknow&quot;</span>] = <span class=\"hljs-literal\">false</span>;\r\n    correct_res[<span class=\"hljs-string\">&quot;Kanpur&quot;</span>] = <span class=\"hljs-literal\">true</span>;\r\n    correct_res[<span class=\"hljs-string\">&quot;Agra&quot;</span>] = <span class=\"hljs-literal\">true</span>;\r\n    correct_res[<span class=\"hljs-string\">&quot;Prayagraj&quot;</span>] = <span class=\"hljs-literal\">false</span>;\r\n    correct_res[<span class=\"hljs-string\">&quot;Noida&quot;</span>] = <span class=\"hljs-literal\">true</span>;\r\n    <span class=\"hljs-built_in\">assert</span>(correct_res == returned_res);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 3 Passed...&quot;</span> &lt;&lt; std::endl;\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Main function */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-built_in\">tests</span>();\r\n    <span class=\"hljs-type\">size_t</span> edges = <span class=\"hljs-number\">0</span>;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the number of edges: &quot;</span>;\r\n    std::cin &gt;&gt; edges;\r\n\r\n    graph::Graph&lt;<span class=\"hljs-type\">int</span>&gt; g;\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter space-separated pairs of vertices that form edges: &quot;</span>\r\n              &lt;&lt; std::endl;\r\n    <span class=\"hljs-keyword\">while</span> (edges--) {\r\n        <span class=\"hljs-type\">int</span> u = <span class=\"hljs-number\">0</span>, v = <span class=\"hljs-number\">0</span>;\r\n        std::cin &gt;&gt; u &gt;&gt; v;\r\n        g.<span class=\"hljs-built_in\">add_edge</span>(u, v);\r\n    }\r\n\r\n    g.<span class=\"hljs-built_in\">breadth_first_search</span>(<span class=\"hljs-number\">0</span>);\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    },
    "java": {
      "dir": "src\\main\\java\\com\\thealgorithms\\searches\\BreadthFirstSearch.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src\\main\\java\\com\\thealgorithms\\searches\\BreadthFirstSearch.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.searches;\r\n\r\n<span class=\"hljs-keyword\">import</span> com.thealgorithms.searches.DepthFirstSearch.Node;\r\n\r\n<span class=\"hljs-keyword\">import</span> java.util.ArrayList;\r\n<span class=\"hljs-keyword\">import</span> java.util.List;\r\n<span class=\"hljs-keyword\">import</span> java.util.Objects;\r\n<span class=\"hljs-keyword\">import</span> java.util.Optional;\r\n\r\n<span class=\"hljs-comment\">/**\r\n * <span class=\"hljs-doctag\">@author</span>: caos321\r\n * <span class=\"hljs-doctag\">@date</span>: 31 October 2021 (Sunday)\r\n */</span>\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BreadthFirstSearch</span> {\r\n\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Optional&lt;Node&gt; <span class=\"hljs-title function_\">search</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> Node node, <span class=\"hljs-keyword\">final</span> String name)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (node.getName().equals(name)) {\r\n            <span class=\"hljs-keyword\">return</span> Optional.of(node);\r\n        }\r\n\r\n        List&lt;Node&gt; queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;(node.getSubNodes());\r\n\r\n        <span class=\"hljs-keyword\">while</span> (!queue.isEmpty()) {\r\n            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">current</span> <span class=\"hljs-operator\">=</span> queue.get(<span class=\"hljs-number\">0</span>);\r\n\r\n            <span class=\"hljs-keyword\">if</span> (current.getName().equals(name)) {\r\n                <span class=\"hljs-keyword\">return</span> Optional.of(current);\r\n            }\r\n\r\n            queue.addAll(current.getSubNodes());\r\n\r\n            queue.remove(<span class=\"hljs-number\">0</span>);\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">return</span> Optional.empty();\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">assertThat</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> Object actual, <span class=\"hljs-keyword\">final</span> Object expected)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (!Objects.equals(actual, expected)) {\r\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AssertionError</span>(String.format(<span class=\"hljs-string\">&quot;expected=%s but was actual=%s&quot;</span>, expected, actual));\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> String[] args)</span> {\r\n        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">rootNode</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;A&quot;</span>, List.of(\r\n                <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;B&quot;</span>, List.of(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;D&quot;</span>), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;F&quot;</span>, List.of(\r\n                        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;H&quot;</span>), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;I&quot;</span>)\r\n                )))),\r\n                <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;C&quot;</span>, List.of(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;G&quot;</span>))),\r\n                <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;E&quot;</span>)\r\n        ));\r\n\r\n        {\r\n            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">expected</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;I&quot;</span>;\r\n\r\n            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> search(rootNode, expected)\r\n                    .orElseThrow(() -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AssertionError</span>(<span class=\"hljs-string\">&quot;Node not found!&quot;</span>));\r\n\r\n            assertThat(result.getName(), expected);\r\n        }\r\n\r\n        {\r\n            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">expected</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;G&quot;</span>;\r\n\r\n            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> search(rootNode, expected)\r\n                    .orElseThrow(() -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AssertionError</span>(<span class=\"hljs-string\">&quot;Node not found!&quot;</span>));\r\n\r\n            assertThat(result.getName(), expected);\r\n        }\r\n\r\n        {\r\n            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">expected</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;E&quot;</span>;\r\n\r\n            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> search(rootNode, expected)\r\n                    .orElseThrow(() -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AssertionError</span>(<span class=\"hljs-string\">&quot;Node not found!&quot;</span>));\r\n\r\n            assertThat(result.getName(), expected);\r\n        }\r\n    }\r\n}\r\n"
    },
    "go": {
      "dir": "graph\\breadthfirstsearch.go",
      "url": "https://github.com/TheAlgorithms/go/tree/master/graph\\breadthfirstsearch.go",
      "code": "<span class=\"hljs-keyword\">package</span> graph\r\n\r\n<span class=\"hljs-comment\">// BreadthFirstSearch is an algorithm for traversing and searching graph data structures.</span>\r\n<span class=\"hljs-comment\">// It starts at an arbitrary node of a graph, and explores all of the neighbor nodes</span>\r\n<span class=\"hljs-comment\">// at the present depth prior to moving on to the nodes at the next depth level.</span>\r\n<span class=\"hljs-comment\">// Worst-case performance\t \t\tO(|V|+|E|)=O(b^{d})}O(|V|+|E|)=O(b^{d})</span>\r\n<span class=\"hljs-comment\">// Worst-case space complexity\t \tO(|V|)=O(b^{d})}O(|V|)=O(b^{d})</span>\r\n<span class=\"hljs-comment\">// reference: https://en.wikipedia.org/wiki/Breadth-first_search</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">BreadthFirstSearch</span><span class=\"hljs-params\">(start, end, nodes <span class=\"hljs-type\">int</span>, edges [][]<span class=\"hljs-type\">int</span>)</span></span> (isConnected <span class=\"hljs-type\">bool</span>, distance <span class=\"hljs-type\">int</span>) {\r\n\tqueue := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">0</span>)\r\n\tdiscovered := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, nodes)\r\n\tdiscovered[start] = <span class=\"hljs-number\">1</span>\r\n\tqueue = <span class=\"hljs-built_in\">append</span>(queue, start)\r\n\t<span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">len</span>(queue) &gt; <span class=\"hljs-number\">0</span> {\r\n\t\tv := queue[<span class=\"hljs-number\">0</span>]\r\n\t\tqueue = queue[<span class=\"hljs-number\">1</span>:]\r\n\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(edges[v]); i++ {\r\n\t\t\t<span class=\"hljs-keyword\">if</span> discovered[i] == <span class=\"hljs-number\">0</span> &amp;&amp; edges[v][i] &gt; <span class=\"hljs-number\">0</span> {\r\n\t\t\t\t<span class=\"hljs-keyword\">if</span> i == end {\r\n\t\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>, discovered[v]\r\n\t\t\t\t}\r\n\t\t\t\tdiscovered[i] = discovered[v] + <span class=\"hljs-number\">1</span>\r\n\t\t\t\tqueue = <span class=\"hljs-built_in\">append</span>(queue, i)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>, <span class=\"hljs-number\">0</span>\r\n}\r\n"
    },
    "rust": {
      "dir": "src\\graph\\breadth_first_search.rs",
      "url": "https://github.com/TheAlgorithms/rust/tree/master/src\\graph\\breadth_first_search.rs",
      "code": "<span class=\"hljs-keyword\">use</span> std::collections::HashSet;\r\n<span class=\"hljs-keyword\">use</span> std::collections::VecDeque;\r\n\r\n<span class=\"hljs-comment\">/// Perform a breadth-first search on Graph `graph`.</span>\r\n<span class=\"hljs-comment\">///</span>\r\n<span class=\"hljs-comment\">/// # Parameters</span>\r\n<span class=\"hljs-comment\">///</span>\r\n<span class=\"hljs-comment\">/// - `graph`: The graph to search.</span>\r\n<span class=\"hljs-comment\">/// - `root`: The starting node of the graph from which to begin searching.</span>\r\n<span class=\"hljs-comment\">/// - `target`: The target node for the search.</span>\r\n<span class=\"hljs-comment\">///</span>\r\n<span class=\"hljs-comment\">/// # Returns</span>\r\n<span class=\"hljs-comment\">///</span>\r\n<span class=\"hljs-comment\">/// If the target is found, an Optional vector is returned with the history</span>\r\n<span class=\"hljs-comment\">/// of nodes visited as its contents.</span>\r\n<span class=\"hljs-comment\">///</span>\r\n<span class=\"hljs-comment\">/// If the target is not found or there is no path from the root,</span>\r\n<span class=\"hljs-comment\">/// `None` is returned.</span>\r\n<span class=\"hljs-comment\">///</span>\r\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">breadth_first_search</span>(graph: &amp;Graph, root: Node, target: Node) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Option</span>&lt;<span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">u32</span>&gt;&gt; {\r\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">visited</span>: HashSet&lt;Node&gt; = HashSet::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">history</span>: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">u32</span>&gt; = Vec::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">queue</span> = VecDeque::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n\r\n    visited.<span class=\"hljs-title function_ invoke__\">insert</span>(root);\r\n    queue.<span class=\"hljs-title function_ invoke__\">push_back</span>(root);\r\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">Some</span>(currentnode) = queue.<span class=\"hljs-title function_ invoke__\">pop_front</span>() {\r\n        history.<span class=\"hljs-title function_ invoke__\">push</span>(currentnode.<span class=\"hljs-title function_ invoke__\">value</span>());\r\n\r\n        <span class=\"hljs-comment\">// If we reach the goal, return our travel history.</span>\r\n        <span class=\"hljs-keyword\">if</span> currentnode == target {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_ invoke__\">Some</span>(history);\r\n        }\r\n\r\n        <span class=\"hljs-comment\">// Check the neighboring nodes for any that we&#x27;ve not visited yet.</span>\r\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">neighbor</span> <span class=\"hljs-keyword\">in</span> currentnode.<span class=\"hljs-title function_ invoke__\">neighbors</span>(graph) {\r\n            <span class=\"hljs-keyword\">if</span> !visited.<span class=\"hljs-title function_ invoke__\">contains</span>(&amp;neighbor) {\r\n                visited.<span class=\"hljs-title function_ invoke__\">insert</span>(neighbor);\r\n                queue.<span class=\"hljs-title function_ invoke__\">push_back</span>(neighbor);\r\n            }\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// All nodes were visited, yet the target was not found.</span>\r\n    <span class=\"hljs-literal\">None</span>\r\n}\r\n\r\n<span class=\"hljs-comment\">// Data Structures</span>\r\n\r\n<span class=\"hljs-meta\">#[derive(Copy, Clone, PartialEq, Eq, Hash)]</span>\r\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-type\">u32</span>);\r\n\r\n<span class=\"hljs-meta\">#[derive(Copy, Clone, PartialEq, Eq, Hash)]</span>\r\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Edge</span>(<span class=\"hljs-type\">u32</span>, <span class=\"hljs-type\">u32</span>);\r\n\r\n<span class=\"hljs-meta\">#[derive(Clone)]</span>\r\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Graph</span> {\r\n    <span class=\"hljs-meta\">#[allow(dead_code)]</span>\r\n    nodes: <span class=\"hljs-type\">Vec</span>&lt;Node&gt;,\r\n    edges: <span class=\"hljs-type\">Vec</span>&lt;Edge&gt;,\r\n}\r\n\r\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Graph</span> {\r\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">new</span>(nodes: <span class=\"hljs-type\">Vec</span>&lt;Node&gt;, edges: <span class=\"hljs-type\">Vec</span>&lt;Edge&gt;) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\r\n        Graph { nodes, edges }\r\n    }\r\n}\r\n\r\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">From</span>&lt;<span class=\"hljs-type\">u32</span>&gt; <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Node</span> {\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">from</span>(item: <span class=\"hljs-type\">u32</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\r\n        <span class=\"hljs-title function_ invoke__\">Node</span>(item)\r\n    }\r\n}\r\n\r\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Node</span> {\r\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">value</span>(&amp;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">u32</span> {\r\n        <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">neighbors</span>(&amp;<span class=\"hljs-keyword\">self</span>, graph: &amp;Graph) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Vec</span>&lt;Node&gt; {\r\n        graph\r\n            .edges\r\n            .<span class=\"hljs-title function_ invoke__\">iter</span>()\r\n            .<span class=\"hljs-title function_ invoke__\">filter</span>(|e| e.<span class=\"hljs-number\">0</span> == <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>)\r\n            .<span class=\"hljs-title function_ invoke__\">map</span>(|e| e.<span class=\"hljs-number\">1</span>.<span class=\"hljs-title function_ invoke__\">into</span>())\r\n            .<span class=\"hljs-title function_ invoke__\">collect</span>()\r\n    }\r\n}\r\n\r\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">From</span>&lt;(<span class=\"hljs-type\">u32</span>, <span class=\"hljs-type\">u32</span>)&gt; <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Edge</span> {\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">from</span>(item: (<span class=\"hljs-type\">u32</span>, <span class=\"hljs-type\">u32</span>)) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\r\n        <span class=\"hljs-title function_ invoke__\">Edge</span>(item.<span class=\"hljs-number\">0</span>, item.<span class=\"hljs-number\">1</span>)\r\n    }\r\n}\r\n\r\n<span class=\"hljs-meta\">#[cfg(test)]</span>\r\n<span class=\"hljs-keyword\">mod</span> tests {\r\n    <span class=\"hljs-keyword\">use</span> super::*;\r\n\r\n    <span class=\"hljs-comment\">/* Example graph #1:\r\n     *\r\n     *            (1)   &lt;--- Root\r\n     *           /   \\\r\n     *         (2)   (3)\r\n     *        / |     | \\\r\n     *     (4) (5)   (6) (7)\r\n     *          |\r\n     *         (8)\r\n     */</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">graph1</span>() <span class=\"hljs-punctuation\">-&gt;</span> Graph {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">nodes</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>];\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">edges</span> = <span class=\"hljs-built_in\">vec!</span>[(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>), (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>), (<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>), (<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>), (<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>), (<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>), (<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>)];\r\n\r\n        Graph::<span class=\"hljs-title function_ invoke__\">new</span>(\r\n            nodes.<span class=\"hljs-title function_ invoke__\">into_iter</span>().<span class=\"hljs-title function_ invoke__\">map</span>(|v| v.<span class=\"hljs-title function_ invoke__\">into</span>()).<span class=\"hljs-title function_ invoke__\">collect</span>(),\r\n            edges.<span class=\"hljs-title function_ invoke__\">into_iter</span>().<span class=\"hljs-title function_ invoke__\">map</span>(|e| e.<span class=\"hljs-title function_ invoke__\">into</span>()).<span class=\"hljs-title function_ invoke__\">collect</span>(),\r\n        )\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">breadth_first_search_graph1_when_node_not_found_returns_none</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">graph</span> = <span class=\"hljs-title function_ invoke__\">graph1</span>();\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">root</span> = <span class=\"hljs-number\">1</span>;\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">target</span> = <span class=\"hljs-number\">10</span>;\r\n\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(\r\n            <span class=\"hljs-title function_ invoke__\">breadth_first_search</span>(&amp;graph, root.<span class=\"hljs-title function_ invoke__\">into</span>(), target.<span class=\"hljs-title function_ invoke__\">into</span>()),\r\n            <span class=\"hljs-literal\">None</span>\r\n        );\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">breadth_first_search_graph1_when_target_8_should_evaluate_all_nodes_first</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">graph</span> = <span class=\"hljs-title function_ invoke__\">graph1</span>();\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">root</span> = <span class=\"hljs-number\">1</span>;\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">target</span> = <span class=\"hljs-number\">8</span>;\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">expected_path</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>];\r\n\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(\r\n            <span class=\"hljs-title function_ invoke__\">breadth_first_search</span>(&amp;graph, root.<span class=\"hljs-title function_ invoke__\">into</span>(), target.<span class=\"hljs-title function_ invoke__\">into</span>()),\r\n            <span class=\"hljs-title function_ invoke__\">Some</span>(expected_path)\r\n        );\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/* Example graph #2:\r\n     *\r\n     *     (1) --- (2)     (3) --- (4)\r\n     *            / |     /       /\r\n     *          /   |   /       /\r\n     *        /     | /       /\r\n     *     (5)     (6) --- (7)     (8)\r\n     */</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">graph2</span>() <span class=\"hljs-punctuation\">-&gt;</span> Graph {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">nodes</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>];\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">undirected_edges</span> = <span class=\"hljs-built_in\">vec!</span>[\r\n            (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>),\r\n            (<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>),\r\n            (<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>),\r\n            (<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>),\r\n            (<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">6</span>),\r\n            (<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>),\r\n            (<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>),\r\n            (<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>),\r\n            (<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>),\r\n            (<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">3</span>),\r\n            (<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">7</span>),\r\n            (<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">4</span>),\r\n            (<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>),\r\n            (<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">6</span>),\r\n        ];\r\n\r\n        Graph::<span class=\"hljs-title function_ invoke__\">new</span>(\r\n            nodes.<span class=\"hljs-title function_ invoke__\">into_iter</span>().<span class=\"hljs-title function_ invoke__\">map</span>(|v| v.<span class=\"hljs-title function_ invoke__\">into</span>()).<span class=\"hljs-title function_ invoke__\">collect</span>(),\r\n            undirected_edges.<span class=\"hljs-title function_ invoke__\">into_iter</span>().<span class=\"hljs-title function_ invoke__\">map</span>(|e| e.<span class=\"hljs-title function_ invoke__\">into</span>()).<span class=\"hljs-title function_ invoke__\">collect</span>(),\r\n        )\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">breadth_first_search_graph2_when_no_path_to_node_returns_none</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">graph</span> = <span class=\"hljs-title function_ invoke__\">graph2</span>();\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">root</span> = <span class=\"hljs-number\">8</span>;\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">target</span> = <span class=\"hljs-number\">4</span>;\r\n\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(\r\n            <span class=\"hljs-title function_ invoke__\">breadth_first_search</span>(&amp;graph, root.<span class=\"hljs-title function_ invoke__\">into</span>(), target.<span class=\"hljs-title function_ invoke__\">into</span>()),\r\n            <span class=\"hljs-literal\">None</span>\r\n        );\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">breadth_first_search_graph2_should_find_path_from_4_to_1</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">graph</span> = <span class=\"hljs-title function_ invoke__\">graph2</span>();\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">root</span> = <span class=\"hljs-number\">4</span>;\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">target</span> = <span class=\"hljs-number\">1</span>;\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">expected_path</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>];\r\n\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(\r\n            <span class=\"hljs-title function_ invoke__\">breadth_first_search</span>(&amp;graph, root.<span class=\"hljs-title function_ invoke__\">into</span>(), target.<span class=\"hljs-title function_ invoke__\">into</span>()),\r\n            <span class=\"hljs-title function_ invoke__\">Some</span>(expected_path)\r\n        );\r\n    }\r\n}\r\n"
    },
    "dart": {
      "dir": "graphs\\breadth_first_search.dart",
      "url": "https://github.com/TheAlgorithms/dart/tree/master/graphs\\breadth_first_search.dart",
      "code": "<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;dart:collection&#x27;</span>;\r\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;package:test/test.dart&#x27;</span>;\r\n\r\n<span class=\"hljs-comment\">/// <span class=\"language-markdown\">Implementation of Breadth First Search</span></span>\r\n<span class=\"hljs-comment\">/// <span class=\"language-markdown\">https://en.wikipedia.org/wiki/Breadth-first<span class=\"hljs-emphasis\">_search</span></span></span>\r\n\r\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Graph</span> </span>{\r\n  <span class=\"hljs-comment\">/// <span class=\"language-markdown\"><span class=\"hljs-emphasis\">Adjacency List representation using dynamic list and HashMap</span></span></span>\r\n  HashMap graph = <span class=\"hljs-keyword\">new</span> HashMap&lt;<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">dynamic</span>&gt;&gt;();\r\n  <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; nodes;\r\n\r\n  <span class=\"hljs-keyword\">void</span> makeGraph() {\r\n    <span class=\"hljs-comment\">/// <span class=\"language-markdown\"><span class=\"hljs-emphasis\">initialise all nodes with empty lists.</span></span></span>\r\n    <span class=\"hljs-comment\">/// <span class=\"language-markdown\"><span class=\"hljs-emphasis\">each node will have a list as value which stores</span></span></span>\r\n    <span class=\"hljs-comment\">/// <span class=\"language-markdown\"><span class=\"hljs-emphasis\">the nodes to which it is connected to</span></span></span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-keyword\">this</span>.nodes.length; i++) {\r\n      <span class=\"hljs-keyword\">this</span>.graph[nodes[i]] = <span class=\"hljs-built_in\">List</span>();\r\n    }\r\n  }\r\n\r\n  Graph(<span class=\"hljs-keyword\">this</span>.nodes) {\r\n    <span class=\"hljs-keyword\">this</span>.makeGraph();\r\n  }\r\n\r\n  <span class=\"hljs-built_in\">int</span> <span class=\"hljs-keyword\">get</span> numberOfNodesInGraph {\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.nodes.length;\r\n  }\r\n\r\n  HashMap <span class=\"hljs-keyword\">get</span> graphDataStructure {\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.graph;\r\n  }\r\n\r\n  <span class=\"hljs-keyword\">void</span> addNodes(<span class=\"hljs-built_in\">int</span> newNode) {\r\n    <span class=\"hljs-keyword\">this</span>.nodes.add(newNode);\r\n    <span class=\"hljs-keyword\">this</span>.graph[newNode] = <span class=\"hljs-built_in\">List</span>();\r\n  }\r\n\r\n  <span class=\"hljs-keyword\">void</span> addEdges(<span class=\"hljs-built_in\">int</span> start, <span class=\"hljs-built_in\">int</span> end) {\r\n    <span class=\"hljs-keyword\">this</span>.graph[start].add(end);\r\n  }\r\n}\r\n\r\n<span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; breadthFirstSearch(Graph graph, <span class=\"hljs-built_in\">int</span> numberOfNodes, <span class=\"hljs-built_in\">int</span> startNode) {\r\n  Queue queue = <span class=\"hljs-keyword\">new</span> Queue&lt;<span class=\"hljs-built_in\">int</span>&gt;();\r\n  <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; answer = <span class=\"hljs-built_in\">List</span>();\r\n  queue.add(startNode);\r\n  <span class=\"hljs-keyword\">while</span> (queue.isNotEmpty) {\r\n    <span class=\"hljs-built_in\">int</span> node = queue.removeFirst();\r\n    answer.add(node);\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> child <span class=\"hljs-keyword\">in</span> graph.graph[node]) {\r\n      queue.add(child);\r\n    }\r\n  }\r\n  <span class=\"hljs-keyword\">return</span> answer;\r\n}\r\n\r\n<span class=\"hljs-keyword\">void</span> main() {\r\n  test((<span class=\"hljs-string\">&#x27;Test case 1:&#x27;</span>), () {\r\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; nodes = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\r\n    <span class=\"hljs-built_in\">int</span> numberOfEdges = <span class=\"hljs-number\">2</span>;\r\n\r\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt;&gt; edges = [\r\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],\r\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>]\r\n    ];\r\n    Graph graph = Graph(nodes);\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; numberOfEdges; i++) {\r\n      <span class=\"hljs-built_in\">int</span> start = edges[i][<span class=\"hljs-number\">0</span>];\r\n      <span class=\"hljs-built_in\">int</span> end = edges[i][<span class=\"hljs-number\">1</span>];\r\n      graph.addEdges(start, end);\r\n    }\r\n    <span class=\"hljs-built_in\">int</span> startNode = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; answer =\r\n        breadthFirstSearch(graph, graph.numberOfNodesInGraph, startNode);\r\n    expect(answer, equals([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]));\r\n  });\r\n\r\n  test((<span class=\"hljs-string\">&#x27;Test case 2:&#x27;</span>), () {\r\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; nodes = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\r\n    <span class=\"hljs-built_in\">int</span> numberOfEdges = <span class=\"hljs-number\">4</span>;\r\n\r\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt;&gt; edges = [\r\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],\r\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>],\r\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>],\r\n      [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>]\r\n    ];\r\n    Graph graph = Graph(nodes);\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; numberOfEdges; i++) {\r\n      <span class=\"hljs-built_in\">int</span> start = edges[i][<span class=\"hljs-number\">0</span>];\r\n      <span class=\"hljs-built_in\">int</span> end = edges[i][<span class=\"hljs-number\">1</span>];\r\n      graph.addEdges(start, end);\r\n    }\r\n    <span class=\"hljs-built_in\">int</span> startNode = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; answer =\r\n        breadthFirstSearch(graph, graph.numberOfNodesInGraph, startNode);\r\n    expect(answer, equals([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]));\r\n  });\r\n}\r\n"
    },
    "c-sharp": {
      "dir": "./Algorithms/Graph/BreadthFirstSearch.cs",
      "url": "https:\\github.com\\TheAlgorithms\\C-Sharp\\tree\\master\\Algorithms\\Graph\\BreadthFirstSearch.cs",
      "code": "<span class=\"hljs-keyword\">using</span> System;\r\n<span class=\"hljs-keyword\">using</span> System.Collections.Generic;\r\n<span class=\"hljs-keyword\">using</span> DataStructures.Graph;\r\n\r\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">Algorithms.Graph</span>\r\n{\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> Breadth First Search - algorithm for traversing graph.</span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> Algorithm starts from root node that is selected by the user.</span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> Algorithm explores all nodes at the present depth.</span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;typeparam name=&quot;T&quot;&gt;</span>Vertex data type.<span class=\"hljs-doctag\">&lt;/typeparam&gt;</span></span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BreadthFirstSearch</span>&lt;<span class=\"hljs-title\">T</span>&gt; : <span class=\"hljs-title\">IGraphSearch</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">where</span> <span class=\"hljs-title\">T</span> : <span class=\"hljs-title\">IComparable</span>&lt;<span class=\"hljs-title\">T</span>&gt;\r\n    {\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> Traverses graph from start vertex.</span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;graph&quot;&gt;</span>Graph instance.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;startVertex&quot;&gt;</span>Vertex that search starts from.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;action&quot;&gt;</span>Action that needs to be executed on each graph vertex.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">VisitAll</span>(<span class=\"hljs-params\">IDirectedWeightedGraph&lt;T&gt; graph, Vertex&lt;T&gt; startVertex, Action&lt;Vertex&lt;T&gt;&gt;? action = <span class=\"hljs-literal\">default</span></span>)</span>\r\n        {\r\n            Bfs(graph, startVertex, action, <span class=\"hljs-keyword\">new</span> HashSet&lt;Vertex&lt;T&gt;&gt;());\r\n        }\r\n\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> Traverses graph from start vertex.</span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;graph&quot;&gt;</span>Graph instance.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;startVertex&quot;&gt;</span>Vertex that search starts from.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;action&quot;&gt;</span>Action that needs to be executed on each graph vertex.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;visited&quot;&gt;</span>Hash set with visited vertices.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Bfs</span>(<span class=\"hljs-params\">IDirectedWeightedGraph&lt;T&gt; graph, Vertex&lt;T&gt; startVertex, Action&lt;Vertex&lt;T&gt;&gt;? action, HashSet&lt;Vertex&lt;T&gt;&gt; visited</span>)</span>\r\n        {\r\n            <span class=\"hljs-keyword\">var</span> queue = <span class=\"hljs-keyword\">new</span> Queue&lt;Vertex&lt;T&gt;&gt;();\r\n\r\n            queue.Enqueue(startVertex);\r\n\r\n            <span class=\"hljs-keyword\">while</span> (queue.Count &gt; <span class=\"hljs-number\">0</span>)\r\n            {\r\n                <span class=\"hljs-keyword\">var</span> currentVertex = queue.Dequeue();\r\n\r\n                <span class=\"hljs-keyword\">if</span> (currentVertex == <span class=\"hljs-literal\">null</span> || visited.Contains(currentVertex))\r\n                {\r\n                    <span class=\"hljs-keyword\">continue</span>;\r\n                }\r\n\r\n                <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> vertex <span class=\"hljs-keyword\">in</span> graph.GetNeighbors(currentVertex))\r\n                {\r\n                    queue.Enqueue(vertex!);\r\n                }\r\n\r\n                action?.Invoke(currentVertex);\r\n\r\n                visited.Add(currentVertex);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Anup Kumar Panwar",
      "email": "1anuppanwar@gmail.com",
      "commits": 1
    },
    {
      "name": "scturtle",
      "email": "scturtle@gmail.com",
      "commits": 1
    },
    {
      "name": "Joshua Ford",
      "email": "joshua.ford@protonmail.com",
      "commits": 1
    },
    {
      "name": "AlexDvorak",
      "email": "opti.jawsome@gmail.com",
      "commits": 1
    },
    {
      "name": "BohdanLev",
      "email": "43375672+BohdanLev@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Akash G Krishnan",
      "email": "krishnanag1996@gmail.com",
      "commits": 1
    },
    {
      "name": "Simon Berndtsson",
      "email": "simon.berndtsson@gmail.com",
      "commits": 1
    },
    {
      "name": "Taj",
      "email": "tjgurwara99@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Brayo",
      "email": "vukubrian@gmail.com",
      "commits": 1
    },
    {
      "name": "Kaveh Fazaeli",
      "email": "kaveh.fazaeli@gmail.com",
      "commits": 1
    },
    {
      "name": "hasan",
      "email": "hasanuli10@gmail.com",
      "commits": 1
    },
    {
      "name": "ParthS007",
      "email": "parth1989shandilya@gmail.com",
      "commits": 1
    },
    {
      "name": "caos321",
      "email": "36530240+caos321@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Kaustubh Damania",
      "email": "kaustubh.damania@gmail.com",
      "commits": 1
    },
    {
      "name": "gpamangkp",
      "email": "gpamangkp.18je0087@mc.iitism.ac.in",
      "commits": 1
    },
    {
      "name": "Rohan R Bharadwaj",
      "email": "rohanrbharadwaj@gmail.com",
      "commits": 1
    },
    {
      "name": "Casper Rysgaard",
      "email": "Crowton@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Lewis Tian",
      "email": "taseikyo@gmail.com",
      "commits": 1
    },
    {
      "name": "Sanders Lin",
      "email": "45224617+SandersLin@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "cclauss",
      "email": "cclauss@bluewin.ch",
      "commits": 1
    },
    {
      "name": "97arushisharma",
      "email": "97arushisharma@gmail.com",
      "commits": 1
    },
    {
      "name": "mounaim",
      "email": "mounaim.zaryouhi@gmail.com",
      "commits": 1
    },
    {
      "name": "algobytewise",
      "email": "algobytewise@gmail.com",
      "commits": 2
    },
    {
      "name": "rxaru",
      "email": "ai.kanaria.ai@gmail.com",
      "commits": 2
    },
    {
      "name": "Roland Hummel",
      "email": "roland.hummel@qaware.de",
      "commits": 2
    },
    {
      "name": "Alvin Nguyen",
      "email": "alvin@D-10-16-24-223.dhcp4.washington.edu",
      "commits": 2
    },
    {
      "name": "Francisco Matias",
      "email": "franciscomatias@alu.ufc.br",
      "commits": 2
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 3
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 4
    },
    {
      "name": "Gpamangkp",
      "email": "41160734+Gpamangkp@users.noreply.github.com",
      "commits": 7
    }
  ],
  "explanationUrl": {}
}