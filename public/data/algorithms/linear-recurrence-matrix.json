{
  "slug": "linear-recurrence-matrix",
  "name": "Linear Recurrence Matrix",
  "categories": [
    "math"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "math\\linear_recurrence_matrix.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/math\\linear_recurrence_matrix.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @brief Evaluate recurrence relation using [matrix\r\n * exponentiation](https://www.hackerearth.com/practice/notes/matrix-exponentiation-1/).\r\n * @details\r\n * Given a recurrence relation; evaluate the value of nth term.\r\n * For e.g., For fibonacci series, recurrence series is `f(n) = f(n-1) + f(n-2)`\r\n * where `f(0) = 0` and `f(1) = 1`.\r\n * Note that the method used only demonstrates\r\n * recurrence relation with one variable (n), unlike `nCr` problem, since it has\r\n * two (n, r)\r\n *\r\n * ### Algorithm\r\n * This problem can be solved using matrix exponentiation method.\r\n * @see here for simple [number exponentiation\r\n * algorithm](https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/modular_exponentiation.cpp)\r\n * or [explaination\r\n * here](https://en.wikipedia.org/wiki/Exponentiation_by_squaring).\r\n * @author [Ashish Daulatabad](https://github.com/AshishYUO)\r\n */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>   <span class=\"hljs-comment\">/// for assert</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">/// for IO operations</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>    <span class=\"hljs-comment\">/// for std::vector STL</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace math\r\n * @brief Mathematical algorithms\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> math {\r\n<span class=\"hljs-comment\">/**\r\n * @namespace linear_recurrence_matrix\r\n * @brief Functions for [Linear Recurrence\r\n * Matrix](https://www.hackerearth.com/practice/notes/matrix-exponentiation-1/)\r\n * implementation.\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> linear_recurrence_matrix {\r\n<span class=\"hljs-comment\">/**\r\n * @brief Implementation of matrix multiplication\r\n * @details Multiplies matrix A and B, given total columns in A are equal to\r\n * total given rows in column B\r\n * @tparam T template type for integer as well as floating values, default is\r\n * long long int\r\n * @param _mat_a first matrix of size n * m\r\n * @param _mat_b second matrix of size m * k\r\n * @returns `_mat_c` resultant matrix of size n * k\r\n * Complexity: `O(n*m*k)`\r\n * @note The complexity in this case will be O(n^3) due to the nature of the\r\n * problem. We&#x27;ll be multiplying the matrix with itself most of the time.\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T = <span class=\"hljs-type\">int64_t</span>&gt;\r\nstd::vector&lt;std::vector&lt;T&gt;&gt; <span class=\"hljs-built_in\">matrix_multiplication</span>(\r\n    <span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;T&gt;&gt;&amp; _mat_a,\r\n    <span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;T&gt;&gt;&amp; _mat_b, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int64_t</span> mod = <span class=\"hljs-number\">1000000007</span>) {\r\n    <span class=\"hljs-comment\">// assert that columns in `_mat_a` and rows in `_mat_b` are equal</span>\r\n    <span class=\"hljs-built_in\">assert</span>(_mat_a[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>() == _mat_b.<span class=\"hljs-built_in\">size</span>());\r\n    std::vector&lt;std::vector&lt;T&gt;&gt; _mat_c(_mat_a.<span class=\"hljs-built_in\">size</span>(),\r\n                                       std::<span class=\"hljs-built_in\">vector</span>&lt;T&gt;(_mat_b[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>(), <span class=\"hljs-number\">0</span>));\r\n    <span class=\"hljs-comment\">/**\r\n     * Actual matrix multiplication.\r\n     */</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; _mat_a.<span class=\"hljs-built_in\">size</span>(); ++i) {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; _mat_b[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>(); ++j) {\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> k = <span class=\"hljs-number\">0</span>; k &lt; _mat_b.<span class=\"hljs-built_in\">size</span>(); ++k) {\r\n                _mat_c[i][j] =\r\n                    (_mat_c[i][j] % mod +\r\n                     (_mat_a[i][k] % mod * _mat_b[k][j] % mod) % mod) %\r\n                    mod;\r\n            }\r\n        }\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> _mat_c;\r\n}\r\n<span class=\"hljs-comment\">/**\r\n * @brief Returns whether matrix `mat` is a [zero\r\n * matrix.](https://en.wikipedia.org/wiki/Zero_matrix)\r\n * @tparam T template type for integer as well as floating values, default is\r\n * long long int\r\n * @param _mat A matrix\r\n * @returns true if it is a zero matrix else false\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T = <span class=\"hljs-type\">int64_t</span>&gt;\r\n<span class=\"hljs-type\">bool</span> <span class=\"hljs-built_in\">is_zero_matrix</span>(<span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;T&gt;&gt;&amp; _mat) {\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; _mat.<span class=\"hljs-built_in\">size</span>(); ++i) {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; _mat[i].<span class=\"hljs-built_in\">size</span>(); ++j) {\r\n            <span class=\"hljs-keyword\">if</span> (_mat[i][j] != <span class=\"hljs-number\">0</span>) {\r\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n            }\r\n        }\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Implementation of Matrix exponentiation\r\n * @details returns the matrix exponentiation `(B^n)` in `k^3 * O(log2(power))`\r\n * time, where `k` is the size of matrix (k by k).\r\n * @tparam T template type for integer as well as floating values, default is\r\n * long long int\r\n * @param _mat matrix for exponentiation\r\n * @param power the exponent value\r\n * @returns the matrix _mat to the power `power (_mat^power)`\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T = <span class=\"hljs-type\">int64_t</span>&gt;\r\nstd::vector&lt;std::vector&lt;T&gt;&gt; <span class=\"hljs-built_in\">matrix_exponentiation</span>(\r\n    std::vector&lt;std::vector&lt;T&gt;&gt; _mat, <span class=\"hljs-type\">uint64_t</span> power,\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int64_t</span> mod = <span class=\"hljs-number\">1000000007</span>) {\r\n    <span class=\"hljs-comment\">/**\r\n     * Initializing answer as identity matrix. For simple binary\r\n     * exponentiation reference, [see\r\n     * here](https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/modular_exponentiation.cpp)\r\n     */</span>\r\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">is_zero_matrix</span>(_mat)) {\r\n        <span class=\"hljs-keyword\">return</span> _mat;\r\n    }\r\n\r\n    std::vector&lt;std::vector&lt;T&gt;&gt; _mat_answer(_mat.<span class=\"hljs-built_in\">size</span>(),\r\n                                            std::<span class=\"hljs-built_in\">vector</span>&lt;T&gt;(_mat.<span class=\"hljs-built_in\">size</span>(), <span class=\"hljs-number\">0</span>));\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; _mat.<span class=\"hljs-built_in\">size</span>(); ++i) {\r\n        _mat_answer[i][i] = <span class=\"hljs-number\">1</span>;\r\n    }\r\n    <span class=\"hljs-comment\">// exponentiation algorithm here.</span>\r\n    <span class=\"hljs-keyword\">while</span> (power &gt; <span class=\"hljs-number\">0</span>) {\r\n        <span class=\"hljs-keyword\">if</span> (power &amp; <span class=\"hljs-number\">1</span>) {\r\n            _mat_answer = <span class=\"hljs-built_in\">matrix_multiplication</span>(_mat_answer, _mat, mod);\r\n        }\r\n        power &gt;&gt;= <span class=\"hljs-number\">1</span>;\r\n        _mat = <span class=\"hljs-built_in\">matrix_multiplication</span>(_mat, _mat, mod);\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">return</span> _mat_answer;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Implementation of nth recurrence series.\r\n * @details Returns the nth term in the recurrence series.\r\n * Note that the function assumes definition of base cases from `n = 0`\r\n * (e.g., for fibonacci, `f(0)` has a defined value `0`)\r\n * @tparam T template type for integer as well as floating values, default is\r\n * long long int\r\n * @param _mat [square matrix](https://en.m.wikipedia.org/wiki/Square_matrix)\r\n * that evaluates the nth term using exponentiation\r\n * @param _base_cases 2D array of dimension `1*n` containing values which are\r\n * defined for some n (e.g., for fibonacci, `f(0)` and `f(1)` are defined, and\r\n * `f(n)` where `n &gt; 1` is evaluated on previous two values)\r\n * @param nth_term the nth term of recurrence relation\r\n * @param constant_or_sum_included whether the recurrence relation has a\r\n * constant value or is evaluating sum of first n terms of the recurrence.\r\n * @returns the nth term of the recurrence relation in `O(k^3. log(n))`, where k\r\n * is number of rows and columns in `_mat` and `n` is the value of `nth_term`\r\n * If constant_or_sum_included is true, returns the sum of first n terms in\r\n * recurrence series\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T = <span class=\"hljs-type\">int64_t</span>&gt;\r\nT <span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\r\n    <span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;T&gt;&gt;&amp; _mat,\r\n    <span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;T&gt;&gt;&amp; _base_cases, <span class=\"hljs-type\">uint64_t</span> nth_term,\r\n    <span class=\"hljs-type\">bool</span> constant_or_sum_included = <span class=\"hljs-literal\">false</span>) {\r\n    <span class=\"hljs-built_in\">assert</span>(_mat.<span class=\"hljs-built_in\">size</span>() == _base_cases.<span class=\"hljs-built_in\">back</span>().<span class=\"hljs-built_in\">size</span>());\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * If nth term is a base case, then return base case directly.\r\n     */</span>\r\n\r\n    <span class=\"hljs-keyword\">if</span> (nth_term &lt; _base_cases.<span class=\"hljs-built_in\">back</span>().<span class=\"hljs-built_in\">size</span>() - constant_or_sum_included) {\r\n        <span class=\"hljs-keyword\">return</span> _base_cases.<span class=\"hljs-built_in\">back</span>()[nth_term - constant_or_sum_included];\r\n    } <span class=\"hljs-keyword\">else</span> {\r\n        <span class=\"hljs-comment\">/**\r\n         * Else evaluate the expression, so multiplying _mat to itself (n -\r\n         * base_cases.length + 1 + constant_or_sum_included) times.\r\n         */</span>\r\n        std::vector&lt;std::vector&lt;T&gt;&gt; _res_matrix =\r\n            <span class=\"hljs-built_in\">matrix_exponentiation</span>(_mat, nth_term - _base_cases.<span class=\"hljs-built_in\">back</span>().<span class=\"hljs-built_in\">size</span>() +\r\n                                            <span class=\"hljs-number\">1</span> + constant_or_sum_included);\r\n\r\n        <span class=\"hljs-comment\">/**\r\n         * After matrix exponentiation, multiply with the base case to evaluate\r\n         * the answer. The answer is always at the end of the array.\r\n         */</span>\r\n        std::vector&lt;std::vector&lt;T&gt;&gt; _res =\r\n            <span class=\"hljs-built_in\">matrix_multiplication</span>(_base_cases, _res_matrix);\r\n\r\n        <span class=\"hljs-keyword\">return</span> _res.<span class=\"hljs-built_in\">back</span>().<span class=\"hljs-built_in\">back</span>();\r\n    }\r\n}\r\n}  <span class=\"hljs-comment\">// namespace linear_recurrence_matrix</span>\r\n}  <span class=\"hljs-comment\">// namespace math</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Self test-implementations\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-comment\">/*\r\n     * Example 1: [Fibonacci\r\n     * series](https://en.wikipedia.org/wiki/Fibonacci_number);\r\n     *\r\n     * [fn-2    fn-1]  [0      1]  ==   [fn-1   (fn-2 + fn-1)] =&gt; [fn-1   fn]\r\n     *                 [1      1]\r\n     *\r\n     * Let A = [fn-2   fn-1], and B = [0   1]\r\n     *                                [1   1],\r\n     *\r\n     * Since, A.B....(n-1 times) = [fn-1   fn]\r\n     * we can multiply B with itself n-1 times to obtain the required value\r\n     */</span>\r\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;&gt; fibonacci_matrix = {{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>}},\r\n                                      fib_base_case = {{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}};\r\n\r\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\r\n               fibonacci_matrix, fib_base_case, <span class=\"hljs-number\">11</span>) == <span class=\"hljs-number\">89LL</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\r\n               fibonacci_matrix, fib_base_case, <span class=\"hljs-number\">39</span>) == <span class=\"hljs-number\">63245986LL</span>);\r\n    <span class=\"hljs-comment\">/*\r\n     * Example 2: [Tribonacci series](https://oeis.org/A000073)\r\n     *                    [0   0   1]\r\n     * [fn-3  fn-2  fn-1] [1   0   1]  =  [(fn-2)  (fn-1)  (fn-3 + fn-2 + fn-1)]\r\n     *                    [0   1   1]\r\n     *                                 =&gt; [fn-2     fn-1    fn]\r\n     *\r\n     *                                       [0   0   1]\r\n     * Let A = [fn-3   fn-2   fn-1], and B = [1   0   1]\r\n     *                                       [0   1   1]\r\n     *\r\n     * Since, A.B....(n-2 times) = [fn-2  fn-1   fn]\r\n     * we will have multiply B with itself n-2 times to obtain the required\r\n     * value ()\r\n     */</span>\r\n\r\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;&gt; tribonacci = {{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>},\r\n                                                    {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>},\r\n                                                    {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>}},\r\n                                      trib_base_case = {\r\n                                          {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}};  <span class=\"hljs-comment\">// f0 = 0, f1 = 0, f2 = 1</span>\r\n\r\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\r\n               tribonacci, trib_base_case, <span class=\"hljs-number\">11</span>) == <span class=\"hljs-number\">149LL</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\r\n               tribonacci, trib_base_case, <span class=\"hljs-number\">36</span>) == <span class=\"hljs-number\">615693474LL</span>);\r\n\r\n    <span class=\"hljs-comment\">/*\r\n     * Example 3: [Pell numbers](https://oeis.org/A000129)\r\n     * `f(n)  = 2* f(n-1) + f(n-2); f(0) = f(1) = 2`\r\n     *\r\n     * [fn-2  fn-1] [0   1]  =  [(fn-1)  fn-2 + 2*fn-1)]\r\n     *              [1   2]\r\n     *                       =&gt; [fn-1     fn]\r\n     *\r\n     * Let A = [fn-2  fn-1], and B = [0   1]\r\n     *                               [1   2]\r\n     */</span>\r\n\r\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;&gt; pell_recurrence = {{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>}},\r\n                                      pell_base_case = {\r\n                                          {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>}};  <span class=\"hljs-comment\">// `f0 = 2, f1 = 2`</span>\r\n\r\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\r\n               pell_recurrence, pell_base_case, <span class=\"hljs-number\">15</span>) == <span class=\"hljs-number\">551614LL</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\r\n               pell_recurrence, pell_base_case, <span class=\"hljs-number\">23</span>) == <span class=\"hljs-number\">636562078LL</span>);\r\n\r\n    <span class=\"hljs-comment\">/*\r\n     * Example 4: Custom recurrence relation:\r\n     * Now the recurrence is of the form `a*f(n-1) + b*(fn-2) + ... + c`\r\n     * where `c` is the constant\r\n     * `f(n)  = 2* f(n-1) + f(n-2) + 7; f(0) = f(1) = 2, c = 7`\r\n     *\r\n     *                   [1   0   1]\r\n     * [7,  fn-2,  fn-1] [0   0   1]\r\n     *                   [0   1   2]\r\n     * =  [7,  (fn-1),  fn-2 + 2*fn-1) + 7]\r\n     *\r\n     * =&gt; [7,    fn-1,     fn]\r\n     * :: Series will be 2, 2, 13, 35, 90, 222, 541, 1311, 3170, 7658, 18493,\r\n     * 44651, 107802, 260262, 628333, 1516935, 362210, 8841362, 21344941,\r\n     * 51531251\r\n     *\r\n     * Let A = [7,  fn-2,  fn-1], and B = [1   0   1]\r\n     *                                    [0   0   1]\r\n     *                                    [0   1   2]\r\n     */</span>\r\n\r\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;&gt;\r\n        custom_recurrence = {{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>}},\r\n        custom_base_case = {{<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>}};  <span class=\"hljs-comment\">// `c = 7, f0 = 2, f1 = 2`</span>\r\n\r\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\r\n               custom_recurrence, custom_base_case, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">18493LL</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\r\n               custom_recurrence, custom_base_case, <span class=\"hljs-number\">19</span>, <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">51531251LL</span>);\r\n\r\n    <span class=\"hljs-comment\">/*\r\n     * Example 5: Sum fibonacci sequence\r\n     * The following matrix evaluates the sum of first n fibonacci terms in\r\n     * O(27. log2(n)) time.\r\n     * `f(n) = f(n-1) + f(n-2); f(0) = 0, f(1) = 1`\r\n     *\r\n     *                           [1   0   0]\r\n     * [s(f, n-1),  fn-2,  fn-1] [1   0   1]\r\n     *                           [1   1   1]\r\n     *   =&gt; [(s(f, n-1)+f(n-2)+f(n-1)), (fn-1),  f(n-2)+f(n-1)]\r\n     *\r\n     *   =&gt; [s(f, n-1)+f(n),    fn-1,     fn]\r\n     *\r\n     *   =&gt; [s(f, n),    fn-1,     fn]\r\n     *\r\n     * Sum of first 20 fibonacci series:\r\n     * 0, 1, 2, 4, 7, 12, 20, 33, 54, 88, 143, 232, 376, 609, 986, 1596, 2583,\r\n     * 4180, 6764\r\n     *          f0  f1  s(f,1)\r\n     * Let A = [0    1    1], and B = [0   1   1]\r\n     *                                [1   1   1]\r\n     *                                [0   0   1]\r\n     */</span>\r\n\r\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;&gt; sum_fibo_recurrence = {{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>},\r\n                                                             {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>},\r\n                                                             {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}},\r\n                                      sum_fibo_base_case = {\r\n                                          {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>}};  <span class=\"hljs-comment\">// `f0 = 0, f1 = 1`</span>\r\n\r\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\r\n               sum_fibo_recurrence, sum_fibo_base_case, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">609LL</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\r\n               sum_fibo_recurrence, sum_fibo_base_case, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">2583LL</span>);\r\n    <span class=\"hljs-comment\">/*\r\n     * Example 6: [Tribonacci sum series](https://oeis.org/A000073)\r\n     *                               [0   0   1   1]\r\n     * [fn-3  fn-2  fn-1  s(f, n-1)] [1   0   1   1]\r\n     *                               [0   1   1   1]\r\n     *                               [0   0   0   1]\r\n     *\r\n     * = [fn-2, fn-1, fn-3 + fn-2 + fn-1, (fn-3 + fn-2 + fn-1 + s(f, n-1))]\r\n     *\r\n     * =&gt; [fn-2, fn-1, fn,  fn + s(f, n-1)]\r\n     *\r\n     * =&gt; [fn-2, fn-1, fn, s(f, n)]\r\n     *\r\n     * Sum of the series is: 0, 0, 1, 2, 4, 8, 15, 28, 52, 96, 177, 326, 600,\r\n     * 1104, 2031, 3736, 6872, 12640, 23249, 42762\r\n     *\r\n     * Let A = [fn-3   fn-2   fn-1   s(f, n-1)], and\r\n     *     [0   0   1   1]\r\n     * B = [1   0   1   1]\r\n     *     [0   1   1   1]\r\n     *     [0   0   0   1]\r\n     *\r\n     * Since, A.B....(n-2 times) = [fn-2  fn-1   fn]\r\n     * we will have multiply B with itself n-2 times to obtain the required\r\n     * value\r\n     */</span>\r\n\r\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;&gt; tribonacci_sum = {{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>},\r\n                                                        {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>},\r\n                                                        {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>},\r\n                                                        {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}},\r\n                                      trib_sum_base_case = {{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>}};\r\n    <span class=\"hljs-comment\">// `f0 = 0, f1 = 0, f2 = 1, s = 1`</span>\r\n\r\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\r\n               tribonacci_sum, trib_sum_base_case, <span class=\"hljs-number\">18</span>, <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">23249LL</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\r\n               tribonacci_sum, trib_sum_base_case, <span class=\"hljs-number\">19</span>, <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">42762LL</span>);\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// run self-test implementations</span>\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [],
  "explanationUrl": {}
}