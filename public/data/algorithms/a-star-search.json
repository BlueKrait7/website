{
  "slug": "a-star-search",
  "name": "A Star Search",
  "categories": [
    "machinelearning"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "machine_learning\\a_star_search.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/machine_learning\\a_star_search.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @brief\r\n * [A* search algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm)\r\n * @details\r\n * A* is an informed search algorithm, or a best-first search, meaning that it\r\n * is formulated in terms of weighted graphs: starting from a specific starting\r\n * node of a graph (initial state), it aims to find a path to the given goal\r\n * node having the smallest cost (least distance travelled, shortest time,\r\n * etc.). It evaluates by maintaining a tree of paths originating at the start\r\n * node and extending those paths one edge at a time until it reaches the final\r\n * state.\r\n * The weighted edges (or cost) is evaluated on two factors, G score\r\n * (cost required from starting node or initial state to current state) and H\r\n * score (cost required from current state to final state). The F(state), then\r\n * is evaluated as:\r\n * F(state) = G(state) + H(state).\r\n *\r\n * To solve the given search with shortest cost or path possible  is to inspect\r\n * values having minimum F(state).\r\n * @author [Ashish Daulatabad](https://github.com/AshishYUO)\r\n */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span>   <span class=\"hljs-comment\">/// for `std::reverse` function</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;array&gt;</span>       <span class=\"hljs-comment\">/// for `std::array`, representing `EightPuzzle` board</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>     <span class=\"hljs-comment\">/// for `assert`</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;functional&gt;</span>  <span class=\"hljs-comment\">/// for `std::function` STL</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>    <span class=\"hljs-comment\">/// for IO operations</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span>         <span class=\"hljs-comment\">/// for `std::map` STL</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;memory&gt;</span>      <span class=\"hljs-comment\">/// for `std::shared_ptr`</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;set&gt;</span>         <span class=\"hljs-comment\">/// for `std::set` STL</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>      <span class=\"hljs-comment\">/// for `std::vector` STL</span></span>\r\n<span class=\"hljs-comment\">/**\r\n * @namespace machine_learning\r\n * @brief Machine learning algorithms\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> machine_learning {\r\n<span class=\"hljs-comment\">/**\r\n * @namespace aystar_search\r\n * @brief Functions for [A*\r\n * Search](https://en.wikipedia.org/wiki/A*_search_algorithm) implementation.\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> aystar_search {\r\n<span class=\"hljs-comment\">/**\r\n * @class EightPuzzle\r\n * @brief A class defining [EightPuzzle/15-Puzzle\r\n * game](https://en.wikipedia.org/wiki/15_puzzle).\r\n * @details\r\n * A well known 3 x 3 puzzle of the form\r\n * `\r\n * 1   2   3\r\n * 4   5   6\r\n * 7   8   0\r\n * `\r\n * where `0` represents an empty space in the puzzle\r\n * Given any random state, the goal is to achieve the above configuration\r\n * (or any other configuration if possible)\r\n * @tparam N size of the square Puzzle, default is set to 3 (since it is\r\n * EightPuzzle)\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-type\">size_t</span> N = <span class=\"hljs-number\">3</span>&gt;\r\n<span class=\"hljs-keyword\">class</span> EightPuzzle {\r\n    std::array&lt;std::array&lt;<span class=\"hljs-type\">uint32_t</span>, N&gt;, N&gt;\r\n        board;  <span class=\"hljs-comment\">/// N x N array to store the current state of the Puzzle.</span>\r\n\r\n    std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int8_t</span>, <span class=\"hljs-type\">int8_t</span>&gt;&gt; moves = {\r\n        {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>},\r\n        {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>},\r\n        {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>},\r\n        {<span class=\"hljs-number\">-1</span>,\r\n         <span class=\"hljs-number\">0</span>}};  <span class=\"hljs-comment\">/// A helper array to evaluate the next state from current state;</span>\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Finds an empty space in puzzle (in this case; a zero)\r\n     * @returns a pair indicating integer distances from top and right\r\n     * respectively, else returns -1, -1\r\n     */</span>\r\n    <span class=\"hljs-function\">std::pair&lt;<span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-type\">uint32_t</span>&gt; <span class=\"hljs-title\">find_zero</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; ++i) {\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; N; ++j) {\r\n                <span class=\"hljs-keyword\">if</span> (!board[i][j]) {\r\n                    <span class=\"hljs-keyword\">return</span> {i, j};\r\n                }\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> {<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>};\r\n    }\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief check whether the index value is bounded within the puzzle area\r\n     * @param value index for the current board\r\n     * @returns `true` if index is within the board, else `false`\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">in_range</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> value)</span> <span class=\"hljs-type\">const</span> </span>{ <span class=\"hljs-keyword\">return</span> value &lt; N; }\r\n\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief get the value from i units from right and j units from left side\r\n     * of the board\r\n     * @param i integer denoting ith row\r\n     * @param j integer denoting column\r\n     * @returns non-negative integer denoting the value at ith row and jth\r\n     * column\r\n     * @returns -1 if invalid i or j position\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> i, <span class=\"hljs-type\">size_t</span> j)</span> <span class=\"hljs-type\">const</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">in_range</span>(i) &amp;&amp; <span class=\"hljs-built_in\">in_range</span>(j)) {\r\n            <span class=\"hljs-keyword\">return</span> board[i][j];\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\r\n    }\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Returns the current state of the board\r\n     */</span>\r\n    std::array&lt;std::array&lt;<span class=\"hljs-type\">uint32_t</span>, N&gt;, N&gt; <span class=\"hljs-built_in\">get_state</span>() { <span class=\"hljs-keyword\">return</span> board; }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief returns the size of the EightPuzzle (number of row / column)\r\n     * @return N, the size of the puzzle.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">get_size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>{ <span class=\"hljs-keyword\">return</span> N; }\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Default constructor for EightPuzzle\r\n     */</span>\r\n    <span class=\"hljs-built_in\">EightPuzzle</span>() {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; ++i) {\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; N; ++j) {\r\n                board[i][j] = ((i * <span class=\"hljs-number\">3</span> + j + <span class=\"hljs-number\">1</span>) % (N * N));\r\n            }\r\n        }\r\n    }\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Parameterized Constructor for EightPuzzle\r\n     * @param init a 2-dimensional array denoting a puzzle configuration\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">EightPuzzle</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::array&lt;std::array&lt;<span class=\"hljs-type\">uint32_t</span>, N&gt;, N&gt; &amp;init)</span>\r\n        : board(init) {</span>}\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Copy constructor\r\n     * @param A a reference of an EightPuzzle\r\n     */</span>\r\n    <span class=\"hljs-built_in\">EightPuzzle</span>(<span class=\"hljs-type\">const</span> EightPuzzle&lt;N&gt; &amp;A) : <span class=\"hljs-built_in\">board</span>(A.board) {}\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Move constructor\r\n     * @param A a reference of an EightPuzzle\r\n     */</span>\r\n    <span class=\"hljs-built_in\">EightPuzzle</span>(<span class=\"hljs-type\">const</span> EightPuzzle&lt;N&gt; &amp;&amp;A) <span class=\"hljs-keyword\">noexcept</span>\r\n        : <span class=\"hljs-built_in\">board</span>(std::<span class=\"hljs-built_in\">move</span>(A.board)) {}\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Destructor of EightPuzzle\r\n     */</span>\r\n    ~<span class=\"hljs-built_in\">EightPuzzle</span>() = <span class=\"hljs-keyword\">default</span>;\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Copy assignment operator\r\n     * @param A a reference of an EightPuzzle\r\n     */</span>\r\n    EightPuzzle &amp;<span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> EightPuzzle &amp;A) {\r\n        board = A.board;\r\n        <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Move assignment operator\r\n     * @param A a reference of an EightPuzzle\r\n     */</span>\r\n    EightPuzzle &amp;<span class=\"hljs-keyword\">operator</span>=(EightPuzzle &amp;&amp;A) <span class=\"hljs-keyword\">noexcept</span> {\r\n        board = std::<span class=\"hljs-built_in\">move</span>(A.board);\r\n        <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Find all possible states after processing all possible\r\n     * moves, given the current state of the puzzle\r\n     * @returns list of vector containing all possible next moves\r\n     * @note the implementation is compulsory to create A* search\r\n     */</span>\r\n    std::vector&lt;EightPuzzle&lt;N&gt;&gt; <span class=\"hljs-built_in\">generate_possible_moves</span>() {\r\n        <span class=\"hljs-keyword\">auto</span> zero_pos = <span class=\"hljs-built_in\">find_zero</span>();\r\n        <span class=\"hljs-comment\">// vector which will contain all possible state from current state</span>\r\n        std::vector&lt;EightPuzzle&lt;N&gt;&gt; NewStates;\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;move : moves) {\r\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">in_range</span>(zero_pos.first + move.first) &amp;&amp;\r\n                <span class=\"hljs-built_in\">in_range</span>(zero_pos.second + move.second)) {\r\n                <span class=\"hljs-comment\">// swap with the possible moves</span>\r\n                std::array&lt;std::array&lt;<span class=\"hljs-type\">uint32_t</span>, N&gt;, N&gt; new_config = board;\r\n                std::<span class=\"hljs-built_in\">swap</span>(new_config[zero_pos.first][zero_pos.second],\r\n                          new_config[zero_pos.first + move.first]\r\n                                    [zero_pos.second + move.second]);\r\n                <span class=\"hljs-function\">EightPuzzle&lt;N&gt; <span class=\"hljs-title\">new_state</span><span class=\"hljs-params\">(new_config)</span></span>;\r\n                <span class=\"hljs-comment\">// Store new state and calculate heuristic value, and depth</span>\r\n                NewStates.<span class=\"hljs-built_in\">emplace_back</span>(new_state);\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> NewStates;\r\n    }\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief check whether two boards are equal\r\n     * @returns `true` if check.state is equal to `this-&gt;state`, else\r\n     * `false`\r\n     */</span>\r\n    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>==(<span class=\"hljs-type\">const</span> EightPuzzle&lt;N&gt; &amp;check) <span class=\"hljs-type\">const</span> {\r\n        <span class=\"hljs-keyword\">if</span> (check.<span class=\"hljs-built_in\">get_size</span>() != N) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; ++i) {\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; N; ++j) {\r\n                <span class=\"hljs-keyword\">if</span> (board[i][j] != check.board[i][j]) {\r\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n                }\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n    }\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief check whether one board is lexicographically smaller\r\n     * @returns `true` if this-&gt;state is lexicographically smaller than\r\n     * `check.state`, else `false`\r\n     */</span>\r\n    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>&lt;(<span class=\"hljs-type\">const</span> EightPuzzle&lt;N&gt; &amp;check) <span class=\"hljs-type\">const</span> {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; ++i) {\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; N; ++j) {\r\n                <span class=\"hljs-keyword\">if</span> (board[i][j] != check.board[i][j]) {\r\n                    <span class=\"hljs-keyword\">return</span> board[i][j] &lt; check.board[i][j];\r\n                }\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n    }\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief check whether one board is lexicographically smaller or equal\r\n     * @returns `true` if this-&gt;state is lexicographically smaller than\r\n     * `check.state` or same, else `false`\r\n     */</span>\r\n    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>&lt;=(<span class=\"hljs-type\">const</span> EightPuzzle&lt;N&gt; &amp;check) <span class=\"hljs-type\">const</span> {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; ++i) {\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; N; ++j) {\r\n                <span class=\"hljs-keyword\">if</span> (board[i][j] != check.board[i][j]) {\r\n                    <span class=\"hljs-keyword\">return</span> board[i][j] &lt; check.board[i][j];\r\n                }\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief friend operator to display EightPuzzle&lt;&gt;\r\n     * @param op ostream object\r\n     * @param SomeState a certain state.\r\n     * @returns ostream operator op\r\n     */</span>\r\n    <span class=\"hljs-keyword\">friend</span> std::ostream &amp;<span class=\"hljs-keyword\">operator</span>&lt;&lt;(std::ostream &amp;op,\r\n                                    <span class=\"hljs-type\">const</span> EightPuzzle&lt;N&gt; &amp;SomeState) {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; ++i) {\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; N; ++j) {\r\n                op &lt;&lt; SomeState.board[i][j] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;\r\n            }\r\n            op &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> op;\r\n    }\r\n};\r\n<span class=\"hljs-comment\">/**\r\n * @class AyStarSearch\r\n * @brief A class defining [A* search\r\n * algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm). for some\r\n * initial state and final state\r\n * @details AyStarSearch class is defined as the informed search algorithm\r\n * that is formulated in terms of weighted graphs: starting from a specific\r\n * starting node of a graph (initial state), it aims to find a path to the given\r\n * goal node having the smallest cost (least distance travelled, shortest time,\r\n * etc.)\r\n * The weighted edges (or cost) is evaluated on two factors, G score\r\n * (cost required from starting node or initial state to current state) and H\r\n * score (cost required from current state to final state). The `F(state)`, then\r\n * is evaluated as:\r\n * `F(state) = G(state) + H(state)`.\r\n * The best search would be the final state having minimum `F(state)` value\r\n * @tparam Puzzle denotes the puzzle or problem involving initial state and\r\n * final state to be solved by A* search.\r\n * @note 1. The algorithm is referred from pesudocode from\r\n * [Wikipedia page](https://en.wikipedia.org/wiki/A*_search_algorithm)\r\n * as is.\r\n * 2. For `AyStarSearch` to work, the definitions for template Puzzle is\r\n * compulsory.\r\n * a. Comparison operator for template Puzzle (`&lt;`, `==`, and `&lt;=`)\r\n * b. `generate_possible_moves()`\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> Puzzle&gt;\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AyStarSearch</span> {\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Struct that handles all the information related to the current\r\n     * state.\r\n     */</span>\r\n    <span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Info</span> {\r\n        std::shared_ptr&lt;Puzzle&gt; state;  <span class=\"hljs-comment\">/// Holds the current state.</span>\r\n        <span class=\"hljs-type\">size_t</span> heuristic_value = <span class=\"hljs-number\">0</span>;     <span class=\"hljs-comment\">/// stores h score</span>\r\n        <span class=\"hljs-type\">size_t</span> depth = <span class=\"hljs-number\">0</span>;               <span class=\"hljs-comment\">/// stores g score</span>\r\n\r\n        <span class=\"hljs-comment\">/**\r\n         * @brief Default constructor\r\n         */</span>\r\n        <span class=\"hljs-built_in\">Info</span>() = <span class=\"hljs-keyword\">default</span>;\r\n\r\n        <span class=\"hljs-comment\">/**\r\n         * @brief constructor having Puzzle as parameter\r\n         * @param A a puzzle object\r\n         */</span>\r\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Info</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> Puzzle &amp;A)</span> : state(std::make_shared&lt;Puzzle&gt;(A)) {</span>}\r\n\r\n        <span class=\"hljs-comment\">/**\r\n         * @brief constructor having three parameters\r\n         * @param A a puzzle object\r\n         * @param h_value heuristic value of this puzzle object\r\n         * @param depth the depth at which this node was found during traversal\r\n         */</span>\r\n        <span class=\"hljs-built_in\">Info</span>(<span class=\"hljs-type\">const</span> Puzzle &amp;A, <span class=\"hljs-type\">size_t</span> h_value, <span class=\"hljs-type\">size_t</span> d)\r\n            : <span class=\"hljs-built_in\">state</span>(std::<span class=\"hljs-built_in\">make_shared</span>&lt;Puzzle&gt;(A)),\r\n              <span class=\"hljs-built_in\">heuristic_value</span>(h_value),\r\n              <span class=\"hljs-built_in\">depth</span>(d) {}\r\n\r\n        <span class=\"hljs-comment\">/**\r\n         * @brief Copy constructor\r\n         * @param A Info object reference\r\n         */</span>\r\n        <span class=\"hljs-built_in\">Info</span>(<span class=\"hljs-type\">const</span> Info &amp;A)\r\n            : <span class=\"hljs-built_in\">state</span>(std::<span class=\"hljs-built_in\">make_shared</span>&lt;Puzzle&gt;(A.state)),\r\n              <span class=\"hljs-built_in\">heuristic_value</span>(A.heuristic_value),\r\n              <span class=\"hljs-built_in\">depth</span>(A.depth) {}\r\n\r\n        <span class=\"hljs-comment\">/**\r\n         * @brief Move constructor\r\n         * @param A Info object reference\r\n         */</span>\r\n        <span class=\"hljs-built_in\">Info</span>(<span class=\"hljs-type\">const</span> Info &amp;&amp;A) <span class=\"hljs-keyword\">noexcept</span>\r\n            : <span class=\"hljs-built_in\">state</span>(std::<span class=\"hljs-built_in\">make_shared</span>&lt;Puzzle&gt;(std::<span class=\"hljs-built_in\">move</span>(A.state))),\r\n              <span class=\"hljs-built_in\">heuristic_value</span>(std::<span class=\"hljs-built_in\">move</span>(A.heuristic_value)),\r\n              <span class=\"hljs-built_in\">depth</span>(std::<span class=\"hljs-built_in\">move</span>(A.depth)) {}\r\n\r\n        <span class=\"hljs-comment\">/**\r\n         * @brief copy assignment operator\r\n         * @param A Info object reference\r\n         */</span>\r\n        Info &amp;<span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> Info &amp;A) {\r\n            state = A.state;\r\n            heuristic_value = A.heuristic_value;\r\n            depth = A.depth;\r\n            <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;\r\n        }\r\n\r\n        <span class=\"hljs-comment\">/**\r\n         * @brief move assignment operator\r\n         * @param A Info object reference\r\n         */</span>\r\n        Info &amp;<span class=\"hljs-keyword\">operator</span>=(Info &amp;&amp;A) <span class=\"hljs-keyword\">noexcept</span> {\r\n            state = std::<span class=\"hljs-built_in\">move</span>(A.state);\r\n            heuristic_value = std::<span class=\"hljs-built_in\">move</span>(A.heuristic_value);\r\n            depth = std::<span class=\"hljs-built_in\">move</span>(A.depth);\r\n            <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;\r\n        }\r\n        <span class=\"hljs-comment\">/**\r\n         * @brief Destructor for Info\r\n         */</span>\r\n        ~<span class=\"hljs-built_in\">Info</span>() = <span class=\"hljs-keyword\">default</span>;\r\n    } Info;\r\n\r\n    std::shared_ptr&lt;Info&gt; Initial;  <span class=\"hljs-comment\">// Initial state of the AyStarSearch</span>\r\n    std::shared_ptr&lt;Info&gt; Final;    <span class=\"hljs-comment\">// Final state of the AyStarSearch</span>\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Custom comparator for open_list\r\n     */</span>\r\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">comparison_operator</span> {\r\n        <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::shared_ptr&lt;Info&gt; &amp;a,\r\n                        <span class=\"hljs-type\">const</span> std::shared_ptr&lt;Info&gt; &amp;b)</span> <span class=\"hljs-type\">const</span> </span>{\r\n            <span class=\"hljs-keyword\">return</span> *(a-&gt;state) &lt; *(b-&gt;state);\r\n        }\r\n    };\r\n\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-keyword\">using</span> MapOfPuzzleInfoWithPuzzleInfo =\r\n        std::map&lt;std::shared_ptr&lt;Info&gt;, std::shared_ptr&lt;Info&gt;,\r\n                 comparison_operator&gt;;\r\n\r\n    <span class=\"hljs-keyword\">using</span> MapOfPuzzleInfoWithInteger =\r\n        std::map&lt;std::shared_ptr&lt;Info&gt;, <span class=\"hljs-type\">uint32_t</span>, comparison_operator&gt;;\r\n\r\n    <span class=\"hljs-keyword\">using</span> SetOfPuzzleInfo =\r\n        std::set&lt;std::shared_ptr&lt;Info&gt;, comparison_operator&gt;;\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Parameterized constructor for AyStarSearch\r\n     * @param initial denoting initial state of the puzzle\r\n     * @param final denoting final state of the puzzle\r\n     */</span>\r\n    <span class=\"hljs-built_in\">AyStarSearch</span>(<span class=\"hljs-type\">const</span> Puzzle &amp;initial, <span class=\"hljs-type\">const</span> Puzzle &amp;<span class=\"hljs-keyword\">final</span>) {\r\n        Initial = std::<span class=\"hljs-built_in\">make_shared</span>&lt;Info&gt;(initial);\r\n        Final = std::<span class=\"hljs-built_in\">make_shared</span>&lt;Info&gt;(<span class=\"hljs-keyword\">final</span>);\r\n    }\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief A helper solution: launches when a solution for AyStarSearch\r\n     * is found\r\n     * @param FinalState the pointer to the obtained final state\r\n     * @param parent_of the list of all parents of nodes stored during A*\r\n     * search\r\n     * @returns the list of moves denoting moves from final state to initial\r\n     * state (in reverse)\r\n     */</span>\r\n    <span class=\"hljs-function\">std::vector&lt;Puzzle&gt; <span class=\"hljs-title\">Solution</span><span class=\"hljs-params\">(\r\n        std::shared_ptr&lt;Info&gt; FinalState,\r\n        <span class=\"hljs-type\">const</span> MapOfPuzzleInfoWithPuzzleInfo &amp;parent_of)</span> </span>{\r\n        <span class=\"hljs-comment\">//  Useful for traversing from final state to current state.</span>\r\n        <span class=\"hljs-keyword\">auto</span> current_state = FinalState;\r\n        <span class=\"hljs-comment\">/*\r\n         * For storing the solution tree starting from initial state to\r\n         * final state\r\n         */</span>\r\n        std::vector&lt;Puzzle&gt; answer;\r\n        <span class=\"hljs-keyword\">while</span> (current_state != <span class=\"hljs-literal\">nullptr</span>) {\r\n            answer.<span class=\"hljs-built_in\">emplace_back</span>(*current_state-&gt;state);\r\n            current_state = parent_of.<span class=\"hljs-built_in\">find</span>(current_state)-&gt;second;\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> answer;\r\n    }\r\n    <span class=\"hljs-comment\">/**\r\n     * Main algorithm for finding `FinalState`, given the `InitialState`\r\n     * @param dist the heuristic finction, defined by the user\r\n     * @param permissible_depth the depth at which the A* search discards\r\n     * searching for solution\r\n     * @returns List of moves from Final state to initial state, if\r\n     * evaluated, else returns an empty array\r\n     */</span>\r\n    <span class=\"hljs-function\">std::vector&lt;Puzzle&gt; <span class=\"hljs-title\">a_star_search</span><span class=\"hljs-params\">(\r\n        <span class=\"hljs-type\">const</span> std::function&lt;<span class=\"hljs-type\">uint32_t</span>(<span class=\"hljs-type\">const</span> Puzzle &amp;, <span class=\"hljs-type\">const</span> Puzzle &amp;)&gt; &amp;dist,\r\n        <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> permissible_depth = <span class=\"hljs-number\">30</span>)</span> </span>{\r\n        MapOfPuzzleInfoWithPuzzleInfo\r\n            parent_of;                       <span class=\"hljs-comment\">/// Stores the parent of the states</span>\r\n        MapOfPuzzleInfoWithInteger g_score;  <span class=\"hljs-comment\">/// Stores the g_score</span>\r\n        SetOfPuzzleInfo open_list;           <span class=\"hljs-comment\">/// Stores the list to explore</span>\r\n        SetOfPuzzleInfo closed_list;  <span class=\"hljs-comment\">/// Stores the list that are explored</span>\r\n\r\n        <span class=\"hljs-comment\">// Before starting the AyStartSearch, initialize the set and maps</span>\r\n        open_list.<span class=\"hljs-built_in\">emplace</span>(Initial);\r\n        parent_of[Initial] = <span class=\"hljs-literal\">nullptr</span>;\r\n        g_score[Initial] = <span class=\"hljs-number\">0</span>;\r\n\r\n        <span class=\"hljs-keyword\">while</span> (!open_list.<span class=\"hljs-built_in\">empty</span>()) {\r\n            <span class=\"hljs-comment\">// Iterator for state having having lowest f_score.</span>\r\n            <span class=\"hljs-keyword\">typename</span> SetOfPuzzleInfo::iterator it_low_f_score;\r\n            <span class=\"hljs-type\">uint32_t</span> min_f_score = <span class=\"hljs-number\">1e9</span>;\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> iter = open_list.<span class=\"hljs-built_in\">begin</span>(); iter != open_list.<span class=\"hljs-built_in\">end</span>();\r\n                 ++iter) {\r\n                <span class=\"hljs-comment\">// f score here is evaluated by g score (depth) and h score</span>\r\n                <span class=\"hljs-comment\">// (distance between current state and final state)</span>\r\n                <span class=\"hljs-type\">uint32_t</span> f_score = (*iter)-&gt;heuristic_value + (*iter)-&gt;depth;\r\n                <span class=\"hljs-keyword\">if</span> (f_score &lt; min_f_score) {\r\n                    min_f_score = f_score;\r\n                    it_low_f_score = iter;\r\n                }\r\n            }\r\n\r\n            <span class=\"hljs-comment\">// current_state, stores lowest f score so far for this state.</span>\r\n            std::shared_ptr&lt;Info&gt; current_state = *it_low_f_score;\r\n\r\n            <span class=\"hljs-comment\">// if this current state is equal to final, return</span>\r\n            <span class=\"hljs-keyword\">if</span> (*(current_state-&gt;state) == *(Final-&gt;state)) {\r\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Solution</span>(current_state, parent_of);\r\n            }\r\n            <span class=\"hljs-comment\">// else remove from open list as visited.</span>\r\n            open_list.<span class=\"hljs-built_in\">erase</span>(it_low_f_score);\r\n            <span class=\"hljs-comment\">// if current_state has exceeded the allowed depth, skip</span>\r\n            <span class=\"hljs-comment\">// neighbor checking</span>\r\n            <span class=\"hljs-keyword\">if</span> (current_state-&gt;depth &gt;= permissible_depth) {\r\n                <span class=\"hljs-keyword\">continue</span>;\r\n            }\r\n            <span class=\"hljs-comment\">// Generate all possible moves (neighbors) given the current</span>\r\n            <span class=\"hljs-comment\">// state</span>\r\n            std::vector&lt;Puzzle&gt; total_possible_moves =\r\n                current_state-&gt;state-&gt;<span class=\"hljs-built_in\">generate_possible_moves</span>();\r\n\r\n            <span class=\"hljs-keyword\">for</span> (Puzzle &amp;neighbor : total_possible_moves) {\r\n                <span class=\"hljs-comment\">// calculate score of neighbors with respect to</span>\r\n                <span class=\"hljs-comment\">// current_state</span>\r\n                std::shared_ptr&lt;Info&gt; Neighbor = std::<span class=\"hljs-built_in\">make_shared</span>&lt;Info&gt;(\r\n                    neighbor, <span class=\"hljs-built_in\">dist</span>(neighbor, *(Final-&gt;state)),\r\n                    current_state-&gt;depth + <span class=\"hljs-number\">1U</span>);\r\n                <span class=\"hljs-type\">uint32_t</span> temp_g_score = Neighbor-&gt;depth;\r\n\r\n                <span class=\"hljs-comment\">// Check whether this state is explored.</span>\r\n                <span class=\"hljs-comment\">// If this state is discovered at greater depth, then discard,</span>\r\n                <span class=\"hljs-comment\">// else remove from closed list and explore the node</span>\r\n                <span class=\"hljs-keyword\">auto</span> closed_list_iter = closed_list.<span class=\"hljs-built_in\">find</span>(Neighbor);\r\n                <span class=\"hljs-keyword\">if</span> (closed_list_iter != closed_list.<span class=\"hljs-built_in\">end</span>()) {\r\n                    <span class=\"hljs-comment\">// 1. If state in closed list has higher depth, then remove</span>\r\n                    <span class=\"hljs-comment\">// from list since we have found better option,</span>\r\n                    <span class=\"hljs-comment\">// 2. Else don&#x27;t explore this state.</span>\r\n                    <span class=\"hljs-keyword\">if</span> (Neighbor-&gt;depth &lt; (*closed_list_iter)-&gt;depth) {\r\n                        closed_list.<span class=\"hljs-built_in\">erase</span>(closed_list_iter);\r\n                    } <span class=\"hljs-keyword\">else</span> {\r\n                        <span class=\"hljs-keyword\">continue</span>;\r\n                    }\r\n                }\r\n                <span class=\"hljs-keyword\">auto</span> neighbor_g_score_iter = g_score.<span class=\"hljs-built_in\">find</span>(Neighbor);\r\n                <span class=\"hljs-comment\">// if the neighbor is already created and has minimum</span>\r\n                <span class=\"hljs-comment\">// g_score, then update g_score and f_score else insert new</span>\r\n                <span class=\"hljs-keyword\">if</span> (neighbor_g_score_iter != g_score.<span class=\"hljs-built_in\">end</span>()) {\r\n                    <span class=\"hljs-keyword\">if</span> (neighbor_g_score_iter-&gt;second &gt; temp_g_score) {\r\n                        neighbor_g_score_iter-&gt;second = temp_g_score;\r\n                        parent_of[Neighbor] = current_state;\r\n                    }\r\n                } <span class=\"hljs-keyword\">else</span> {\r\n                    g_score[Neighbor] = temp_g_score;\r\n                    parent_of[Neighbor] = current_state;\r\n                }\r\n                <span class=\"hljs-comment\">// If this is a new state, insert into open_list</span>\r\n                <span class=\"hljs-comment\">// else update if the this state has better g score than</span>\r\n                <span class=\"hljs-comment\">// existing one.</span>\r\n                <span class=\"hljs-keyword\">auto</span> iter = open_list.<span class=\"hljs-built_in\">find</span>(Neighbor);\r\n                <span class=\"hljs-keyword\">if</span> (iter == open_list.<span class=\"hljs-built_in\">end</span>()) {\r\n                    open_list.<span class=\"hljs-built_in\">emplace</span>(Neighbor);\r\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> ((*iter)-&gt;depth &gt; Neighbor-&gt;depth) {\r\n                    (*iter)-&gt;depth = Neighbor-&gt;depth;\r\n                }\r\n            }\r\n            closed_list.<span class=\"hljs-built_in\">emplace</span>(current_state);\r\n        }\r\n        <span class=\"hljs-comment\">// Cannot find the solution, return empty vector</span>\r\n        <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">vector</span>&lt;Puzzle&gt;(<span class=\"hljs-number\">0</span>);\r\n    }\r\n};\r\n}  <span class=\"hljs-comment\">// namespace aystar_search</span>\r\n}  <span class=\"hljs-comment\">// namespace machine_learning</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Self test-implementations\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-comment\">// Renaming for simplicity</span>\r\n    <span class=\"hljs-keyword\">using</span> matrix3 = std::array&lt;std::array&lt;<span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-number\">3</span>&gt;, <span class=\"hljs-number\">3</span>&gt;;\r\n    <span class=\"hljs-keyword\">using</span> row3 = std::array&lt;<span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-number\">3</span>&gt;;\r\n    <span class=\"hljs-keyword\">using</span> matrix4 = std::array&lt;std::array&lt;<span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-number\">4</span>&gt;, <span class=\"hljs-number\">4</span>&gt;;\r\n    <span class=\"hljs-keyword\">using</span> row4 = std::array&lt;<span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-number\">4</span>&gt;;\r\n    <span class=\"hljs-comment\">// 1st test: A* search for simple EightPuzzle problem</span>\r\n    matrix3 puzzle;\r\n    puzzle[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>});\r\n    puzzle[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>});\r\n    puzzle[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>});\r\n\r\n    matrix3 ideal;\r\n    ideal[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>});\r\n    ideal[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>});\r\n    ideal[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">0</span>});\r\n\r\n    <span class=\"hljs-comment\">/*\r\n     * Heuristic function: Manhattan distance\r\n     */</span>\r\n    <span class=\"hljs-keyword\">auto</span> manhattan_distance =\r\n        [](<span class=\"hljs-type\">const</span> machine_learning::aystar_search::EightPuzzle&lt;&gt; &amp;first,\r\n           <span class=\"hljs-type\">const</span> machine_learning::aystar_search::EightPuzzle&lt;&gt; &amp;second) {\r\n            <span class=\"hljs-type\">uint32_t</span> ret = <span class=\"hljs-number\">0</span>;\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; first.<span class=\"hljs-built_in\">get_size</span>(); ++i) {\r\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; first.<span class=\"hljs-built_in\">get_size</span>(); ++j) {\r\n                    <span class=\"hljs-type\">uint32_t</span> find = first.<span class=\"hljs-built_in\">get</span>(i, j);\r\n                    <span class=\"hljs-type\">size_t</span> m = first.<span class=\"hljs-built_in\">get_size</span>(), n = first.<span class=\"hljs-built_in\">get_size</span>();\r\n                    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> k = <span class=\"hljs-number\">0</span>; k &lt; second.<span class=\"hljs-built_in\">get_size</span>(); ++k) {\r\n                        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> l = <span class=\"hljs-number\">0</span>; l &lt; second.<span class=\"hljs-built_in\">get_size</span>(); ++l) {\r\n                            <span class=\"hljs-keyword\">if</span> (find == second.<span class=\"hljs-built_in\">get</span>(k, l)) {\r\n                                std::<span class=\"hljs-built_in\">tie</span>(m, n) = std::<span class=\"hljs-built_in\">make_pair</span>(k, l);\r\n                                <span class=\"hljs-keyword\">break</span>;\r\n                            }\r\n                        }\r\n                        <span class=\"hljs-keyword\">if</span> (m != first.<span class=\"hljs-built_in\">get_size</span>()) {\r\n                            <span class=\"hljs-keyword\">break</span>;\r\n                        }\r\n                    }\r\n                    <span class=\"hljs-keyword\">if</span> (m != first.<span class=\"hljs-built_in\">get_size</span>()) {\r\n                        ret += (std::<span class=\"hljs-built_in\">max</span>(m, i) - std::<span class=\"hljs-built_in\">min</span>(m, i)) +\r\n                               (std::<span class=\"hljs-built_in\">max</span>(n, j) - std::<span class=\"hljs-built_in\">min</span>(n, j));\r\n                    }\r\n                }\r\n            }\r\n            <span class=\"hljs-keyword\">return</span> ret;\r\n        };\r\n\r\n    machine_learning::aystar_search::EightPuzzle&lt;&gt; <span class=\"hljs-built_in\">Puzzle</span>(puzzle);\r\n    machine_learning::aystar_search::EightPuzzle&lt;&gt; <span class=\"hljs-built_in\">Ideal</span>(ideal);\r\n    machine_learning::aystar_search::AyStarSearch&lt;\r\n        machine_learning::aystar_search::EightPuzzle&lt;<span class=\"hljs-number\">3</span>&gt;&gt;\r\n        <span class=\"hljs-built_in\">search</span>(Puzzle, Ideal);  <span class=\"hljs-comment\">/// Search object</span>\r\n\r\n    std::vector&lt;matrix3&gt; answer;  <span class=\"hljs-comment\">/// Array that validates the answer</span>\r\n\r\n    answer.<span class=\"hljs-built_in\">push_back</span>(\r\n        <span class=\"hljs-built_in\">matrix3</span>({<span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>})}));\r\n    answer.<span class=\"hljs-built_in\">push_back</span>(\r\n        <span class=\"hljs-built_in\">matrix3</span>({<span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>})}));\r\n    answer.<span class=\"hljs-built_in\">push_back</span>(\r\n        <span class=\"hljs-built_in\">matrix3</span>({<span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>})}));\r\n    answer.<span class=\"hljs-built_in\">push_back</span>(\r\n        <span class=\"hljs-built_in\">matrix3</span>({<span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">8</span>})}));\r\n    answer.<span class=\"hljs-built_in\">push_back</span>(\r\n        <span class=\"hljs-built_in\">matrix3</span>({<span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">0</span>})}));\r\n\r\n    <span class=\"hljs-keyword\">auto</span> Solution = search.<span class=\"hljs-built_in\">a_star_search</span>(manhattan_distance);\r\n    std::cout &lt;&lt; Solution.<span class=\"hljs-built_in\">size</span>() &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-built_in\">assert</span>(Solution.<span class=\"hljs-built_in\">size</span>() == answer.<span class=\"hljs-built_in\">size</span>());\r\n\r\n    <span class=\"hljs-type\">uint32_t</span> i = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it = Solution.<span class=\"hljs-built_in\">rbegin</span>(); it != Solution.<span class=\"hljs-built_in\">rend</span>(); ++it) {\r\n        <span class=\"hljs-built_in\">assert</span>(it-&gt;<span class=\"hljs-built_in\">get_state</span>() == answer[i]);\r\n        ++i;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// 2nd test: A* search for complicated EightPuzzle problem</span>\r\n    <span class=\"hljs-comment\">// Initial state</span>\r\n    puzzle[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">3</span>});\r\n    puzzle[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">6</span>});\r\n    puzzle[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">8</span>});\r\n    <span class=\"hljs-comment\">// Final state</span>\r\n    ideal[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>});\r\n    ideal[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>});\r\n    ideal[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">0</span>});\r\n\r\n    Puzzle = machine_learning::aystar_search::EightPuzzle&lt;&gt;(puzzle);\r\n    Ideal = machine_learning::aystar_search::EightPuzzle&lt;&gt;(ideal);\r\n\r\n    <span class=\"hljs-comment\">// Initialize the search object</span>\r\n    search = machine_learning::aystar_search::AyStarSearch&lt;\r\n        machine_learning::aystar_search::EightPuzzle&lt;<span class=\"hljs-number\">3</span>&gt;&gt;(Puzzle, Ideal);\r\n\r\n    Solution = search.<span class=\"hljs-built_in\">a_star_search</span>(manhattan_distance);\r\n    std::cout &lt;&lt; Solution.<span class=\"hljs-built_in\">size</span>() &lt;&lt; std::endl;\r\n    <span class=\"hljs-comment\">// Static assertion due to large solution</span>\r\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-number\">13</span> == Solution.<span class=\"hljs-built_in\">size</span>());\r\n    <span class=\"hljs-comment\">// Check whether the final state is equal to expected one</span>\r\n    <span class=\"hljs-built_in\">assert</span>(Solution[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">get_state</span>() == ideal);\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it = Solution.<span class=\"hljs-built_in\">rbegin</span>(); it != Solution.<span class=\"hljs-built_in\">rend</span>(); ++it) {\r\n        std::cout &lt;&lt; *it &lt;&lt; std::endl;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// 3rd test: A* search for 15-Puzzle</span>\r\n    <span class=\"hljs-comment\">// Initial State of the puzzle</span>\r\n    matrix4 puzzle2;\r\n    puzzle2[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-built_in\">row4</span>({<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>});\r\n    puzzle2[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-built_in\">row4</span>({<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>});\r\n    puzzle2[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-built_in\">row4</span>({<span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>});\r\n    puzzle2[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-built_in\">row4</span>({<span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">12</span>});\r\n    <span class=\"hljs-comment\">// Final state of the puzzle</span>\r\n    matrix4 ideal2;\r\n    ideal2[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-built_in\">row4</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>});\r\n    ideal2[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-built_in\">row4</span>({<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>});\r\n    ideal2[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-built_in\">row4</span>({<span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">12</span>});\r\n    ideal2[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-built_in\">row4</span>({<span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">0</span>});\r\n\r\n    <span class=\"hljs-comment\">// Instantiate states for a*, initial state and final states</span>\r\n    machine_learning::<span class=\"hljs-function\">aystar_search::EightPuzzle&lt;4&gt; <span class=\"hljs-title\">Puzzle2</span><span class=\"hljs-params\">(puzzle2)</span>,\r\n        <span class=\"hljs-title\">Ideal2</span><span class=\"hljs-params\">(ideal2)</span></span>;\r\n    <span class=\"hljs-comment\">// Initialize the search object</span>\r\n    machine_learning::aystar_search::AyStarSearch&lt;\r\n        machine_learning::aystar_search::EightPuzzle&lt;<span class=\"hljs-number\">4</span>&gt;&gt;\r\n        <span class=\"hljs-built_in\">search2</span>(Puzzle2, Ideal2);\r\n    <span class=\"hljs-comment\">/**\r\n     * Heuristic function: Manhattan distance\r\n     */</span>\r\n    <span class=\"hljs-keyword\">auto</span> manhattan_distance2 =\r\n        [](<span class=\"hljs-type\">const</span> machine_learning::aystar_search::EightPuzzle&lt;<span class=\"hljs-number\">4</span>&gt; &amp;first,\r\n           <span class=\"hljs-type\">const</span> machine_learning::aystar_search::EightPuzzle&lt;<span class=\"hljs-number\">4</span>&gt; &amp;second) {\r\n            <span class=\"hljs-type\">uint32_t</span> ret = <span class=\"hljs-number\">0</span>;\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; first.<span class=\"hljs-built_in\">get_size</span>(); ++i) {\r\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; first.<span class=\"hljs-built_in\">get_size</span>(); ++j) {\r\n                    <span class=\"hljs-type\">uint32_t</span> find = first.<span class=\"hljs-built_in\">get</span>(i, j);\r\n                    <span class=\"hljs-type\">size_t</span> m = first.<span class=\"hljs-built_in\">get_size</span>(), n = first.<span class=\"hljs-built_in\">get_size</span>();\r\n                    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> k = <span class=\"hljs-number\">0</span>; k &lt; second.<span class=\"hljs-built_in\">get_size</span>(); ++k) {\r\n                        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> l = <span class=\"hljs-number\">0</span>; l &lt; second.<span class=\"hljs-built_in\">get_size</span>(); ++l) {\r\n                            <span class=\"hljs-keyword\">if</span> (find == second.<span class=\"hljs-built_in\">get</span>(k, l)) {\r\n                                std::<span class=\"hljs-built_in\">tie</span>(m, n) = std::<span class=\"hljs-built_in\">make_pair</span>(k, l);\r\n                                <span class=\"hljs-keyword\">break</span>;\r\n                            }\r\n                        }\r\n                        <span class=\"hljs-keyword\">if</span> (m != first.<span class=\"hljs-built_in\">get_size</span>()) {\r\n                            <span class=\"hljs-keyword\">break</span>;\r\n                        }\r\n                    }\r\n                    <span class=\"hljs-keyword\">if</span> (m != first.<span class=\"hljs-built_in\">get_size</span>()) {\r\n                        ret += (std::<span class=\"hljs-built_in\">max</span>(m, i) - std::<span class=\"hljs-built_in\">min</span>(m, i)) +\r\n                               (std::<span class=\"hljs-built_in\">max</span>(n, j) - std::<span class=\"hljs-built_in\">min</span>(n, j));\r\n                    }\r\n                }\r\n            }\r\n            <span class=\"hljs-keyword\">return</span> ret;\r\n        };\r\n\r\n    <span class=\"hljs-keyword\">auto</span> sol2 = search2.<span class=\"hljs-built_in\">a_star_search</span>(manhattan_distance2);\r\n    std::cout &lt;&lt; sol2.<span class=\"hljs-built_in\">size</span>() &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-comment\">// Static assertion due to large solution</span>\r\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-number\">24</span> == sol2.<span class=\"hljs-built_in\">size</span>());\r\n    <span class=\"hljs-comment\">// Check whether the final state is equal to expected one</span>\r\n    <span class=\"hljs-built_in\">assert</span>(sol2[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">get_state</span>() == ideal2);\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it = sol2.<span class=\"hljs-built_in\">rbegin</span>(); it != sol2.<span class=\"hljs-built_in\">rend</span>(); ++it) {\r\n        std::cout &lt;&lt; *it &lt;&lt; std::endl;\r\n    }\r\n}\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// run self-test implementations</span>\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "David Leal",
      "email": "halfpacho@gmail.com",
      "commits": 1
    },
    {
      "name": "Ashish Bhanu Daulatabad",
      "email": "supersonic12910@gmail.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}