{
  "slug": "kosaraju",
  "name": "Kosaraju",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "graph\\kosaraju.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph\\kosaraju.cpp",
      "code": "<span class=\"hljs-comment\">/* Implementation of Kosaraju&#x27;s Algorithm to find out the strongly connected\r\n   components (SCCs) in a graph. Author:Anirban166\r\n*/</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Iterative function/method to print graph:\r\n * @param a adjacency list representation of the graph\r\n * @param V number of vertices\r\n * @return void\r\n **/</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; &amp;a, <span class=\"hljs-type\">int</span> V)</span> </span>{\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) {\r\n        <span class=\"hljs-keyword\">if</span> (!a[i].<span class=\"hljs-built_in\">empty</span>()) {\r\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot;--&gt;&quot;</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j : a[i]) {\r\n            std::cout &lt;&lt; j &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (!a[i].<span class=\"hljs-built_in\">empty</span>()) {\r\n            std::cout &lt;&lt; std::endl;\r\n        }\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * //Recursive function/method to push vertices into stack passed as parameter:\r\n * @param v vertices\r\n * @param st stack passed by reference\r\n * @param vis array to keep track of visited nodes (boolean type)\r\n * @param adj adjacency list representation of the graph\r\n * @return void\r\n **/</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_vertex</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> v, std::stack&lt;<span class=\"hljs-type\">int</span>&gt; *st, std::vector&lt;<span class=\"hljs-type\">bool</span>&gt; *vis,\r\n                 <span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; &amp;adj)</span> </span>{\r\n    (*vis)[v] = <span class=\"hljs-literal\">true</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i = adj[v].<span class=\"hljs-built_in\">begin</span>(); i != adj[v].<span class=\"hljs-built_in\">end</span>(); i++) {\r\n        <span class=\"hljs-keyword\">if</span> ((*vis)[*i] == <span class=\"hljs-literal\">false</span>) {\r\n            <span class=\"hljs-built_in\">push_vertex</span>(*i, st, vis, adj);\r\n        }\r\n    }\r\n    st-&gt;<span class=\"hljs-built_in\">push</span>(v);\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * //Recursive function/method to implement depth first traversal(dfs):\r\n * @param v vertices\r\n * @param vis array to keep track of visited nodes (boolean type)\r\n * @param grev graph with reversed edges\r\n * @return void\r\n **/</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> v, std::vector&lt;<span class=\"hljs-type\">bool</span>&gt; *vis,\r\n         <span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; &amp;grev)</span> </span>{\r\n    (*vis)[v] = <span class=\"hljs-literal\">true</span>;\r\n    <span class=\"hljs-comment\">// cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i = grev[v].<span class=\"hljs-built_in\">begin</span>(); i != grev[v].<span class=\"hljs-built_in\">end</span>(); i++) {\r\n        <span class=\"hljs-keyword\">if</span> ((*vis)[*i] == <span class=\"hljs-literal\">false</span>) {\r\n            <span class=\"hljs-built_in\">dfs</span>(*i, vis, grev);\r\n        }\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">// function/method to implement Kosaraju&#x27;s Algorithm:</span>\r\n<span class=\"hljs-comment\">/**\r\n* Info about the method\r\n* @param V vertices in graph\r\n* @param adj array of vectors that represent a graph (adjacency list/array)\r\n* @return int ( 0, 1, 2..and so on, only unsigned values as either there can be\r\nno SCCs i.e. none(0) or there will be x no. of SCCs (x&gt;0)) i.e. it returns the\r\ncount of (number of) strongly connected components (SCCs) in the graph.\r\n(variable &#x27;count_scc&#x27; within function)\r\n**/</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">kosaraju</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> V, <span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; &amp;adj)</span> </span>{\r\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-title\">vis</span><span class=\"hljs-params\">(V, <span class=\"hljs-literal\">false</span>)</span></span>;\r\n    std::stack&lt;<span class=\"hljs-type\">int</span>&gt; st;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v = <span class=\"hljs-number\">0</span>; v &lt; V; v++) {\r\n        <span class=\"hljs-keyword\">if</span> (vis[v] == <span class=\"hljs-literal\">false</span>) {\r\n            <span class=\"hljs-built_in\">push_vertex</span>(v, &amp;st, &amp;vis, adj);\r\n        }\r\n    }\r\n    <span class=\"hljs-comment\">// making new graph (grev) with reverse edges as in adj[]:</span>\r\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; <span class=\"hljs-built_in\">grev</span>(V);\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V + <span class=\"hljs-number\">1</span>; i++) {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> j = adj[i].<span class=\"hljs-built_in\">begin</span>(); j != adj[i].<span class=\"hljs-built_in\">end</span>(); j++) {\r\n            grev[*j].<span class=\"hljs-built_in\">push_back</span>(i);\r\n        }\r\n    }\r\n    <span class=\"hljs-comment\">// cout&lt;&lt;&quot;grev=&quot;&lt;&lt;endl; -&gt;debug statement</span>\r\n    <span class=\"hljs-comment\">// print(grev,V);       -&gt;debug statement</span>\r\n    <span class=\"hljs-comment\">// reinitialise visited to 0</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) vis[i] = <span class=\"hljs-literal\">false</span>;\r\n    <span class=\"hljs-type\">int</span> count_scc = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-keyword\">while</span> (!st.<span class=\"hljs-built_in\">empty</span>()) {\r\n        <span class=\"hljs-type\">int</span> t = st.<span class=\"hljs-built_in\">top</span>();\r\n        st.<span class=\"hljs-built_in\">pop</span>();\r\n        <span class=\"hljs-keyword\">if</span> (vis[t] == <span class=\"hljs-literal\">false</span>) {\r\n            <span class=\"hljs-built_in\">dfs</span>(t, &amp;vis, grev);\r\n            count_scc++;\r\n        }\r\n    }\r\n    <span class=\"hljs-comment\">// cout&lt;&lt;&quot;count_scc=&quot;&lt;&lt;count_scc&lt;&lt;endl; //in case you want to print here</span>\r\n    <span class=\"hljs-comment\">// itself, uncomment &amp; change return type of function to void.</span>\r\n    <span class=\"hljs-keyword\">return</span> count_scc;\r\n}\r\n\r\n<span class=\"hljs-comment\">// All critical/corner cases have been taken care of.</span>\r\n<span class=\"hljs-comment\">// Input your required values: (not hardcoded)</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-type\">int</span> t = <span class=\"hljs-number\">0</span>;\r\n    std::cin &gt;&gt; t;\r\n    <span class=\"hljs-keyword\">while</span> (t--) {\r\n        <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">0</span>, b = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// a-&gt;number of nodes, b-&gt;directed edges.</span>\r\n        std::cin &gt;&gt; a &gt;&gt; b;\r\n        <span class=\"hljs-type\">int</span> m = <span class=\"hljs-number\">0</span>, n = <span class=\"hljs-number\">0</span>;\r\n        std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; <span class=\"hljs-built_in\">adj</span>(a + <span class=\"hljs-number\">1</span>);\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; b; i++)  <span class=\"hljs-comment\">// take total b inputs of 2 vertices each</span>\r\n                                     <span class=\"hljs-comment\">// required to form an edge.</span>\r\n        {\r\n            std::cin &gt;&gt; m &gt;&gt; n;  <span class=\"hljs-comment\">// take input m,n denoting edge from m-&gt;n.</span>\r\n            adj[m].<span class=\"hljs-built_in\">push_back</span>(n);\r\n        }\r\n        <span class=\"hljs-comment\">// pass number of nodes and adjacency array as parameters to function:</span>\r\n        std::cout &lt;&lt; <span class=\"hljs-built_in\">kosaraju</span>(a, adj) &lt;&lt; std::endl;\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Ayaan Khan",
      "email": "ayaankhan98@gmail.com",
      "commits": 1
    },
    {
      "name": "Anirban166",
      "email": "bloodraven166@gmail.com",
      "commits": 3
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 3
    }
  ],
  "explanationUrl": {}
}