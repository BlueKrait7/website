{
  "slug": "lowest-common-ancestor",
  "name": "Lowest Common Ancestor",
  "categories": [
    "datastructures",
    "binarytree"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "data_structures\\binary_tree\\lowest_common_ancestor.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/data_structures\\binary_tree\\lowest_common_ancestor.py",
      "code": "<span class=\"hljs-comment\"># https://en.wikipedia.org/wiki/Lowest_common_ancestor</span>\r\n<span class=\"hljs-comment\"># https://en.wikipedia.org/wiki/Breadth-first_search</span>\r\n\r\n<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\r\n\r\n<span class=\"hljs-keyword\">from</span> queue <span class=\"hljs-keyword\">import</span> Queue\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">swap</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">int</span>, b: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>]:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Return a tuple (b, a) when given two integers a and b\r\n    &gt;&gt;&gt; swap(2,3)\r\n    (3, 2)\r\n    &gt;&gt;&gt; swap(3,4)\r\n    (4, 3)\r\n    &gt;&gt;&gt; swap(67, 12)\r\n    (12, 67)\r\n    &quot;&quot;&quot;</span>\r\n    a ^= b\r\n    b ^= a\r\n    a ^= b\r\n    <span class=\"hljs-keyword\">return</span> a, b\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">create_sparse</span>(<span class=\"hljs-params\">max_node: <span class=\"hljs-built_in\">int</span>, parent: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]]</span>) -&gt; <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]]:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    creating sparse table which saves each nodes 2^i-th parent\r\n    &quot;&quot;&quot;</span>\r\n    j = <span class=\"hljs-number\">1</span>\r\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span> &lt;&lt; j) &lt; max_node:\r\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, max_node + <span class=\"hljs-number\">1</span>):\r\n            parent[j][i] = parent[j - <span class=\"hljs-number\">1</span>][parent[j - <span class=\"hljs-number\">1</span>][i]]\r\n        j += <span class=\"hljs-number\">1</span>\r\n    <span class=\"hljs-keyword\">return</span> parent\r\n\r\n\r\n<span class=\"hljs-comment\"># returns lca of node u,v</span>\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">lowest_common_ancestor</span>(<span class=\"hljs-params\">\r\n    u: <span class=\"hljs-built_in\">int</span>, v: <span class=\"hljs-built_in\">int</span>, level: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>], parent: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]]\r\n</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\r\n    <span class=\"hljs-comment\"># u must be deeper in the tree than v</span>\r\n    <span class=\"hljs-keyword\">if</span> level[u] &lt; level[v]:\r\n        u, v = swap(u, v)\r\n    <span class=\"hljs-comment\"># making depth of u same as depth of v</span>\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">18</span>, -<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>):\r\n        <span class=\"hljs-keyword\">if</span> level[u] - (<span class=\"hljs-number\">1</span> &lt;&lt; i) &gt;= level[v]:\r\n            u = parent[i][u]\r\n    <span class=\"hljs-comment\"># at the same depth if u==v that mean lca is found</span>\r\n    <span class=\"hljs-keyword\">if</span> u == v:\r\n        <span class=\"hljs-keyword\">return</span> u\r\n    <span class=\"hljs-comment\"># moving both nodes upwards till lca in found</span>\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">18</span>, -<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>):\r\n        <span class=\"hljs-keyword\">if</span> parent[i][u] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-number\">0</span>, parent[i][v]]:\r\n            u, v = parent[i][u], parent[i][v]\r\n    <span class=\"hljs-comment\"># returning longest common ancestor of u,v</span>\r\n    <span class=\"hljs-keyword\">return</span> parent[<span class=\"hljs-number\">0</span>][u]\r\n\r\n\r\n<span class=\"hljs-comment\"># runs a breadth first search from root node of the tree</span>\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">breadth_first_search</span>(<span class=\"hljs-params\">\r\n    level: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>],\r\n    parent: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]],\r\n    max_node: <span class=\"hljs-built_in\">int</span>,\r\n    graph: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]],\r\n    root: <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">1</span>,\r\n</span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>], <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]]]:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    sets every nodes direct parent\r\n    parent of root node is set to 0\r\n    calculates depth of each node from root node\r\n    &quot;&quot;&quot;</span>\r\n    level[root] = <span class=\"hljs-number\">0</span>\r\n    q: Queue[<span class=\"hljs-built_in\">int</span>] = Queue(maxsize=max_node)\r\n    q.put(root)\r\n    <span class=\"hljs-keyword\">while</span> q.qsize() != <span class=\"hljs-number\">0</span>:\r\n        u = q.get()\r\n        <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> graph[u]:\r\n            <span class=\"hljs-keyword\">if</span> level[v] == -<span class=\"hljs-number\">1</span>:\r\n                level[v] = level[u] + <span class=\"hljs-number\">1</span>\r\n                q.put(v)\r\n                parent[<span class=\"hljs-number\">0</span>][v] = u\r\n    <span class=\"hljs-keyword\">return</span> level, parent\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">main</span>() -&gt; <span class=\"hljs-literal\">None</span>:\r\n    max_node = <span class=\"hljs-number\">13</span>\r\n    <span class=\"hljs-comment\"># initializing with 0</span>\r\n    parent = [[<span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(max_node + <span class=\"hljs-number\">10</span>)] <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">20</span>)]\r\n    <span class=\"hljs-comment\"># initializing with -1 which means every node is unvisited</span>\r\n    level = [-<span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(max_node + <span class=\"hljs-number\">10</span>)]\r\n    graph: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]] = {\r\n        <span class=\"hljs-number\">1</span>: [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>],\r\n        <span class=\"hljs-number\">2</span>: [<span class=\"hljs-number\">5</span>],\r\n        <span class=\"hljs-number\">3</span>: [<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>],\r\n        <span class=\"hljs-number\">4</span>: [<span class=\"hljs-number\">8</span>],\r\n        <span class=\"hljs-number\">5</span>: [<span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>],\r\n        <span class=\"hljs-number\">6</span>: [<span class=\"hljs-number\">11</span>],\r\n        <span class=\"hljs-number\">7</span>: [],\r\n        <span class=\"hljs-number\">8</span>: [<span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">13</span>],\r\n        <span class=\"hljs-number\">9</span>: [],\r\n        <span class=\"hljs-number\">10</span>: [],\r\n        <span class=\"hljs-number\">11</span>: [],\r\n        <span class=\"hljs-number\">12</span>: [],\r\n        <span class=\"hljs-number\">13</span>: [],\r\n    }\r\n    level, parent = breadth_first_search(level, parent, max_node, graph, <span class=\"hljs-number\">1</span>)\r\n    parent = create_sparse(max_node, parent)\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 1 and 3 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, level, parent))\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 5 and 6 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, level, parent))\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 7 and 11 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>, level, parent))\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 6 and 7 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, level, parent))\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 4 and 12 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">12</span>, level, parent))\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 8 and 8 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">8</span>, level, parent))\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    main()\r\n"
    },
    "c-plus-plus": {
      "dir": "graph\\lowest_common_ancestor.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph\\lowest_common_ancestor.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n *\r\n * \\file\r\n *\r\n * \\brief Data structure for finding the lowest common ancestor\r\n * of two vertices in a rooted tree using binary lifting.\r\n *\r\n * \\details\r\n * Algorithm: https://cp-algorithms.com/graph/lca_binary_lifting.html\r\n *\r\n * Complexity:\r\n *   - Precomputation: \\f$O(N \\log N)\\f$ where \\f$N\\f$ is the number of vertices\r\n * in the tree\r\n *   - Query: \\f$O(\\log N)\\f$\r\n *   - Space: \\f$O(N \\log N)\\f$\r\n *\r\n * Example:\r\n * &lt;br/&gt;  Tree:\r\n * &lt;pre&gt;\r\n *             _  3  _\r\n *          /     |     \\\r\n *        1       6       4\r\n *      / |     /   \\       \\\r\n *    7   5   2       8       0\r\n *            |\r\n *            9\r\n * &lt;/pre&gt;\r\n *\r\n * &lt;br/&gt;  lowest_common_ancestor(7, 4) = 3\r\n * &lt;br/&gt;  lowest_common_ancestor(9, 6) = 6\r\n * &lt;br/&gt;  lowest_common_ancestor(0, 0) = 0\r\n * &lt;br/&gt;  lowest_common_ancestor(8, 2) = 6\r\n *\r\n *   The query is symmetrical, therefore\r\n *     lowest_common_ancestor(x, y) = lowest_common_ancestor(y, x)\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;utility&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * \\namespace graph\r\n * \\brief Graph algorithms\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> graph {\r\n<span class=\"hljs-comment\">/**\r\n * Class for representing a graph as an adjacency list.\r\n * Its vertices are indexed 0, 1, ..., N - 1.\r\n */</span>\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span> {\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-comment\">/**\r\n     * \\brief Populate the adjacency list for each vertex in the graph.\r\n     * Assumes that evey edge is a pair of valid vertex indices.\r\n     *\r\n     * @param N number of vertices in the graph\r\n     * @param undirected_edges list of graph&#x27;s undirected edges\r\n     */</span>\r\n    <span class=\"hljs-built_in\">Graph</span>(<span class=\"hljs-type\">size_t</span> N, <span class=\"hljs-type\">const</span> std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; &gt; &amp;undirected_edges) {\r\n        neighbors.<span class=\"hljs-built_in\">resize</span>(N);\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;edge : undirected_edges) {\r\n            neighbors[edge.first].<span class=\"hljs-built_in\">push_back</span>(edge.second);\r\n            neighbors[edge.second].<span class=\"hljs-built_in\">push_back</span>(edge.first);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Function to get the number of vertices in the graph\r\n     * @return the number of vertices in the graph.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">number_of_vertices</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>{ <span class=\"hljs-keyword\">return</span> neighbors.<span class=\"hljs-built_in\">size</span>(); }\r\n\r\n    <span class=\"hljs-comment\">/** \\brief for each vertex it stores a list indicies of its neighbors */</span>\r\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; neighbors;\r\n};\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Representation of a rooted tree. For every vertex its parent is\r\n * precalculated.\r\n */</span>\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RootedTree</span> : <span class=\"hljs-keyword\">public</span> Graph {\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-comment\">/**\r\n     * \\brief Constructs the tree by calculating parent for every vertex.\r\n     * Assumes a valid description of a tree is provided.\r\n     *\r\n     * @param undirected_edges list of graph&#x27;s undirected edges\r\n     * @param root_ index of the root vertex\r\n     */</span>\r\n    <span class=\"hljs-built_in\">RootedTree</span>(<span class=\"hljs-type\">const</span> std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; &gt; &amp;undirected_edges,\r\n               <span class=\"hljs-type\">int</span> root_)\r\n        : <span class=\"hljs-built_in\">Graph</span>(undirected_edges.<span class=\"hljs-built_in\">size</span>() + <span class=\"hljs-number\">1</span>, undirected_edges), <span class=\"hljs-built_in\">root</span>(root_) {\r\n        <span class=\"hljs-built_in\">populate_parents</span>();\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * \\brief Stores parent of every vertex and for root its own index.\r\n     * The root is technically not its own parent, but it&#x27;s very practical\r\n     * for the lowest common ancestor algorithm.\r\n     */</span>\r\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; parent;\r\n    <span class=\"hljs-comment\">/** \\brief Stores the distance from the root. */</span>\r\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; level;\r\n    <span class=\"hljs-comment\">/** \\brief Index of the root vertex. */</span>\r\n    <span class=\"hljs-type\">int</span> root;\r\n\r\n <span class=\"hljs-keyword\">protected</span>:\r\n    <span class=\"hljs-comment\">/**\r\n     * \\brief Calculate the parents for all the vertices in the tree.\r\n     * Implements the breadth first search algorithm starting from the root\r\n     * vertex searching the entire tree and labeling parents for all vertices.\r\n     * @returns none\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">populate_parents</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-comment\">// Initialize the vector with -1 which indicates the vertex</span>\r\n        <span class=\"hljs-comment\">// wasn&#x27;t yet visited.</span>\r\n        parent = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(<span class=\"hljs-built_in\">number_of_vertices</span>(), <span class=\"hljs-number\">-1</span>);\r\n        level = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(<span class=\"hljs-built_in\">number_of_vertices</span>());\r\n        parent[root] = root;\r\n        level[root] = <span class=\"hljs-number\">0</span>;\r\n        std::queue&lt;<span class=\"hljs-type\">int</span>&gt; queue_of_vertices;\r\n        queue_of_vertices.<span class=\"hljs-built_in\">push</span>(root);\r\n        <span class=\"hljs-keyword\">while</span> (!queue_of_vertices.<span class=\"hljs-built_in\">empty</span>()) {\r\n            <span class=\"hljs-type\">int</span> vertex = queue_of_vertices.<span class=\"hljs-built_in\">front</span>();\r\n            queue_of_vertices.<span class=\"hljs-built_in\">pop</span>();\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> neighbor : neighbors[vertex]) {\r\n                <span class=\"hljs-comment\">// As long as the vertex was not yet visited.</span>\r\n                <span class=\"hljs-keyword\">if</span> (parent[neighbor] == <span class=\"hljs-number\">-1</span>) {\r\n                    parent[neighbor] = vertex;\r\n                    level[neighbor] = level[vertex] + <span class=\"hljs-number\">1</span>;\r\n                    queue_of_vertices.<span class=\"hljs-built_in\">push</span>(neighbor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n<span class=\"hljs-comment\">/**\r\n * A structure that holds a rooted tree and allow for effecient\r\n * queries of the lowest common ancestor of two given vertices in the tree.\r\n */</span>\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LowestCommonAncestor</span> {\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-comment\">/**\r\n     * \\brief Stores the tree and precomputs &quot;up lifts&quot;.\r\n     * @param tree_ rooted tree.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">LowestCommonAncestor</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> RootedTree &amp;tree_)</span> : tree(tree_) {</span>\r\n        <span class=\"hljs-built_in\">populate_up</span>();\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * \\brief Query the structure to find the lowest common ancestor.\r\n     * Assumes that the provided numbers are valid indices of vertices.\r\n     * Iterativelly modifies (&quot;lifts&quot;) u an v until it finnds their lowest\r\n     * common ancestor.\r\n     * @param u index of one of the queried vertex\r\n     * @param v index of the other queried vertex\r\n     * @return index of the vertex which is the lowet common ancestor of u and v\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">lowest_common_ancestor</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> v)</span> <span class=\"hljs-type\">const</span> </span>{\r\n        <span class=\"hljs-comment\">// Ensure u is the deeper (higher level) of the two vertices</span>\r\n        <span class=\"hljs-keyword\">if</span> (tree.level[v] &gt; tree.level[u]) {\r\n            std::<span class=\"hljs-built_in\">swap</span>(u, v);\r\n        }\r\n\r\n        <span class=\"hljs-comment\">// &quot;Lift&quot; u to the same level as v.</span>\r\n        <span class=\"hljs-type\">int</span> level_diff = tree.level[u] - tree.level[v];\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; (<span class=\"hljs-number\">1</span> &lt;&lt; i) &lt;= level_diff; ++i) {\r\n            <span class=\"hljs-keyword\">if</span> (level_diff &amp; (<span class=\"hljs-number\">1</span> &lt;&lt; i)) {\r\n                u = up[u][i];\r\n            }\r\n        }\r\n        <span class=\"hljs-built_in\">assert</span>(tree.level[u] == tree.level[v]);\r\n\r\n        <span class=\"hljs-keyword\">if</span> (u == v) {\r\n            <span class=\"hljs-keyword\">return</span> u;\r\n        }\r\n\r\n        <span class=\"hljs-comment\">// &quot;Lift&quot; u and v to their 2^i th ancestor if they are different</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(up[u].<span class=\"hljs-built_in\">size</span>()) - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; --i) {\r\n            <span class=\"hljs-keyword\">if</span> (up[u][i] != up[v][i]) {\r\n                u = up[u][i];\r\n                v = up[v][i];\r\n            }\r\n        }\r\n\r\n        <span class=\"hljs-comment\">// As we regressed u an v such that they cannot further be lifted so</span>\r\n        <span class=\"hljs-comment\">// that their ancestor would be different, the only logical</span>\r\n        <span class=\"hljs-comment\">// consequence is that their parent is the sought answer.</span>\r\n        <span class=\"hljs-built_in\">assert</span>(up[u][<span class=\"hljs-number\">0</span>] == up[v][<span class=\"hljs-number\">0</span>]);\r\n        <span class=\"hljs-keyword\">return</span> up[u][<span class=\"hljs-number\">0</span>];\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/* \\brief reference to the rooted tree this structure allows to query */</span>\r\n    <span class=\"hljs-type\">const</span> RootedTree &amp;tree;\r\n    <span class=\"hljs-comment\">/**\r\n     * \\brief for every vertex stores a list of its ancestors by powers of two\r\n     * For each vertex, the first element of the corresponding list contains\r\n     * the index of its parent. The i-th element of the list is an index of\r\n     * the (2^i)-th ancestor of the vertex.\r\n     */</span>\r\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; up;\r\n\r\n <span class=\"hljs-keyword\">protected</span>:\r\n    <span class=\"hljs-comment\">/**\r\n     * Populate the &quot;up&quot; structure. See above.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">populate_up</span><span class=\"hljs-params\">()</span> </span>{\r\n        up.<span class=\"hljs-built_in\">resize</span>(tree.<span class=\"hljs-built_in\">number_of_vertices</span>());\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> vertex = <span class=\"hljs-number\">0</span>; vertex &lt; tree.<span class=\"hljs-built_in\">number_of_vertices</span>(); ++vertex) {\r\n            up[vertex].<span class=\"hljs-built_in\">push_back</span>(tree.parent[vertex]);\r\n        }\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> level = <span class=\"hljs-number\">0</span>; (<span class=\"hljs-number\">1</span> &lt;&lt; level) &lt; tree.<span class=\"hljs-built_in\">number_of_vertices</span>(); ++level) {\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> vertex = <span class=\"hljs-number\">0</span>; vertex &lt; tree.<span class=\"hljs-built_in\">number_of_vertices</span>(); ++vertex) {\r\n                <span class=\"hljs-comment\">// up[vertex][level + 1] = 2^(level + 1) th ancestor of vertex =</span>\r\n                <span class=\"hljs-comment\">// = 2^level th ancestor of 2^level th ancestor of vertex =</span>\r\n                <span class=\"hljs-comment\">// = 2^level th ancestor of up[vertex][level]</span>\r\n                up[vertex].<span class=\"hljs-built_in\">push_back</span>(up[up[vertex][level]][level]);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n}  <span class=\"hljs-comment\">// namespace graph</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Unit tests\r\n * @returns none\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">tests</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-comment\">/**\r\n     *             _  3  _\r\n     *          /     |     \\\r\n     *        1       6       4\r\n     *      / |     /   \\       \\\r\n     *    7   5   2       8       0\r\n     *            |\r\n     *            9\r\n     */</span>\r\n    std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; &gt; edges = {\r\n        {<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>}, {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>}, {<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">9</span>}, {<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>}, {<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>}, {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">4</span>}};\r\n    <span class=\"hljs-function\">graph::RootedTree <span class=\"hljs-title\">t</span><span class=\"hljs-params\">(edges, <span class=\"hljs-number\">3</span>)</span></span>;\r\n    <span class=\"hljs-function\">graph::LowestCommonAncestor <span class=\"hljs-title\">lca</span><span class=\"hljs-params\">(t)</span></span>;\r\n    <span class=\"hljs-built_in\">assert</span>(lca.<span class=\"hljs-built_in\">lowest_common_ancestor</span>(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">4</span>) == <span class=\"hljs-number\">3</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(lca.<span class=\"hljs-built_in\">lowest_common_ancestor</span>(<span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">6</span>) == <span class=\"hljs-number\">6</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(lca.<span class=\"hljs-built_in\">lowest_common_ancestor</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>) == <span class=\"hljs-number\">0</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(lca.<span class=\"hljs-built_in\">lowest_common_ancestor</span>(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">2</span>) == <span class=\"hljs-number\">6</span>);\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Main function */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-built_in\">tests</span>();\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "David Leal",
      "email": "halfpacho@gmail.com",
      "commits": 1
    },
    {
      "name": "Dylan Buchi",
      "email": "devybuchi@gmail.com",
      "commits": 1
    },
    {
      "name": "kanthuc",
      "email": "srikanthuchavali@gmail.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 2
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 3
    }
  ],
  "explanationUrl": {}
}