{
  "slug": "extended-euclid-algorithm",
  "name": "Extended Euclid Algorithm",
  "categories": [
    "math"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "math\\extended_euclid_algorithm.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/math\\extended_euclid_algorithm.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @brief GCD using [extended Euclid&#x27;s algorithm]\r\n * (https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)\r\n *\r\n * Finding coefficients of a and b ie x and y in  BÃ©zout&#x27;s identity\r\n * \\f[\\text{gcd}(a, b) = a \\times x + b \\times y \\f]\r\n * This is also used in finding Modular\r\n * multiplicative inverse of a number. (A * B)%M == 1 Here B is the MMI of A for\r\n * given M, so extendedEuclid (A, M) gives B.\r\n */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span>  <span class=\"hljs-comment\">// for swap function</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * function to update the coefficients per iteration\r\n * \\f[r_0,\\,r = r,\\, r_0 - \\text{quotient}\\times r\\f]\r\n *\r\n * @param[in,out] r signed or unsigned\r\n * @param[in,out] r0 signed or unsigned\r\n * @param[in] quotient  unsigned\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> T2&gt;\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">update_step</span><span class=\"hljs-params\">(T *r, T *r0, <span class=\"hljs-type\">const</span> T2 quotient)</span> </span>{\r\n    T temp = *r;\r\n    *r = *r0 - (quotient * temp);\r\n    *r0 = temp;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Implementation using iterative algorithm from\r\n * [Wikipedia](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Pseudocode)\r\n *\r\n * @param[in] A unsigned\r\n * @param[in] B unsigned\r\n * @param[out] GCD unsigned\r\n * @param[out] x signed\r\n * @param[out] y signed\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T1, <span class=\"hljs-keyword\">typename</span> T2&gt;\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">extendedEuclid_1</span><span class=\"hljs-params\">(T1 A, T1 B, T1 *GCD, T2 *x, T2 *y)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (B &gt; A)\r\n        std::<span class=\"hljs-built_in\">swap</span>(A, B);  <span class=\"hljs-comment\">// Ensure that A &gt;= B</span>\r\n\r\n    T2 s = <span class=\"hljs-number\">0</span>, s0 = <span class=\"hljs-number\">1</span>;\r\n    T2 t = <span class=\"hljs-number\">1</span>, t0 = <span class=\"hljs-number\">0</span>;\r\n    T1 r = B, r0 = A;\r\n\r\n    <span class=\"hljs-keyword\">while</span> (r != <span class=\"hljs-number\">0</span>) {\r\n        T1 quotient = r0 / r;\r\n        <span class=\"hljs-built_in\">update_step</span>(&amp;r, &amp;r0, quotient);\r\n        <span class=\"hljs-built_in\">update_step</span>(&amp;s, &amp;s0, quotient);\r\n        <span class=\"hljs-built_in\">update_step</span>(&amp;t, &amp;t0, quotient);\r\n    }\r\n    *GCD = r0;\r\n    *x = s0;\r\n    *y = t0;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Implementation using recursive algorithm\r\n *\r\n * @param[in] A unsigned\r\n * @param[in] B unsigned\r\n * @param[out] GCD unsigned\r\n * @param[in,out] x signed\r\n * @param[in,out] y signed\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> T2&gt;\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">extendedEuclid</span><span class=\"hljs-params\">(T A, T B, T *GCD, T2 *x, T2 *y)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (B &gt; A)\r\n        std::<span class=\"hljs-built_in\">swap</span>(A, B);  <span class=\"hljs-comment\">// Ensure that A &gt;= B</span>\r\n\r\n    <span class=\"hljs-keyword\">if</span> (B == <span class=\"hljs-number\">0</span>) {\r\n        *GCD = A;\r\n        *x = <span class=\"hljs-number\">1</span>;\r\n        *y = <span class=\"hljs-number\">0</span>;\r\n    } <span class=\"hljs-keyword\">else</span> {\r\n        <span class=\"hljs-built_in\">extendedEuclid</span>(B, A % B, GCD, x, y);\r\n        T2 temp = *x;\r\n        *x = *y;\r\n        *y = temp - (A / B) * (*y);\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/// Main function</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-type\">uint32_t</span> a, b, gcd;\r\n    <span class=\"hljs-type\">int32_t</span> x, y;\r\n    std::cin &gt;&gt; a &gt;&gt; b;\r\n    <span class=\"hljs-built_in\">extendedEuclid</span>(a, b, &amp;gcd, &amp;x, &amp;y);\r\n    std::cout &lt;&lt; gcd &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl;\r\n    <span class=\"hljs-built_in\">extendedEuclid_1</span>(a, b, &amp;gcd, &amp;x, &amp;y);\r\n    std::cout &lt;&lt; gcd &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl;\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [],
  "explanationUrl": {}
}