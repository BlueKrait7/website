{
  "slug": "points-are-collinear-3d",
  "name": "Points Are Collinear 3d",
  "categories": [
    "math"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "maths\\points_are_collinear_3d.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/maths\\points_are_collinear_3d.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;\r\nCheck if three points are collinear in 3D.\r\n\r\nIn short, the idea is that we are able to create a triangle using three points,\r\nand the area of that triangle can determine if the three points are collinear or not.\r\n\r\n\r\nFirst, we create two vectors with the same initial point from the three points,\r\nthen we will calculate the cross-product of them.\r\n\r\nThe length of the cross vector is numerically equal to the area of a parallelogram.\r\n\r\nFinally, the area of the triangle is equal to half of the area of the parallelogram.\r\n\r\nSince we are only differentiating between zero and anything else,\r\nwe can get rid of the square root when calculating the length of the vector,\r\nand also the division by two at the end.\r\n\r\nFrom a second perspective, if the two vectors are parallel and overlapping,\r\nwe can&#x27;t get a nonzero perpendicular vector,\r\nsince there will be an infinite number of orthogonal vectors.\r\n\r\nTo simplify the solution we will not calculate the length,\r\nbut we will decide directly from the vector whether it is equal to (0, 0, 0) or not.\r\n\r\n\r\nRead More:\r\n    https://math.stackexchange.com/a/1951650\r\n&quot;&quot;&quot;</span>\r\n\r\nVector3d = <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">float</span>, <span class=\"hljs-built_in\">float</span>, <span class=\"hljs-built_in\">float</span>]\r\nPoint3d = <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">float</span>, <span class=\"hljs-built_in\">float</span>, <span class=\"hljs-built_in\">float</span>]\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">create_vector</span>(<span class=\"hljs-params\">end_point1: Point3d, end_point2: Point3d</span>) -&gt; Vector3d:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Pass two points to get the vector from them in the form (x, y, z).\r\n\r\n    &gt;&gt;&gt; create_vector((0, 0, 0), (1, 1, 1))\r\n    (1, 1, 1)\r\n    &gt;&gt;&gt; create_vector((45, 70, 24), (47, 32, 1))\r\n    (2, -38, -23)\r\n    &gt;&gt;&gt; create_vector((-14, -1, -8), (-7, 6, 4))\r\n    (7, 7, 12)\r\n    &quot;&quot;&quot;</span>\r\n    x = end_point2[<span class=\"hljs-number\">0</span>] - end_point1[<span class=\"hljs-number\">0</span>]\r\n    y = end_point2[<span class=\"hljs-number\">1</span>] - end_point1[<span class=\"hljs-number\">1</span>]\r\n    z = end_point2[<span class=\"hljs-number\">2</span>] - end_point1[<span class=\"hljs-number\">2</span>]\r\n    <span class=\"hljs-keyword\">return</span> (x, y, z)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_3d_vectors_cross</span>(<span class=\"hljs-params\">ab: Vector3d, ac: Vector3d</span>) -&gt; Vector3d:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Get the cross of the two vectors AB and AC.\r\n\r\n    I used determinant of 2x2 to get the determinant of the 3x3 matrix in the process.\r\n\r\n    Read More:\r\n        https://en.wikipedia.org/wiki/Cross_product\r\n        https://en.wikipedia.org/wiki/Determinant\r\n\r\n    &gt;&gt;&gt; get_3d_vectors_cross((3, 4, 7), (4, 9, 2))\r\n    (-55, 22, 11)\r\n    &gt;&gt;&gt; get_3d_vectors_cross((1, 1, 1), (1, 1, 1))\r\n    (0, 0, 0)\r\n    &gt;&gt;&gt; get_3d_vectors_cross((-4, 3, 0), (3, -9, -12))\r\n    (-36, -48, 27)\r\n    &gt;&gt;&gt; get_3d_vectors_cross((17.67, 4.7, 6.78), (-9.5, 4.78, -19.33))\r\n    (-123.2594, 277.15110000000004, 129.11260000000001)\r\n    &quot;&quot;&quot;</span>\r\n    x = ab[<span class=\"hljs-number\">1</span>] * ac[<span class=\"hljs-number\">2</span>] - ab[<span class=\"hljs-number\">2</span>] * ac[<span class=\"hljs-number\">1</span>]  <span class=\"hljs-comment\"># *i</span>\r\n    y = (ab[<span class=\"hljs-number\">0</span>] * ac[<span class=\"hljs-number\">2</span>] - ab[<span class=\"hljs-number\">2</span>] * ac[<span class=\"hljs-number\">0</span>]) * -<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># *j</span>\r\n    z = ab[<span class=\"hljs-number\">0</span>] * ac[<span class=\"hljs-number\">1</span>] - ab[<span class=\"hljs-number\">1</span>] * ac[<span class=\"hljs-number\">0</span>]  <span class=\"hljs-comment\"># *k</span>\r\n    <span class=\"hljs-keyword\">return</span> (x, y, z)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">is_zero_vector</span>(<span class=\"hljs-params\">vector: Vector3d, accuracy: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Check if vector is equal to (0, 0, 0) of not.\r\n\r\n    Sine the algorithm is very accurate, we will never get a zero vector,\r\n    so we need to round the vector axis,\r\n    because we want a result that is either True or False.\r\n    In other applications, we can return a float that represents the collinearity ratio.\r\n\r\n    &gt;&gt;&gt; is_zero_vector((0, 0, 0), accuracy=10)\r\n    True\r\n    &gt;&gt;&gt; is_zero_vector((15, 74, 32), accuracy=10)\r\n    False\r\n    &gt;&gt;&gt; is_zero_vector((-15, -74, -32), accuracy=10)\r\n    False\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">tuple</span>(<span class=\"hljs-built_in\">round</span>(x, accuracy) <span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> vector) == (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">are_collinear</span>(<span class=\"hljs-params\">a: Point3d, b: Point3d, c: Point3d, accuracy: <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">10</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Check if three points are collinear or not.\r\n\r\n    1- Create tow vectors AB and AC.\r\n    2- Get the cross vector of the tow vectors.\r\n    3- Calcolate the length of the cross vector.\r\n    4- If the length is zero then the points are collinear, else they are not.\r\n\r\n    The use of the accuracy parameter is explained in is_zero_vector docstring.\r\n\r\n    &gt;&gt;&gt; are_collinear((4.802293498137402, 3.536233125455244, 0),\r\n    ...               (-2.186788107953106, -9.24561398001649, 7.141509524846482),\r\n    ...               (1.530169574640268, -2.447927606600034, 3.343487096469054))\r\n    True\r\n    &gt;&gt;&gt; are_collinear((-6, -2, 6),\r\n    ...               (6.200213806439997, -4.930157614926678, -4.482371908289856),\r\n    ...               (-4.085171149525941, -2.459889509029438, 4.354787180795383))\r\n    True\r\n    &gt;&gt;&gt; are_collinear((2.399001826862445, -2.452009976680793, 4.464656666157666),\r\n    ...               (-3.682816335934376, 5.753788986533145, 9.490993909044244),\r\n    ...               (1.962903518985307, 3.741415730125627, 7))\r\n    False\r\n    &gt;&gt;&gt; are_collinear((1.875375340689544, -7.268426006071538, 7.358196269835993),\r\n    ...               (-3.546599383667157, -4.630005261513976, 3.208784032924246),\r\n    ...               (-2.564606140206386, 3.937845170672183, 7))\r\n    False\r\n    &quot;&quot;&quot;</span>\r\n    ab = create_vector(a, b)\r\n    ac = create_vector(a, c)\r\n    <span class=\"hljs-keyword\">return</span> is_zero_vector(get_3d_vectors_cross(ab, ac), accuracy)\r\n"
    }
  },
  "contributors": [
    {
      "name": "zer0-x",
      "email": "65136727+zer0-x@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}