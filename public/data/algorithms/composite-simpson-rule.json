{
  "slug": "composite-simpson-rule",
  "name": "Composite Simpson Rule",
  "categories": [
    "numericalmethods"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "numerical_methods\\composite_simpson_rule.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/numerical_methods\\composite_simpson_rule.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @brief Implementation of the Composite Simpson Rule for the approximation\r\n *\r\n * @details The following is an implementation of the Composite Simpson Rule for\r\n * the approximation of definite integrals. More info -&gt; wiki:\r\n * https://en.wikipedia.org/wiki/Simpson%27s_rule#Composite_Simpson&#x27;s_rule\r\n *\r\n * The idea is to split the interval in an EVEN number N of intervals and use as\r\n * interpolation points the xi for which it applies that xi = x0 + i*h, where h\r\n * is a step defined as h = (b-a)/N where a and b are the first and last points\r\n * of the interval of the integration [a, b].\r\n *\r\n * We create a table of the xi and their corresponding f(xi) values and we\r\n * evaluate the integral by the formula: I = h/3 * {f(x0) + 4*f(x1) + 2*f(x2) +\r\n * ... + 2*f(xN-2) + 4*f(xN-1) + f(xN)}\r\n *\r\n * That means that the first and last indexed i f(xi) are multiplied by 1,\r\n * the odd indexed f(xi) by 4 and the even by 2.\r\n *\r\n * In this program there are 4 sample test functions f, g, k, l that are\r\n * evaluated in the same interval.\r\n *\r\n * Arguments can be passed as parameters from the command line argv[1] = N,\r\n * argv[2] = a, argv[3] = b\r\n *\r\n * N must be even number and a&lt;b.\r\n *\r\n * In the end of the main() i compare the program&#x27;s result with the one from\r\n * mathematical software with 2 decimal points margin.\r\n *\r\n * Add sample function by replacing one of the f, g, k, l and the assert\r\n *\r\n * @author [ggkogkou](https://github.com/ggkogkou)\r\n *\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>  <span class=\"hljs-comment\">/// for assert</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span>    <span class=\"hljs-comment\">/// for math functions</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdint&gt;</span>     <span class=\"hljs-comment\">/// for integer allocation</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span>     <span class=\"hljs-comment\">/// for std::atof</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;functional&gt;</span>  <span class=\"hljs-comment\">/// for std::function</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>    <span class=\"hljs-comment\">/// for IO operations</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span>         <span class=\"hljs-comment\">/// for std::map container</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace numerical_methods\r\n * @brief Numerical algorithms/methods\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> numerical_methods {\r\n<span class=\"hljs-comment\">/**\r\n * @namespace simpson_method\r\n * @brief Contains the Simpson&#x27;s method implementation\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> simpson_method {\r\n<span class=\"hljs-comment\">/**\r\n * @fn double evaluate_by_simpson(int N, double h, double a,\r\n * std::function&lt;double (double)&gt; func)\r\n * @brief Calculate integral or assert if integral is not a number (Nan)\r\n * @param N number of intervals\r\n * @param h step\r\n * @param a x0\r\n * @param func: choose the function that will be evaluated\r\n * @returns the result of the integration\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">evaluate_by_simpson</span><span class=\"hljs-params\">(std::<span class=\"hljs-type\">int32_t</span> N, <span class=\"hljs-type\">double</span> h, <span class=\"hljs-type\">double</span> a,\r\n                           <span class=\"hljs-type\">const</span> std::function&lt;<span class=\"hljs-type\">double</span>(<span class=\"hljs-type\">double</span>)&gt;&amp; func)</span> </span>{\r\n    std::map&lt;std::<span class=\"hljs-type\">int32_t</span>, <span class=\"hljs-type\">double</span>&gt;\r\n        data_table;  <span class=\"hljs-comment\">// Contains the data points. key: i, value: f(xi)</span>\r\n    <span class=\"hljs-type\">double</span> xi = a;   <span class=\"hljs-comment\">// Initialize xi to the starting point x0 = a</span>\r\n\r\n    <span class=\"hljs-comment\">// Create the data table</span>\r\n    <span class=\"hljs-type\">double</span> temp = NAN;\r\n    <span class=\"hljs-keyword\">for</span> (std::<span class=\"hljs-type\">int32_t</span> i = <span class=\"hljs-number\">0</span>; i &lt;= N; i++) {\r\n        temp = <span class=\"hljs-built_in\">func</span>(xi);\r\n        data_table.<span class=\"hljs-built_in\">insert</span>(\r\n            std::<span class=\"hljs-built_in\">pair</span>&lt;std::<span class=\"hljs-type\">int32_t</span>, <span class=\"hljs-type\">double</span>&gt;(i, temp));  <span class=\"hljs-comment\">// add i and f(xi)</span>\r\n        xi += h;  <span class=\"hljs-comment\">// Get the next point xi for the next iteration</span>\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// Evaluate the integral.</span>\r\n    <span class=\"hljs-comment\">// Remember: f(x0) + 4*f(x1) + 2*f(x2) + ... + 2*f(xN-2) + 4*f(xN-1) + f(xN)</span>\r\n    <span class=\"hljs-type\">double</span> evaluate_integral = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-keyword\">for</span> (std::<span class=\"hljs-type\">int32_t</span> i = <span class=\"hljs-number\">0</span>; i &lt;= N; i++) {\r\n        <span class=\"hljs-keyword\">if</span> (i == <span class=\"hljs-number\">0</span> || i == N) {\r\n            evaluate_integral += data_table.<span class=\"hljs-built_in\">at</span>(i);\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (i % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span>) {\r\n            evaluate_integral += <span class=\"hljs-number\">4</span> * data_table.<span class=\"hljs-built_in\">at</span>(i);\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            evaluate_integral += <span class=\"hljs-number\">2</span> * data_table.<span class=\"hljs-built_in\">at</span>(i);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// Multiply by the coefficient h/3</span>\r\n    evaluate_integral *= h / <span class=\"hljs-number\">3</span>;\r\n\r\n    <span class=\"hljs-comment\">// If the result calculated is nan, then the user has given wrong input</span>\r\n    <span class=\"hljs-comment\">// interval.</span>\r\n    <span class=\"hljs-built_in\">assert</span>(!std::<span class=\"hljs-built_in\">isnan</span>(evaluate_integral) &amp;&amp;\r\n           <span class=\"hljs-string\">&quot;The definite integral can&#x27;t be evaluated. Check the validity of &quot;</span>\r\n           <span class=\"hljs-string\">&quot;your input.\\n&quot;</span>);\r\n    <span class=\"hljs-comment\">// Else return</span>\r\n    <span class=\"hljs-keyword\">return</span> evaluate_integral;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @fn double f(double x)\r\n * @brief A function f(x) that will be used to test the method\r\n * @param x The independent variable xi\r\n * @returns the value of the dependent variable yi = f(xi)\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> x)</span> </span>{ <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">sqrt</span>(x) + std::<span class=\"hljs-built_in\">log</span>(x); }\r\n<span class=\"hljs-comment\">/** @brief Another test function */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> x)</span> </span>{ <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">exp</span>(-x) * (<span class=\"hljs-number\">4</span> - std::<span class=\"hljs-built_in\">pow</span>(x, <span class=\"hljs-number\">2</span>)); }\r\n<span class=\"hljs-comment\">/** @brief Another test function */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">k</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> x)</span> </span>{ <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">sqrt</span>(<span class=\"hljs-number\">2</span> * std::<span class=\"hljs-built_in\">pow</span>(x, <span class=\"hljs-number\">3</span>) + <span class=\"hljs-number\">3</span>); }\r\n<span class=\"hljs-comment\">/** @brief Another test function*/</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">l</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> x)</span> </span>{ <span class=\"hljs-keyword\">return</span> x + std::<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-number\">2</span> * x + <span class=\"hljs-number\">1</span>); }\r\n}  <span class=\"hljs-comment\">// namespace simpson_method</span>\r\n}  <span class=\"hljs-comment\">// namespace numerical_methods</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * \\brief Self-test implementations\r\n * @param N is the number of intervals\r\n * @param h is the step\r\n * @param a is x0\r\n * @param b is the end of the interval\r\n * @param used_argv_parameters is &#x27;true&#x27; if argv parameters are given and\r\n * &#x27;false&#x27; if not\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(std::<span class=\"hljs-type\">int32_t</span> N, <span class=\"hljs-type\">double</span> h, <span class=\"hljs-type\">double</span> a, <span class=\"hljs-type\">double</span> b,\r\n                 <span class=\"hljs-type\">bool</span> used_argv_parameters)</span> </span>{\r\n    <span class=\"hljs-comment\">// Call the functions and find the integral of each function</span>\r\n    <span class=\"hljs-type\">double</span> result_f = numerical_methods::simpson_method::<span class=\"hljs-built_in\">evaluate_by_simpson</span>(\r\n        N, h, a, numerical_methods::simpson_method::f);\r\n    <span class=\"hljs-built_in\">assert</span>((used_argv_parameters || (result_f &gt;= <span class=\"hljs-number\">4.09</span> &amp;&amp; result_f &lt;= <span class=\"hljs-number\">4.10</span>)) &amp;&amp;\r\n           <span class=\"hljs-string\">&quot;The result of f(x) is wrong&quot;</span>);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;The result of integral f(x) on interval [&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span> &lt;&lt; b\r\n              &lt;&lt; <span class=\"hljs-string\">&quot;] is equal to: &quot;</span> &lt;&lt; result_f &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-type\">double</span> result_g = numerical_methods::simpson_method::<span class=\"hljs-built_in\">evaluate_by_simpson</span>(\r\n        N, h, a, numerical_methods::simpson_method::g);\r\n    <span class=\"hljs-built_in\">assert</span>((used_argv_parameters || (result_g &gt;= <span class=\"hljs-number\">0.27</span> &amp;&amp; result_g &lt;= <span class=\"hljs-number\">0.28</span>)) &amp;&amp;\r\n           <span class=\"hljs-string\">&quot;The result of g(x) is wrong&quot;</span>);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;The result of integral g(x) on interval [&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span> &lt;&lt; b\r\n              &lt;&lt; <span class=\"hljs-string\">&quot;] is equal to: &quot;</span> &lt;&lt; result_g &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-type\">double</span> result_k = numerical_methods::simpson_method::<span class=\"hljs-built_in\">evaluate_by_simpson</span>(\r\n        N, h, a, numerical_methods::simpson_method::k);\r\n    <span class=\"hljs-built_in\">assert</span>((used_argv_parameters || (result_k &gt;= <span class=\"hljs-number\">9.06</span> &amp;&amp; result_k &lt;= <span class=\"hljs-number\">9.07</span>)) &amp;&amp;\r\n           <span class=\"hljs-string\">&quot;The result of k(x) is wrong&quot;</span>);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;The result of integral k(x) on interval [&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span> &lt;&lt; b\r\n              &lt;&lt; <span class=\"hljs-string\">&quot;] is equal to: &quot;</span> &lt;&lt; result_k &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-type\">double</span> result_l = numerical_methods::simpson_method::<span class=\"hljs-built_in\">evaluate_by_simpson</span>(\r\n        N, h, a, numerical_methods::simpson_method::l);\r\n    <span class=\"hljs-built_in\">assert</span>((used_argv_parameters || (result_l &gt;= <span class=\"hljs-number\">7.16</span> &amp;&amp; result_l &lt;= <span class=\"hljs-number\">7.17</span>)) &amp;&amp;\r\n           <span class=\"hljs-string\">&quot;The result of l(x) is wrong&quot;</span>);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;The result of integral l(x) on interval [&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span> &lt;&lt; b\r\n              &lt;&lt; <span class=\"hljs-string\">&quot;] is equal to: &quot;</span> &lt;&lt; result_l &lt;&lt; std::endl;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @param argc commandline argument count (ignored)\r\n * @param argv commandline array of arguments (ignored)\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>** argv)</span> </span>{\r\n    std::<span class=\"hljs-type\">int32_t</span> N = <span class=\"hljs-number\">16</span>;  <span class=\"hljs-comment\">/// Number of intervals to divide the integration</span>\r\n                          <span class=\"hljs-comment\">/// interval. MUST BE EVEN</span>\r\n    <span class=\"hljs-type\">double</span> a = <span class=\"hljs-number\">1</span>, b = <span class=\"hljs-number\">3</span>;  <span class=\"hljs-comment\">/// Starting and ending point of the integration in</span>\r\n                          <span class=\"hljs-comment\">/// the real axis</span>\r\n    <span class=\"hljs-type\">double</span> h = NAN;       <span class=\"hljs-comment\">/// Step, calculated by a, b and N</span>\r\n\r\n    <span class=\"hljs-type\">bool</span> used_argv_parameters =\r\n        <span class=\"hljs-literal\">false</span>;  <span class=\"hljs-comment\">// If argv parameters are used then the assert must be omitted</span>\r\n                <span class=\"hljs-comment\">// for the tst cases</span>\r\n\r\n    <span class=\"hljs-comment\">// Get user input (by the command line parameters or the console after</span>\r\n    <span class=\"hljs-comment\">// displaying messages)</span>\r\n    <span class=\"hljs-keyword\">if</span> (argc == <span class=\"hljs-number\">4</span>) {\r\n        N = std::<span class=\"hljs-built_in\">atoi</span>(argv[<span class=\"hljs-number\">1</span>]);\r\n        a = std::<span class=\"hljs-built_in\">atof</span>(argv[<span class=\"hljs-number\">2</span>]);\r\n        b = std::<span class=\"hljs-built_in\">atof</span>(argv[<span class=\"hljs-number\">3</span>]);\r\n        <span class=\"hljs-comment\">// Check if a&lt;b else abort</span>\r\n        <span class=\"hljs-built_in\">assert</span>(a &lt; b &amp;&amp; <span class=\"hljs-string\">&quot;a has to be less than b&quot;</span>);\r\n        <span class=\"hljs-built_in\">assert</span>(N &gt; <span class=\"hljs-number\">0</span> &amp;&amp; <span class=\"hljs-string\">&quot;N has to be &gt; 0&quot;</span>);\r\n        <span class=\"hljs-keyword\">if</span> (N &lt; <span class=\"hljs-number\">16</span> || a != <span class=\"hljs-number\">1</span> || b != <span class=\"hljs-number\">3</span>) {\r\n            used_argv_parameters = <span class=\"hljs-literal\">true</span>;\r\n        }\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;You selected N=&quot;</span> &lt;&lt; N &lt;&lt; <span class=\"hljs-string\">&quot;, a=&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot;, b=&quot;</span> &lt;&lt; b\r\n                  &lt;&lt; std::endl;\r\n    } <span class=\"hljs-keyword\">else</span> {\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Default N=&quot;</span> &lt;&lt; N &lt;&lt; <span class=\"hljs-string\">&quot;, a=&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot;, b=&quot;</span> &lt;&lt; b\r\n                  &lt;&lt; std::endl;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// Find the step</span>\r\n    h = (b - a) / N;\r\n\r\n    <span class=\"hljs-built_in\">test</span>(N, h, a, b, used_argv_parameters);  <span class=\"hljs-comment\">// run self-test implementations</span>\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "ggkogkou",
      "email": "76820848+ggkogkou@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "2kindsofcs",
      "email": "42531877+2kindsofcs@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}