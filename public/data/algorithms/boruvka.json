{
  "slug": "boruvka",
  "name": "Boruvka",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "graphs\\boruvka.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/graphs\\boruvka.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;Borůvka&#x27;s algorithm.\r\n\r\n    Determines the minimum spanning tree (MST) of a graph using the Borůvka&#x27;s algorithm.\r\n    Borůvka&#x27;s algorithm is a greedy algorithm for finding a minimum spanning tree in a\r\n    connected graph, or a minimum spanning forest if a graph that is not connected.\r\n\r\n    The time complexity of this algorithm is O(ELogV), where E represents the number\r\n    of edges, while V represents the number of nodes.\r\n    O(number_of_edges Log number_of_nodes)\r\n\r\n    The space complexity of this algorithm is O(V + E), since we have to keep a couple\r\n    of lists whose sizes are equal to the number of nodes, as well as keep all the\r\n    edges of a graph inside of the data structure itself.\r\n\r\n    Borůvka&#x27;s algorithm gives us pretty much the same result as other MST Algorithms -\r\n    they all find the minimum spanning tree, and the time complexity is approximately\r\n    the same.\r\n\r\n    One advantage that Borůvka&#x27;s algorithm has compared to the alternatives is that it\r\n    doesn&#x27;t need to presort the edges or maintain a priority queue in order to find the\r\n    minimum spanning tree.\r\n    Even though that doesn&#x27;t help its complexity, since it still passes the edges logE\r\n    times, it is a bit simpler to code.\r\n\r\n    Details: https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm\r\n&quot;&quot;&quot;</span>\r\n<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\r\n\r\n<span class=\"hljs-keyword\">from</span> typing <span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">Any</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span>:\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, num_of_nodes: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Arguments:\r\n            num_of_nodes - the number of nodes in the graph\r\n        Attributes:\r\n            m_num_of_nodes - the number of nodes in the graph.\r\n            m_edges - the list of edges.\r\n            m_component - the dictionary which stores the index of the component which\r\n            a node belongs to.\r\n        &quot;&quot;&quot;</span>\r\n\r\n        self.m_num_of_nodes = num_of_nodes\r\n        self.m_edges: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]] = []\r\n        self.m_component: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>] = {}\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_edge</span>(<span class=\"hljs-params\">self, u_node: <span class=\"hljs-built_in\">int</span>, v_node: <span class=\"hljs-built_in\">int</span>, weight: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;Adds an edge in the format [first, second, edge weight] to graph.&quot;&quot;&quot;</span>\r\n\r\n        self.m_edges.append([u_node, v_node, weight])\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">find_component</span>(<span class=\"hljs-params\">self, u_node: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;Propagates a new component throughout a given component.&quot;&quot;&quot;</span>\r\n\r\n        <span class=\"hljs-keyword\">if</span> self.m_component[u_node] == u_node:\r\n            <span class=\"hljs-keyword\">return</span> u_node\r\n        <span class=\"hljs-keyword\">return</span> self.find_component(self.m_component[u_node])\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">set_component</span>(<span class=\"hljs-params\">self, u_node: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;Finds the component index of a given node&quot;&quot;&quot;</span>\r\n\r\n        <span class=\"hljs-keyword\">if</span> self.m_component[u_node] != u_node:\r\n            <span class=\"hljs-keyword\">for</span> k <span class=\"hljs-keyword\">in</span> self.m_component:\r\n                self.m_component[k] = self.find_component(k)\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">union</span>(<span class=\"hljs-params\">self, component_size: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>], u_node: <span class=\"hljs-built_in\">int</span>, v_node: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;Union finds the roots of components for two nodes, compares the components\r\n        in terms of size, and attaches the smaller one to the larger one to form\r\n        single component&quot;&quot;&quot;</span>\r\n\r\n        <span class=\"hljs-keyword\">if</span> component_size[u_node] &lt;= component_size[v_node]:\r\n            self.m_component[u_node] = v_node\r\n            component_size[v_node] += component_size[u_node]\r\n            self.set_component(u_node)\r\n\r\n        <span class=\"hljs-keyword\">elif</span> component_size[u_node] &gt;= component_size[v_node]:\r\n            self.m_component[v_node] = self.find_component(u_node)\r\n            component_size[u_node] += component_size[v_node]\r\n            self.set_component(v_node)\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">boruvka</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;Performs Borůvka&#x27;s algorithm to find MST.&quot;&quot;&quot;</span>\r\n\r\n        <span class=\"hljs-comment\"># Initialize additional lists required to algorithm.</span>\r\n        component_size = []\r\n        mst_weight = <span class=\"hljs-number\">0</span>\r\n\r\n        minimum_weight_edge: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-type\">Any</span>] = [-<span class=\"hljs-number\">1</span>] * self.m_num_of_nodes\r\n\r\n        <span class=\"hljs-comment\"># A list of components (initialized to all of the nodes)</span>\r\n        <span class=\"hljs-keyword\">for</span> node <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(self.m_num_of_nodes):\r\n            self.m_component.update({node: node})\r\n            component_size.append(<span class=\"hljs-number\">1</span>)\r\n\r\n        num_of_components = self.m_num_of_nodes\r\n\r\n        <span class=\"hljs-keyword\">while</span> num_of_components &gt; <span class=\"hljs-number\">1</span>:\r\n            <span class=\"hljs-keyword\">for</span> edge <span class=\"hljs-keyword\">in</span> self.m_edges:\r\n                u, v, w = edge\r\n\r\n                u_component = self.m_component[u]\r\n                v_component = self.m_component[v]\r\n\r\n                <span class=\"hljs-keyword\">if</span> u_component != v_component:\r\n                    <span class=\"hljs-string\">&quot;&quot;&quot;If the current minimum weight edge of component u doesn&#x27;t\r\n                    exist (is -1), or if it&#x27;s greater than the edge we&#x27;re\r\n                    observing right now, we will assign the value of the edge\r\n                    we&#x27;re observing to it.\r\n\r\n                    If the current minimum weight edge of component v doesn&#x27;t\r\n                    exist (is -1), or if it&#x27;s greater than the edge we&#x27;re\r\n                    observing right now, we will assign the value of the edge\r\n                    we&#x27;re observing to it&quot;&quot;&quot;</span>\r\n\r\n                    <span class=\"hljs-keyword\">for</span> component <span class=\"hljs-keyword\">in</span> (u_component, v_component):\r\n                        <span class=\"hljs-keyword\">if</span> (\r\n                            minimum_weight_edge[component] == -<span class=\"hljs-number\">1</span>\r\n                            <span class=\"hljs-keyword\">or</span> minimum_weight_edge[component][<span class=\"hljs-number\">2</span>] &gt; w\r\n                        ):\r\n                            minimum_weight_edge[component] = [u, v, w]\r\n\r\n            <span class=\"hljs-keyword\">for</span> edge <span class=\"hljs-keyword\">in</span> minimum_weight_edge:\r\n                <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">isinstance</span>(edge, <span class=\"hljs-built_in\">list</span>):\r\n                    u, v, w = edge\r\n\r\n                    u_component = self.m_component[u]\r\n                    v_component = self.m_component[v]\r\n\r\n                    <span class=\"hljs-keyword\">if</span> u_component != v_component:\r\n                        mst_weight += w\r\n                        self.union(component_size, u_component, v_component)\r\n                        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;Added edge [<span class=\"hljs-subst\">{u}</span> - <span class=\"hljs-subst\">{v}</span>]\\nAdded weight: <span class=\"hljs-subst\">{w}</span>\\n&quot;</span>)\r\n                        num_of_components -= <span class=\"hljs-number\">1</span>\r\n\r\n            minimum_weight_edge = [-<span class=\"hljs-number\">1</span>] * self.m_num_of_nodes\r\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;The total weight of the minimal spanning tree is: <span class=\"hljs-subst\">{mst_weight}</span>&quot;</span>)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">test_vector</span>() -&gt; <span class=\"hljs-literal\">None</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    &gt;&gt;&gt; g = Graph(8)\r\n    &gt;&gt;&gt; for u_v_w in ((0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4),\r\n    ...    (3, 4, 8), (4, 5, 10), (4, 6, 6), (4, 7, 5), (5, 7, 15), (6, 7, 4)):\r\n    ...        g.add_edge(*u_v_w)\r\n    &gt;&gt;&gt; g.boruvka()\r\n    Added edge [0 - 3]\r\n    Added weight: 5\r\n    &lt;BLANKLINE&gt;\r\n    Added edge [0 - 1]\r\n    Added weight: 10\r\n    &lt;BLANKLINE&gt;\r\n    Added edge [2 - 3]\r\n    Added weight: 4\r\n    &lt;BLANKLINE&gt;\r\n    Added edge [4 - 7]\r\n    Added weight: 5\r\n    &lt;BLANKLINE&gt;\r\n    Added edge [4 - 5]\r\n    Added weight: 10\r\n    &lt;BLANKLINE&gt;\r\n    Added edge [6 - 7]\r\n    Added weight: 4\r\n    &lt;BLANKLINE&gt;\r\n    Added edge [3 - 4]\r\n    Added weight: 8\r\n    &lt;BLANKLINE&gt;\r\n    The total weight of the minimal spanning tree is: 46\r\n    &quot;&quot;&quot;</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    <span class=\"hljs-keyword\">import</span> doctest\r\n\r\n    doctest.testmod()\r\n"
    }
  },
  "contributors": [
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 1
    },
    {
      "name": "Dylan Buchi",
      "email": "devybuchi@gmail.com",
      "commits": 1
    },
    {
      "name": "Meysam",
      "email": "MeysamAzad81@gmail.com",
      "commits": 1
    },
    {
      "name": "Shiva Rama Krishna",
      "email": "45482631+srkchowdary2000@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}