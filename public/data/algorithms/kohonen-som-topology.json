{
  "slug": "kohonen-som-topology",
  "name": "Kohonen Som Topology",
  "categories": [
    "machinelearning"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "machine_learning\\kohonen_som_topology.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/machine_learning\\kohonen_som_topology.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * \\addtogroup machine_learning Machine Learning Algorithms\r\n * @{\r\n * \\file\r\n * \\author [Krishna Vedala](https://github.com/kvedala)\r\n *\r\n * \\brief [Kohonen self organizing\r\n * map](https://en.wikipedia.org/wiki/Self-organizing_map) (topological map)\r\n *\r\n * \\details\r\n * This example implements a powerful unsupervised learning algorithm called as\r\n * a self organizing map. The algorithm creates a connected network of weights\r\n * that closely follows the given data points. This thus creates a topological\r\n * map of the given data i.e., it maintains the relationship between varipus\r\n * data points in a much higher dimesional space by creating an equivalent in a\r\n * 2-dimensional space.\r\n * &lt;img alt=&quot;Trained topological maps for the test cases in the program&quot;\r\n * src=&quot;https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/machine_learning/2D_Kohonen_SOM.svg&quot;\r\n * /&gt;\r\n * \\note This C++ version of the program is considerable slower than its [C\r\n * counterpart](https://github.com/kvedala/C/blob/master/machine_learning/kohonen_som_trace.c)\r\n * \\note The compiled code is much slower when compiled with MS Visual C++ 2019\r\n * than with GCC on windows\r\n * \\see kohonen_som_trace.cpp\r\n */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> _USE_MATH_DEFINES  <span class=\"hljs-comment\">//&lt; required for MS Visual C++</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;array&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cerrno&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ctime&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;fstream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;valarray&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP  <span class=\"hljs-comment\">// check if OpenMP based parallellization is available</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;omp.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Helper function to generate a random number in a given interval.\r\n * \\n Steps:\r\n * 1. `r1 = rand() % 100` gets a random number between 0 and 99\r\n * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99\r\n * 3. scale and offset the random number to given range of \\f$[a,b]\\f$\r\n *\r\n * \\param[in] a lower limit\r\n * \\param[in] b upper limit\r\n * \\returns random number in the range \\f$[a,b]\\f$\r\n */</span>\r\n<span class=\"hljs-type\">double</span> _random(<span class=\"hljs-type\">double</span> a, <span class=\"hljs-type\">double</span> b) {\r\n    <span class=\"hljs-keyword\">return</span> ((b - a) * (std::<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span>) / <span class=\"hljs-number\">100.f</span>) + a;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Save a given n-dimensional data martix to file.\r\n *\r\n * \\param[in] fname filename to save in (gets overwriten without confirmation)\r\n * \\param[in] X matrix to save\r\n * \\returns 0 if all ok\r\n * \\returns -1 if file creation failed\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">save_2d_data</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fname,\r\n                 <span class=\"hljs-type\">const</span> std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; &amp;X)</span> </span>{\r\n    <span class=\"hljs-type\">size_t</span> num_points = X.<span class=\"hljs-built_in\">size</span>();       <span class=\"hljs-comment\">// number of rows</span>\r\n    <span class=\"hljs-type\">size_t</span> num_features = X[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>();  <span class=\"hljs-comment\">// number of columns</span>\r\n\r\n    std::ofstream fp;\r\n    fp.<span class=\"hljs-built_in\">open</span>(fname);\r\n    <span class=\"hljs-keyword\">if</span> (!fp.<span class=\"hljs-built_in\">is_open</span>()) {\r\n        <span class=\"hljs-comment\">// error with opening file to write</span>\r\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Error opening file &quot;</span> &lt;&lt; fname &lt;&lt; <span class=\"hljs-string\">&quot;: &quot;</span>\r\n                  &lt;&lt; std::<span class=\"hljs-built_in\">strerror</span>(errno) &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// for each point in the array</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; num_points; i++) {\r\n        <span class=\"hljs-comment\">// for each feature in the array</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; num_features; j++) {\r\n            fp &lt;&lt; X[i][j];               <span class=\"hljs-comment\">// print the feature value</span>\r\n            <span class=\"hljs-keyword\">if</span> (j &lt; num_features - <span class=\"hljs-number\">1</span>) {  <span class=\"hljs-comment\">// if not the last feature</span>\r\n                fp &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span>;               <span class=\"hljs-comment\">// suffix comma</span>\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_points - <span class=\"hljs-number\">1</span>) {  <span class=\"hljs-comment\">// if not the last row</span>\r\n            fp &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;            <span class=\"hljs-comment\">// start a new line</span>\r\n        }\r\n    }\r\n\r\n    fp.<span class=\"hljs-built_in\">close</span>();\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Get minimum value and index of the value in a matrix\r\n * \\param[in] X matrix to search\r\n * \\param[in] N number of points in the vector\r\n * \\param[out] val minimum value found\r\n * \\param[out] idx_x x-index where minimum value was found\r\n * \\param[out] idx_y y-index where minimum value was found\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">get_min_2d</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; &amp;X, <span class=\"hljs-type\">double</span> *val,\r\n                <span class=\"hljs-type\">int</span> *x_idx, <span class=\"hljs-type\">int</span> *y_idx)</span> </span>{\r\n    val[<span class=\"hljs-number\">0</span>] = INFINITY;  <span class=\"hljs-comment\">// initial min value</span>\r\n    <span class=\"hljs-type\">size_t</span> N = X.<span class=\"hljs-built_in\">size</span>();\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {  <span class=\"hljs-comment\">// traverse each x-index</span>\r\n        <span class=\"hljs-keyword\">auto</span> result = std::<span class=\"hljs-built_in\">min_element</span>(std::<span class=\"hljs-built_in\">begin</span>(X[i]), std::<span class=\"hljs-built_in\">end</span>(X[i]));\r\n        <span class=\"hljs-type\">double</span> d_min = *result;\r\n        std::<span class=\"hljs-type\">ptrdiff_t</span> j = std::<span class=\"hljs-built_in\">distance</span>(std::<span class=\"hljs-built_in\">begin</span>(X[i]), result);\r\n\r\n        <span class=\"hljs-keyword\">if</span> (d_min &lt; val[<span class=\"hljs-number\">0</span>]) {  <span class=\"hljs-comment\">// if a lower value is found</span>\r\n                               <span class=\"hljs-comment\">// save the value and its index</span>\r\n            x_idx[<span class=\"hljs-number\">0</span>] = i;\r\n            y_idx[<span class=\"hljs-number\">0</span>] = j;\r\n            val[<span class=\"hljs-number\">0</span>] = d_min;\r\n        }\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/** \\namespace machine_learning\r\n * \\brief Machine learning algorithms\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> machine_learning {\r\n<span class=\"hljs-comment\">/** Minimum average distance of image nodes */</span>\r\n<span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">double</span> MIN_DISTANCE = <span class=\"hljs-number\">1e-4</span>;\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Create the distance matrix or\r\n * [U-matrix](https://en.wikipedia.org/wiki/U-matrix) from the trained\r\n * 3D weiths matrix and save to disk.\r\n *\r\n * \\param [in] fname filename to save in (gets overwriten without\r\n * confirmation)\r\n * \\param [in] W model matrix to save\r\n * \\returns 0 if all ok\r\n * \\returns -1 if file creation failed\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">save_u_matrix</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fname,\r\n                  <span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;&gt; &amp;W)</span> </span>{\r\n    <span class=\"hljs-function\">std::ofstream <span class=\"hljs-title\">fp</span><span class=\"hljs-params\">(fname)</span></span>;\r\n    <span class=\"hljs-keyword\">if</span> (!fp) {  <span class=\"hljs-comment\">// error with fopen</span>\r\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;File error (&quot;</span> &lt;&lt; fname &lt;&lt; <span class=\"hljs-string\">&quot;): &quot;</span> &lt;&lt; std::<span class=\"hljs-built_in\">strerror</span>(errno)\r\n                  &lt;&lt; std::endl;\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// neighborhood range</span>\r\n    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> R = <span class=\"hljs-number\">1</span>;\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; W.<span class=\"hljs-built_in\">size</span>(); i++) {         <span class=\"hljs-comment\">// for each x</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; W[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>(); j++) {  <span class=\"hljs-comment\">// for each y</span>\r\n            <span class=\"hljs-type\">double</span> distance = <span class=\"hljs-number\">0.f</span>;\r\n\r\n            <span class=\"hljs-type\">int</span> from_x = std::<span class=\"hljs-built_in\">max</span>&lt;<span class=\"hljs-type\">int</span>&gt;(<span class=\"hljs-number\">0</span>, i - R);\r\n            <span class=\"hljs-type\">int</span> to_x = std::<span class=\"hljs-built_in\">min</span>&lt;<span class=\"hljs-type\">int</span>&gt;(W.<span class=\"hljs-built_in\">size</span>(), i + R + <span class=\"hljs-number\">1</span>);\r\n            <span class=\"hljs-type\">int</span> from_y = std::<span class=\"hljs-built_in\">max</span>&lt;<span class=\"hljs-type\">int</span>&gt;(<span class=\"hljs-number\">0</span>, j - R);\r\n            <span class=\"hljs-type\">int</span> to_y = std::<span class=\"hljs-built_in\">min</span>&lt;<span class=\"hljs-type\">int</span>&gt;(W[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>(), j + R + <span class=\"hljs-number\">1</span>);\r\n            <span class=\"hljs-type\">int</span> l = <span class=\"hljs-number\">0</span>, m = <span class=\"hljs-number\">0</span>;\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp parallel for reduction(+ : distance)</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n            <span class=\"hljs-keyword\">for</span> (l = from_x; l &lt; to_x; l++) {      <span class=\"hljs-comment\">// scan neighborhoor in x</span>\r\n                <span class=\"hljs-keyword\">for</span> (m = from_y; m &lt; to_y; m++) {  <span class=\"hljs-comment\">// scan neighborhood in y</span>\r\n                    <span class=\"hljs-keyword\">auto</span> d = W[i][j] - W[l][m];\r\n                    <span class=\"hljs-type\">double</span> d2 = std::<span class=\"hljs-built_in\">pow</span>(d, <span class=\"hljs-number\">2</span>).<span class=\"hljs-built_in\">sum</span>();\r\n                    distance += std::<span class=\"hljs-built_in\">sqrt</span>(d2);\r\n                    <span class=\"hljs-comment\">// distance += d2;</span>\r\n                }\r\n            }\r\n\r\n            distance /= R * R;          <span class=\"hljs-comment\">// mean distance from neighbors</span>\r\n            fp &lt;&lt; distance;             <span class=\"hljs-comment\">// print the mean separation</span>\r\n            <span class=\"hljs-keyword\">if</span> (j &lt; W[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>) {  <span class=\"hljs-comment\">// if not the last column</span>\r\n                fp &lt;&lt; <span class=\"hljs-string\">&#x27;,&#x27;</span>;              <span class=\"hljs-comment\">// suffix comma</span>\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; W.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>) {  <span class=\"hljs-comment\">// if not the last row</span>\r\n            fp &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;          <span class=\"hljs-comment\">// start a new line</span>\r\n        }\r\n    }\r\n\r\n    fp.<span class=\"hljs-built_in\">close</span>();\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Update weights of the SOM using Kohonen algorithm\r\n *\r\n * \\param[in] X data point - N features\r\n * \\param[in,out] W weights matrix - PxQxN\r\n * \\param[in,out] D temporary vector to store distances PxQ\r\n * \\param[in] alpha learning rate \\f$0&lt;\\alpha\\le1\\f$\r\n * \\param[in] R neighborhood range\r\n * \\returns minimum distance of sample and trained weights\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">update_weights</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; &amp;X,\r\n                      std::vector&lt;std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;&gt; *W,\r\n                      std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *D, <span class=\"hljs-type\">double</span> alpha,\r\n                      <span class=\"hljs-type\">int</span> R)</span> </span>{\r\n    <span class=\"hljs-type\">int</span> x = <span class=\"hljs-number\">0</span>, y = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">int</span> num_out_x = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(W-&gt;<span class=\"hljs-built_in\">size</span>());       <span class=\"hljs-comment\">// output nodes - in X</span>\r\n    <span class=\"hljs-type\">int</span> num_out_y = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(W[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>());  <span class=\"hljs-comment\">// output nodes - in Y</span>\r\n    <span class=\"hljs-comment\">// int num_features = static_cast&lt;int&gt;(W[0][0][0].size());  //  features =</span>\r\n    <span class=\"hljs-comment\">// in Z</span>\r\n    <span class=\"hljs-type\">double</span> d_min = <span class=\"hljs-number\">0.f</span>;\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-comment\">// step 1: for each output point</span>\r\n    <span class=\"hljs-keyword\">for</span> (x = <span class=\"hljs-number\">0</span>; x &lt; num_out_x; x++) {\r\n        <span class=\"hljs-keyword\">for</span> (y = <span class=\"hljs-number\">0</span>; y &lt; num_out_y; y++) {\r\n            (*D)[x][y] = <span class=\"hljs-number\">0.f</span>;\r\n            <span class=\"hljs-comment\">// compute Euclidian distance of each output</span>\r\n            <span class=\"hljs-comment\">// point from the current sample</span>\r\n            <span class=\"hljs-keyword\">auto</span> d = ((*W)[x][y] - X);\r\n            (*D)[x][y] = (d * d).<span class=\"hljs-built_in\">sum</span>();\r\n            (*D)[x][y] = std::<span class=\"hljs-built_in\">sqrt</span>((*D)[x][y]);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// step 2:  get closest node i.e., node with snallest Euclidian distance</span>\r\n    <span class=\"hljs-comment\">// to the current pattern</span>\r\n    <span class=\"hljs-type\">int</span> d_min_x = <span class=\"hljs-number\">0</span>, d_min_y = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-built_in\">get_min_2d</span>(*D, &amp;d_min, &amp;d_min_x, &amp;d_min_y);\r\n\r\n    <span class=\"hljs-comment\">// step 3a: get the neighborhood range</span>\r\n    <span class=\"hljs-type\">int</span> from_x = std::<span class=\"hljs-built_in\">max</span>(<span class=\"hljs-number\">0</span>, d_min_x - R);\r\n    <span class=\"hljs-type\">int</span> to_x = std::<span class=\"hljs-built_in\">min</span>(num_out_x, d_min_x + R + <span class=\"hljs-number\">1</span>);\r\n    <span class=\"hljs-type\">int</span> from_y = std::<span class=\"hljs-built_in\">max</span>(<span class=\"hljs-number\">0</span>, d_min_y - R);\r\n    <span class=\"hljs-type\">int</span> to_y = std::<span class=\"hljs-built_in\">min</span>(num_out_y, d_min_y + R + <span class=\"hljs-number\">1</span>);\r\n\r\n    <span class=\"hljs-comment\">// step 3b: update the weights of nodes in the</span>\r\n    <span class=\"hljs-comment\">// neighborhood</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-keyword\">for</span> (x = from_x; x &lt; to_x; x++) {\r\n        <span class=\"hljs-keyword\">for</span> (y = from_y; y &lt; to_y; y++) {\r\n            <span class=\"hljs-comment\">/* you can enable the following normalization if needed.\r\n   personally, I found it detrimental to convergence */</span>\r\n            <span class=\"hljs-comment\">// const double s2pi = sqrt(2.f * M_PI);</span>\r\n            <span class=\"hljs-comment\">// double normalize = 1.f / (alpha * s2pi);</span>\r\n\r\n            <span class=\"hljs-comment\">/* apply scaling inversely proportional to distance from the\r\n               current node */</span>\r\n            <span class=\"hljs-type\">double</span> d2 =\r\n                (d_min_x - x) * (d_min_x - x) + (d_min_y - y) * (d_min_y - y);\r\n            <span class=\"hljs-type\">double</span> scale_factor = std::<span class=\"hljs-built_in\">exp</span>(-d2 / (<span class=\"hljs-number\">2.f</span> * alpha * alpha));\r\n\r\n            (*W)[x][y] += (X - (*W)[x][y]) * alpha * scale_factor;\r\n        }\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> d_min;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Apply incremental algorithm with updating neighborhood and learning\r\n * rates on all samples in the given datset.\r\n *\r\n * \\param[in] X data set\r\n * \\param[in,out] W weights matrix\r\n * \\param[in] alpha_min terminal value of alpha\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">kohonen_som</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; &amp;X,\r\n                 std::vector&lt;std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;&gt; *W,\r\n                 <span class=\"hljs-type\">double</span> alpha_min)</span> </span>{\r\n    <span class=\"hljs-type\">size_t</span> num_samples = X.<span class=\"hljs-built_in\">size</span>();  <span class=\"hljs-comment\">// number of rows</span>\r\n    <span class=\"hljs-comment\">// size_t num_features = X[0].size();  // number of columns</span>\r\n    <span class=\"hljs-type\">size_t</span> num_out = W-&gt;<span class=\"hljs-built_in\">size</span>();  <span class=\"hljs-comment\">// output matrix size</span>\r\n    <span class=\"hljs-type\">size_t</span> R = num_out &gt;&gt; <span class=\"hljs-number\">2</span>, iter = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">double</span> alpha = <span class=\"hljs-number\">1.f</span>;\r\n\r\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">D</span>(num_out);\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; num_out; i++) D[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(num_out);\r\n\r\n    <span class=\"hljs-type\">double</span> dmin = <span class=\"hljs-number\">1.f</span>;        <span class=\"hljs-comment\">// average minimum distance of all samples</span>\r\n    <span class=\"hljs-type\">double</span> past_dmin = <span class=\"hljs-number\">1.f</span>;   <span class=\"hljs-comment\">// average minimum distance of all samples</span>\r\n    <span class=\"hljs-type\">double</span> dmin_ratio = <span class=\"hljs-number\">1.f</span>;  <span class=\"hljs-comment\">// change per step</span>\r\n\r\n    <span class=\"hljs-comment\">// Loop alpha from 1 to slpha_min</span>\r\n    <span class=\"hljs-keyword\">for</span> (; alpha &gt; <span class=\"hljs-number\">0</span> &amp;&amp; dmin_ratio &gt; <span class=\"hljs-number\">1e-5</span>; alpha -= <span class=\"hljs-number\">1e-4</span>, iter++) {\r\n        <span class=\"hljs-comment\">// Loop for each sample pattern in the data set</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> sample = <span class=\"hljs-number\">0</span>; sample &lt; num_samples; sample++) {\r\n            <span class=\"hljs-comment\">// update weights for the current input pattern sample</span>\r\n            dmin += <span class=\"hljs-built_in\">update_weights</span>(X[sample], W, &amp;D, alpha, R);\r\n        }\r\n\r\n        <span class=\"hljs-comment\">// every 100th iteration, reduce the neighborhood range</span>\r\n        <span class=\"hljs-keyword\">if</span> (iter % <span class=\"hljs-number\">300</span> == <span class=\"hljs-number\">0</span> &amp;&amp; R &gt; <span class=\"hljs-number\">1</span>) {\r\n            R--;\r\n        }\r\n\r\n        dmin /= num_samples;\r\n\r\n        <span class=\"hljs-comment\">// termination condition variable -&gt; % change in minimum distance</span>\r\n        dmin_ratio = (past_dmin - dmin) / past_dmin;\r\n        <span class=\"hljs-keyword\">if</span> (dmin_ratio &lt; <span class=\"hljs-number\">0</span>) {\r\n            dmin_ratio = <span class=\"hljs-number\">1.f</span>;\r\n        }\r\n        past_dmin = dmin;\r\n\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;iter: &quot;</span> &lt;&lt; iter &lt;&lt; <span class=\"hljs-string\">&quot;\\t alpha: &quot;</span> &lt;&lt; alpha &lt;&lt; <span class=\"hljs-string\">&quot;\\t R: &quot;</span> &lt;&lt; R\r\n                  &lt;&lt; <span class=\"hljs-string\">&quot;\\t d_min: &quot;</span> &lt;&lt; dmin_ratio &lt;&lt; <span class=\"hljs-string\">&quot;\\r&quot;</span>;\r\n    }\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\r\n}\r\n\r\n}  <span class=\"hljs-comment\">// namespace machine_learning</span>\r\n\r\n<span class=\"hljs-keyword\">using</span> machine_learning::kohonen_som;\r\n<span class=\"hljs-keyword\">using</span> machine_learning::save_u_matrix;\r\n\r\n<span class=\"hljs-comment\">/** @} */</span>\r\n\r\n<span class=\"hljs-comment\">/** Creates a random set of points distributed in four clusters in\r\n * 3D space with centroids at the points\r\n * * \\f$(0,5, 0.5, 0.5)\\f$\r\n * * \\f$(0,5,-0.5, -0.5)\\f$\r\n * * \\f$(-0,5, 0.5, 0.5)\\f$\r\n * * \\f$(-0,5,-0.5, -0.5)\\f$\r\n *\r\n * \\param[out] data matrix to store data in\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_2d_classes</span><span class=\"hljs-params\">(std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *data)</span> </span>{\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N = data-&gt;<span class=\"hljs-built_in\">size</span>();\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.3</span>;  <span class=\"hljs-comment\">// radius of cluster</span>\r\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> num_classes = <span class=\"hljs-number\">4</span>;\r\n    std::array&lt;std::array&lt;<span class=\"hljs-type\">double</span>, 2&gt;, num_classes&gt; centres = {\r\n        <span class=\"hljs-comment\">// centres of each class cluster</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">2</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>}),   <span class=\"hljs-comment\">// centre of class 1</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">2</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>}),  <span class=\"hljs-comment\">// centre of class 2</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">2</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>}),  <span class=\"hljs-comment\">// centre of class 3</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">2</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>})  <span class=\"hljs-comment\">// centre of class 4</span>\r\n    };\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\r\n        <span class=\"hljs-comment\">// select a random class for the point</span>\r\n        <span class=\"hljs-type\">int</span> cls = std::<span class=\"hljs-built_in\">rand</span>() % num_classes;\r\n\r\n        <span class=\"hljs-comment\">// create random coordinates (x,y,z) around the centre of the class</span>\r\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">0</span>] = _random(centres[cls][<span class=\"hljs-number\">0</span>] - R, centres[cls][<span class=\"hljs-number\">0</span>] + R);\r\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">1</span>] = _random(centres[cls][<span class=\"hljs-number\">1</span>] - R, centres[cls][<span class=\"hljs-number\">1</span>] + R);\r\n\r\n        <span class=\"hljs-comment\">/* The follosing can also be used\r\n        for (int j = 0; j &lt; 2; j++)\r\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\r\n        */</span>\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed in four clusters in\r\n * circumference of a circle and trains an SOM that finds that circular pattern.\r\n * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)\r\n * files are created to validate the execution:\r\n * * `test1.csv`: random test samples points with a circular pattern\r\n * * `w11.csv`: initial random map\r\n * * `w12.csv`: trained SOM map\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>, N = <span class=\"hljs-number\">300</span>;\r\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">2</span>;\r\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">30</span>;\r\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">X</span>(N);\r\n    std::vector&lt;std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">W</span>(num_out);\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; std::<span class=\"hljs-built_in\">max</span>(num_out, N); i++) {\r\n        <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; N) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\r\n            X[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\r\n            W[i] = std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;(num_out);\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; num_out; k++) {\r\n                W[i][k] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n                <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) {\r\n                    <span class=\"hljs-comment\">// preallocate with random initial weights</span>\r\n                    W[i][k][j] = _random(<span class=\"hljs-number\">-10</span>, <span class=\"hljs-number\">10</span>);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-built_in\">test_2d_classes</span>(&amp;X);  <span class=\"hljs-comment\">// create test data around circumference of a circle</span>\r\n    <span class=\"hljs-built_in\">save_2d_data</span>(<span class=\"hljs-string\">&quot;test1.csv&quot;</span>, X);  <span class=\"hljs-comment\">// save test data points</span>\r\n    <span class=\"hljs-built_in\">save_u_matrix</span>(<span class=\"hljs-string\">&quot;w11.csv&quot;</span>, W);   <span class=\"hljs-comment\">// save initial random weights</span>\r\n    <span class=\"hljs-built_in\">kohonen_som</span>(X, &amp;W, <span class=\"hljs-number\">1e-4</span>);      <span class=\"hljs-comment\">// train the SOM</span>\r\n    <span class=\"hljs-built_in\">save_u_matrix</span>(<span class=\"hljs-string\">&quot;w12.csv&quot;</span>, W);   <span class=\"hljs-comment\">// save the resultant weights</span>\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Creates a random set of points distributed in four clusters in\r\n * 3D space with centroids at the points\r\n * * \\f$(0,5, 0.5, 0.5)\\f$\r\n * * \\f$(0,5,-0.5, -0.5)\\f$\r\n * * \\f$(-0,5, 0.5, 0.5)\\f$\r\n * * \\f$(-0,5,-0.5, -0.5)\\f$\r\n *\r\n * \\param[out] data matrix to store data in\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_3d_classes1</span><span class=\"hljs-params\">(std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *data)</span> </span>{\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">size_t</span> N = data-&gt;<span class=\"hljs-built_in\">size</span>();\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.3</span>;  <span class=\"hljs-comment\">// radius of cluster</span>\r\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> num_classes = <span class=\"hljs-number\">4</span>;\r\n    <span class=\"hljs-type\">const</span> std::array&lt;std::array&lt;<span class=\"hljs-type\">double</span>, 3&gt;, num_classes&gt; centres = {\r\n        <span class=\"hljs-comment\">// centres of each class cluster</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>}),    <span class=\"hljs-comment\">// centre of class 1</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>}),  <span class=\"hljs-comment\">// centre of class 2</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>}),   <span class=\"hljs-comment\">// centre of class 3</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span> - <span class=\"hljs-number\">.5</span>})  <span class=\"hljs-comment\">// centre of class 4</span>\r\n    };\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\r\n        <span class=\"hljs-comment\">// select a random class for the point</span>\r\n        <span class=\"hljs-type\">int</span> cls = std::<span class=\"hljs-built_in\">rand</span>() % num_classes;\r\n\r\n        <span class=\"hljs-comment\">// create random coordinates (x,y,z) around the centre of the class</span>\r\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">0</span>] = _random(centres[cls][<span class=\"hljs-number\">0</span>] - R, centres[cls][<span class=\"hljs-number\">0</span>] + R);\r\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">1</span>] = _random(centres[cls][<span class=\"hljs-number\">1</span>] - R, centres[cls][<span class=\"hljs-number\">1</span>] + R);\r\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">2</span>] = _random(centres[cls][<span class=\"hljs-number\">2</span>] - R, centres[cls][<span class=\"hljs-number\">2</span>] + R);\r\n\r\n        <span class=\"hljs-comment\">/* The follosing can also be used\r\n        for (int j = 0; j &lt; 3; j++)\r\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\r\n        */</span>\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed in 4 clusters in\r\n * 3D space and trains an SOM that finds the topological pattern. The following\r\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\r\n * to validate the execution:\r\n * * `test2.csv`: random test samples points with a lamniscate pattern\r\n * * `w21.csv`: initial random map\r\n * * `w22.csv`: trained SOM map\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>, N = <span class=\"hljs-number\">300</span>;\r\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">3</span>;\r\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">30</span>;\r\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">X</span>(N);\r\n    std::vector&lt;std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">W</span>(num_out);\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; std::<span class=\"hljs-built_in\">max</span>(num_out, N); i++) {\r\n        <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; N) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\r\n            X[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\r\n            W[i] = std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;(num_out);\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; num_out; k++) {\r\n                W[i][k] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n                <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) {\r\n                    <span class=\"hljs-comment\">// preallocate with random initial weights</span>\r\n                    W[i][k][j] = _random(<span class=\"hljs-number\">-10</span>, <span class=\"hljs-number\">10</span>);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-built_in\">test_3d_classes1</span>(&amp;X);  <span class=\"hljs-comment\">// create test data around circumference of a circle</span>\r\n    <span class=\"hljs-built_in\">save_2d_data</span>(<span class=\"hljs-string\">&quot;test2.csv&quot;</span>, X);  <span class=\"hljs-comment\">// save test data points</span>\r\n    <span class=\"hljs-built_in\">save_u_matrix</span>(<span class=\"hljs-string\">&quot;w21.csv&quot;</span>, W);   <span class=\"hljs-comment\">// save initial random weights</span>\r\n    <span class=\"hljs-built_in\">kohonen_som</span>(X, &amp;W, <span class=\"hljs-number\">1e-4</span>);      <span class=\"hljs-comment\">// train the SOM</span>\r\n    <span class=\"hljs-built_in\">save_u_matrix</span>(<span class=\"hljs-string\">&quot;w22.csv&quot;</span>, W);   <span class=\"hljs-comment\">// save the resultant weights</span>\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Creates a random set of points distributed in four clusters in\r\n * 3D space with centroids at the points\r\n * * \\f$(0,5, 0.5, 0.5)\\f$\r\n * * \\f$(0,5,-0.5, -0.5)\\f$\r\n * * \\f$(-0,5, 0.5, 0.5)\\f$\r\n * * \\f$(-0,5,-0.5, -0.5)\\f$\r\n *\r\n * \\param[out] data matrix to store data in\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_3d_classes2</span><span class=\"hljs-params\">(std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *data)</span> </span>{\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">size_t</span> N = data-&gt;<span class=\"hljs-built_in\">size</span>();\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.2</span>;  <span class=\"hljs-comment\">// radius of cluster</span>\r\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> num_classes = <span class=\"hljs-number\">8</span>;\r\n    <span class=\"hljs-type\">const</span> std::array&lt;std::array&lt;<span class=\"hljs-type\">double</span>, 3&gt;, num_classes&gt; centres = {\r\n        <span class=\"hljs-comment\">// centres of each class cluster</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>}),    <span class=\"hljs-comment\">// centre of class 1</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>}),   <span class=\"hljs-comment\">// centre of class 2</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>}),   <span class=\"hljs-comment\">// centre of class 3</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>}),  <span class=\"hljs-comment\">// centre of class 4</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>}),   <span class=\"hljs-comment\">// centre of class 5</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>}),  <span class=\"hljs-comment\">// centre of class 6</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>}),  <span class=\"hljs-comment\">// centre of class 7</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>})  <span class=\"hljs-comment\">// centre of class 8</span>\r\n    };\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\r\n        <span class=\"hljs-comment\">// select a random class for the point</span>\r\n        <span class=\"hljs-type\">int</span> cls = std::<span class=\"hljs-built_in\">rand</span>() % num_classes;\r\n\r\n        <span class=\"hljs-comment\">// create random coordinates (x,y,z) around the centre of the class</span>\r\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">0</span>] = _random(centres[cls][<span class=\"hljs-number\">0</span>] - R, centres[cls][<span class=\"hljs-number\">0</span>] + R);\r\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">1</span>] = _random(centres[cls][<span class=\"hljs-number\">1</span>] - R, centres[cls][<span class=\"hljs-number\">1</span>] + R);\r\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">2</span>] = _random(centres[cls][<span class=\"hljs-number\">2</span>] - R, centres[cls][<span class=\"hljs-number\">2</span>] + R);\r\n\r\n        <span class=\"hljs-comment\">/* The follosing can also be used\r\n        for (int j = 0; j &lt; 3; j++)\r\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\r\n        */</span>\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed in eight clusters in\r\n * 3D space and trains an SOM that finds the topological pattern. The following\r\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\r\n * to validate the execution:\r\n * * `test3.csv`: random test samples points with a circular pattern\r\n * * `w31.csv`: initial random map\r\n * * `w32.csv`: trained SOM map\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test3</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>, N = <span class=\"hljs-number\">500</span>;\r\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">3</span>;\r\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">30</span>;\r\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">X</span>(N);\r\n    std::vector&lt;std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">W</span>(num_out);\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; std::<span class=\"hljs-built_in\">max</span>(num_out, N); i++) {\r\n        <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; N) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\r\n            X[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\r\n            W[i] = std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;(num_out);\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; num_out; k++) {\r\n                W[i][k] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n                <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) {\r\n                    <span class=\"hljs-comment\">// preallocate with random initial weights</span>\r\n                    W[i][k][j] = _random(<span class=\"hljs-number\">-10</span>, <span class=\"hljs-number\">10</span>);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-built_in\">test_3d_classes2</span>(&amp;X);  <span class=\"hljs-comment\">// create test data around circumference of a circle</span>\r\n    <span class=\"hljs-built_in\">save_2d_data</span>(<span class=\"hljs-string\">&quot;test3.csv&quot;</span>, X);  <span class=\"hljs-comment\">// save test data points</span>\r\n    <span class=\"hljs-built_in\">save_u_matrix</span>(<span class=\"hljs-string\">&quot;w31.csv&quot;</span>, W);   <span class=\"hljs-comment\">// save initial random weights</span>\r\n    <span class=\"hljs-built_in\">kohonen_som</span>(X, &amp;W, <span class=\"hljs-number\">1e-4</span>);      <span class=\"hljs-comment\">// train the SOM</span>\r\n    <span class=\"hljs-built_in\">save_u_matrix</span>(<span class=\"hljs-string\">&quot;w32.csv&quot;</span>, W);   <span class=\"hljs-comment\">// save the resultant weights</span>\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Convert clock cycle difference to time in seconds\r\n *\r\n * \\param[in] start_t start clock\r\n * \\param[in] end_t end clock\r\n * \\returns time difference in seconds\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">get_clock_diff</span><span class=\"hljs-params\">(<span class=\"hljs-type\">clock_t</span> <span class=\"hljs-type\">start_t</span>, <span class=\"hljs-type\">clock_t</span> <span class=\"hljs-type\">end_t</span>)</span> </span>{\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(<span class=\"hljs-type\">end_t</span> - <span class=\"hljs-type\">start_t</span>) / CLOCKS_PER_SEC;\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Main function */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span> </span>{\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Using OpenMP based parallelization\\n&quot;</span>;\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;NOT using OpenMP based parallelization\\n&quot;</span>;\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n\r\n    std::<span class=\"hljs-built_in\">srand</span>(std::<span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">nullptr</span>));\r\n\r\n    std::<span class=\"hljs-type\">clock_t</span> start_clk = std::<span class=\"hljs-built_in\">clock</span>();\r\n    <span class=\"hljs-built_in\">test1</span>();\r\n    <span class=\"hljs-keyword\">auto</span> end_clk = std::<span class=\"hljs-built_in\">clock</span>();\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1 completed in &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">get_clock_diff</span>(start_clk, end_clk)\r\n              &lt;&lt; <span class=\"hljs-string\">&quot; sec\\n&quot;</span>;\r\n\r\n    start_clk = std::<span class=\"hljs-built_in\">clock</span>();\r\n    <span class=\"hljs-built_in\">test2</span>();\r\n    end_clk = std::<span class=\"hljs-built_in\">clock</span>();\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2 completed in &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">get_clock_diff</span>(start_clk, end_clk)\r\n              &lt;&lt; <span class=\"hljs-string\">&quot; sec\\n&quot;</span>;\r\n\r\n    start_clk = std::<span class=\"hljs-built_in\">clock</span>();\r\n    <span class=\"hljs-built_in\">test3</span>();\r\n    end_clk = std::<span class=\"hljs-built_in\">clock</span>();\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 3 completed in &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">get_clock_diff</span>(start_clk, end_clk)\r\n              &lt;&lt; <span class=\"hljs-string\">&quot; sec\\n&quot;</span>;\r\n\r\n    std::cout\r\n        &lt;&lt; <span class=\"hljs-string\">&quot;(Note: Calculated times include: creating test sets, training &quot;</span>\r\n           <span class=\"hljs-string\">&quot;model and writing files to disk.)\\n\\n&quot;</span>;\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    },
    "c": {
      "dir": "machine_learning\\kohonen_som_topology.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/machine_learning\\kohonen_som_topology.c",
      "code": "<span class=\"hljs-comment\">/**\r\n * \\file\r\n * \\brief [Kohonen self organizing\r\n * map](https://en.wikipedia.org/wiki/Self-organizing_map) (topological map)\r\n *\r\n * This example implements a powerful unsupervised learning algorithm called as\r\n * a self organizing map. The algorithm creates a connected network of weights\r\n * that closely follows the given data points. This thus creates a topological\r\n * map of the given data i.e., it maintains the relationship between various\r\n * data points in a much higher dimensional space by creating an equivalent in a\r\n * 2-dimensional space.\r\n * &lt;img alt=&quot;Trained topological maps for the test cases in the program&quot;\r\n * src=&quot;https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/2D_Kohonen_SOM.svg&quot;\r\n * /&gt;\r\n * \\author [Krishna Vedala](https://github.com/kvedala)\r\n * \\warning MSVC 2019 compiler generates code that does not execute as expected.\r\n * However, MinGW, Clang for GCC and Clang for MSVC compilers on windows perform\r\n * as expected. Any insights and suggestions should be directed to the author.\r\n * \\see kohonen_som_trace.c\r\n */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> _USE_MATH_DEFINES <span class=\"hljs-comment\">/**&lt; required for MS Visual C */</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;math.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;time.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP  <span class=\"hljs-comment\">// check if OpenMP based parallellization is available</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;omp.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @addtogroup machine_learning Machine learning algorithms\r\n * @{\r\n * @addtogroup kohonen_2d Kohonen SOM topology algorithm\r\n * @{\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> max</span>\r\n<span class=\"hljs-comment\">/** shorthand for maximum value */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> max(a, b) (((a) &gt; (b)) ? (a) : (b))</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> min</span>\r\n<span class=\"hljs-comment\">/** shorthand for minimum value */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> min(a, b) (((a) &lt; (b)) ? (a) : (b))</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n\r\n<span class=\"hljs-comment\">/** to store info regarding 3D arrays */</span>\r\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">kohonen_array_3d</span>\r\n{</span>\r\n    <span class=\"hljs-type\">int</span> dim1;     <span class=\"hljs-comment\">/**&lt; lengths of first dimension */</span>\r\n    <span class=\"hljs-type\">int</span> dim2;     <span class=\"hljs-comment\">/**&lt; lengths of second dimension */</span>\r\n    <span class=\"hljs-type\">int</span> dim3;     <span class=\"hljs-comment\">/**&lt; lengths of thirddimension */</span>\r\n    <span class=\"hljs-type\">double</span> *data; <span class=\"hljs-comment\">/**&lt; pointer to data */</span>\r\n};\r\n\r\n<span class=\"hljs-comment\">/** Function that returns the pointer to (x, y, z) ^th location in the\r\n * linear 3D array given by:\r\n * \\f[\r\n * X_{i,j,k} = i\\times M\\times N + j\\times N + k\r\n * \\f]\r\n * where \\f$L\\f$, \\f$M\\f$ and \\f$N\\f$ are the 3D matrix dimensions.\r\n * \\param[in] arr pointer to ::kohonen_array_3d structure\r\n * \\param[in] x     first index\r\n * \\param[in] y     second index\r\n * \\param[in] z     third index\r\n * \\returns pointer to (x,y,z)^th location of data\r\n */</span>\r\n<span class=\"hljs-type\">double</span> *<span class=\"hljs-title function_\">kohonen_data_3d</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">struct</span> kohonen_array_3d *arr, <span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y, <span class=\"hljs-type\">int</span> z)</span>\r\n{\r\n    <span class=\"hljs-type\">int</span> offset = (x * arr-&gt;dim2 * arr-&gt;dim3) + (y * arr-&gt;dim3) + z;\r\n    <span class=\"hljs-keyword\">return</span> arr-&gt;data + offset;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Helper function to generate a random number in a given interval.\r\n * \\n Steps:\r\n * 1. `r1 = rand() % 100` gets a random number between 0 and 99\r\n * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99\r\n * 3. scale and offset the random number to given range of \\f$[a,b)\\f$\r\n * \\f[\r\n * y = (b - a) \\times \\frac{\\text{(random number between 0 and RAND_MAX)} \\;\r\n * \\text{mod}\\; 100}{100} + a \\f]\r\n *\r\n * \\param[in] a lower limit\r\n * \\param[in] b upper limit\r\n * \\returns random number in the range \\f$[a,b)\\f$\r\n */</span>\r\n<span class=\"hljs-type\">double</span> _random(<span class=\"hljs-type\">double</span> a, <span class=\"hljs-type\">double</span> b)\r\n{\r\n    <span class=\"hljs-keyword\">return</span> ((b - a) * (rand() % <span class=\"hljs-number\">100</span>) / <span class=\"hljs-number\">100.f</span>) + a;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Save a given n-dimensional data martix to file.\r\n *\r\n * \\param[in] fname filename to save in (gets overwritten without confirmation)\r\n * \\param[in] X matrix to save\r\n * \\param[in] num_points rows in the matrix = number of points\r\n * \\param[in] num_features columns in the matrix = dimensions of points\r\n * \\returns 0 if all ok\r\n * \\returns -1 if file creation failed\r\n */</span>\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">save_2d_data</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fname, <span class=\"hljs-type\">double</span> **X, <span class=\"hljs-type\">int</span> num_points,\r\n                 <span class=\"hljs-type\">int</span> num_features)</span>\r\n{\r\n    FILE *fp = fopen(fname, <span class=\"hljs-string\">&quot;wt&quot;</span>);\r\n    <span class=\"hljs-keyword\">if</span> (!fp)  <span class=\"hljs-comment\">// error with fopen</span>\r\n    {\r\n        <span class=\"hljs-type\">char</span> msg[<span class=\"hljs-number\">120</span>];\r\n        <span class=\"hljs-built_in\">sprintf</span>(msg, <span class=\"hljs-string\">&quot;File error (%s): &quot;</span>, fname);\r\n        perror(msg);\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; num_points; i++)  <span class=\"hljs-comment\">// for each point in the array</span>\r\n    {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; num_features; j++)  <span class=\"hljs-comment\">// for each feature in the array</span>\r\n        {\r\n            <span class=\"hljs-built_in\">fprintf</span>(fp, <span class=\"hljs-string\">&quot;%.4g&quot;</span>, X[i][j]);  <span class=\"hljs-comment\">// print the feature value</span>\r\n            <span class=\"hljs-keyword\">if</span> (j &lt; num_features - <span class=\"hljs-number\">1</span>)      <span class=\"hljs-comment\">// if not the last feature</span>\r\n                fputc(<span class=\"hljs-string\">&#x27;,&#x27;</span>, fp);            <span class=\"hljs-comment\">// suffix comma</span>\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_points - <span class=\"hljs-number\">1</span>)  <span class=\"hljs-comment\">// if not the last row</span>\r\n            fputc(<span class=\"hljs-string\">&#x27;\\n&#x27;</span>, fp);     <span class=\"hljs-comment\">// start a new line</span>\r\n    }\r\n    fclose(fp);\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Create the distance matrix or\r\n * [U-matrix](https://en.wikipedia.org/wiki/U-matrix) from the trained weights\r\n * and save to disk.\r\n *\r\n * \\param [in] fname filename to save in (gets overwriten without confirmation)\r\n * \\param [in] W model matrix to save\r\n * \\returns 0 if all ok\r\n * \\returns -1 if file creation failed\r\n */</span>\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">save_u_matrix</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fname, <span class=\"hljs-keyword\">struct</span> kohonen_array_3d *W)</span>\r\n{\r\n    FILE *fp = fopen(fname, <span class=\"hljs-string\">&quot;wt&quot;</span>);\r\n    <span class=\"hljs-keyword\">if</span> (!fp)  <span class=\"hljs-comment\">// error with fopen</span>\r\n    {\r\n        <span class=\"hljs-type\">char</span> msg[<span class=\"hljs-number\">120</span>];\r\n        <span class=\"hljs-built_in\">sprintf</span>(msg, <span class=\"hljs-string\">&quot;File error (%s): &quot;</span>, fname);\r\n        perror(msg);\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\r\n    }\r\n\r\n    <span class=\"hljs-type\">int</span> R = max(W-&gt;dim1 &gt;&gt; <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">/* neighborhood range */</span>\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; W-&gt;dim1; i++)  <span class=\"hljs-comment\">// for each x</span>\r\n    {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; W-&gt;dim2; j++)  <span class=\"hljs-comment\">// for each y</span>\r\n        {\r\n            <span class=\"hljs-type\">double</span> distance = <span class=\"hljs-number\">0.f</span>;\r\n            <span class=\"hljs-type\">int</span> k;\r\n\r\n            <span class=\"hljs-type\">int</span> from_x = max(<span class=\"hljs-number\">0</span>, i - R);\r\n            <span class=\"hljs-type\">int</span> to_x = min(W-&gt;dim1, i + R + <span class=\"hljs-number\">1</span>);\r\n            <span class=\"hljs-type\">int</span> from_y = max(<span class=\"hljs-number\">0</span>, j - R);\r\n            <span class=\"hljs-type\">int</span> to_y = min(W-&gt;dim2, j + R + <span class=\"hljs-number\">1</span>);\r\n            <span class=\"hljs-type\">int</span> l;\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp parallel for reduction(+ : distance)</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n            <span class=\"hljs-keyword\">for</span> (l = from_x; l &lt; to_x; l++)  <span class=\"hljs-comment\">// scan neighborhoor in x</span>\r\n            {\r\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> m = from_y; m &lt; to_y; m++)  <span class=\"hljs-comment\">// scan neighborhood in y</span>\r\n                {\r\n                    <span class=\"hljs-type\">double</span> d = <span class=\"hljs-number\">0.f</span>;\r\n                    <span class=\"hljs-keyword\">for</span> (k = <span class=\"hljs-number\">0</span>; k &lt; W-&gt;dim3; k++)  <span class=\"hljs-comment\">// for each feature</span>\r\n                    {\r\n                        <span class=\"hljs-type\">double</span> *w1 = kohonen_data_3d(W, i, j, k);\r\n                        <span class=\"hljs-type\">double</span> *w2 = kohonen_data_3d(W, l, m, k);\r\n                        d += (w1[<span class=\"hljs-number\">0</span>] - w2[<span class=\"hljs-number\">0</span>]) * (w1[<span class=\"hljs-number\">0</span>] - w2[<span class=\"hljs-number\">0</span>]);\r\n                        <span class=\"hljs-comment\">// distance += w1[0] * w1[0];</span>\r\n                    }\r\n                    distance += <span class=\"hljs-built_in\">sqrt</span>(d);\r\n                    <span class=\"hljs-comment\">// distance += d;</span>\r\n                }\r\n            }\r\n\r\n            distance /= R * R;              <span class=\"hljs-comment\">// mean distance from neighbors</span>\r\n            <span class=\"hljs-built_in\">fprintf</span>(fp, <span class=\"hljs-string\">&quot;%.4g&quot;</span>, distance);  <span class=\"hljs-comment\">// print the mean separation</span>\r\n            <span class=\"hljs-keyword\">if</span> (j &lt; W-&gt;dim2 - <span class=\"hljs-number\">1</span>)            <span class=\"hljs-comment\">// if not the last column</span>\r\n                fputc(<span class=\"hljs-string\">&#x27;,&#x27;</span>, fp);             <span class=\"hljs-comment\">// suffix comma</span>\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; W-&gt;dim1 - <span class=\"hljs-number\">1</span>)  <span class=\"hljs-comment\">// if not the last row</span>\r\n            fputc(<span class=\"hljs-string\">&#x27;\\n&#x27;</span>, fp);  <span class=\"hljs-comment\">// start a new line</span>\r\n    }\r\n    fclose(fp);\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Get minimum value and index of the value in a matrix\r\n * \\param[in] X matrix to search\r\n * \\param[in] N number of points in the vector\r\n * \\param[out] val minimum value found\r\n * \\param[out] x_idx x-index where minimum value was found\r\n * \\param[out] y_idx y-index where minimum value was found\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">get_min_2d</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> **X, <span class=\"hljs-type\">int</span> N, <span class=\"hljs-type\">double</span> *val, <span class=\"hljs-type\">int</span> *x_idx, <span class=\"hljs-type\">int</span> *y_idx)</span>\r\n{\r\n    val[<span class=\"hljs-number\">0</span>] = INFINITY;  <span class=\"hljs-comment\">// initial min value</span>\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)  <span class=\"hljs-comment\">// traverse each x-index</span>\r\n    {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; N; j++)  <span class=\"hljs-comment\">// traverse each y-index</span>\r\n        {\r\n            <span class=\"hljs-keyword\">if</span> (X[i][j] &lt; val[<span class=\"hljs-number\">0</span>])  <span class=\"hljs-comment\">// if a lower value is found</span>\r\n            {                      <span class=\"hljs-comment\">// save the value and its index</span>\r\n                x_idx[<span class=\"hljs-number\">0</span>] = i;\r\n                y_idx[<span class=\"hljs-number\">0</span>] = j;\r\n                val[<span class=\"hljs-number\">0</span>] = X[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Update weights of the SOM using Kohonen algorithm\r\n *\r\n * \\param[in] X data point\r\n * \\param[in,out] W weights matrix\r\n * \\param[in,out] D temporary vector to store distances\r\n * \\param[in] num_out number of output points\r\n * \\param[in] num_features number of features per input sample\r\n * \\param[in] alpha learning rate \\f$0&lt;\\alpha\\le1\\f$\r\n * \\param[in] R neighborhood range\r\n * \\returns minimum distance of sample and trained weights\r\n */</span>\r\n<span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">kohonen_update_weights</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> *X, <span class=\"hljs-keyword\">struct</span> kohonen_array_3d *W,\r\n                              <span class=\"hljs-type\">double</span> **D, <span class=\"hljs-type\">int</span> num_out, <span class=\"hljs-type\">int</span> num_features,\r\n                              <span class=\"hljs-type\">double</span> alpha, <span class=\"hljs-type\">int</span> R)</span>\r\n{\r\n    <span class=\"hljs-type\">int</span> x, y, k;\r\n    <span class=\"hljs-type\">double</span> d_min = <span class=\"hljs-number\">0.f</span>;\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-comment\">// step 1: for each 2D output point</span>\r\n    <span class=\"hljs-keyword\">for</span> (x = <span class=\"hljs-number\">0</span>; x &lt; num_out; x++)\r\n    {\r\n        <span class=\"hljs-keyword\">for</span> (y = <span class=\"hljs-number\">0</span>; y &lt; num_out; y++)\r\n        {\r\n            D[x][y] = <span class=\"hljs-number\">0.f</span>;\r\n            <span class=\"hljs-comment\">// compute Euclidian distance of each output</span>\r\n            <span class=\"hljs-comment\">// point from the current sample</span>\r\n            <span class=\"hljs-keyword\">for</span> (k = <span class=\"hljs-number\">0</span>; k &lt; num_features; k++)\r\n            {\r\n                <span class=\"hljs-type\">double</span> *w = kohonen_data_3d(W, x, y, k);\r\n                D[x][y] += (w[<span class=\"hljs-number\">0</span>] - X[k]) * (w[<span class=\"hljs-number\">0</span>] - X[k]);\r\n            }\r\n            D[x][y] = <span class=\"hljs-built_in\">sqrt</span>(D[x][y]);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// step 2:  get closest node i.e., node with smallest Euclidian distance to</span>\r\n    <span class=\"hljs-comment\">// the current pattern</span>\r\n    <span class=\"hljs-type\">int</span> d_min_x, d_min_y;\r\n    get_min_2d(D, num_out, &amp;d_min, &amp;d_min_x, &amp;d_min_y);\r\n\r\n    <span class=\"hljs-comment\">// step 3a: get the neighborhood range</span>\r\n    <span class=\"hljs-type\">int</span> from_x = max(<span class=\"hljs-number\">0</span>, d_min_x - R);\r\n    <span class=\"hljs-type\">int</span> to_x = min(num_out, d_min_x + R + <span class=\"hljs-number\">1</span>);\r\n    <span class=\"hljs-type\">int</span> from_y = max(<span class=\"hljs-number\">0</span>, d_min_y - R);\r\n    <span class=\"hljs-type\">int</span> to_y = min(num_out, d_min_y + R + <span class=\"hljs-number\">1</span>);\r\n\r\n    <span class=\"hljs-comment\">// step 3b: update the weights of nodes in the</span>\r\n    <span class=\"hljs-comment\">// neighborhood</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-keyword\">for</span> (x = from_x; x &lt; to_x; x++)\r\n    {\r\n        <span class=\"hljs-keyword\">for</span> (y = from_y; y &lt; to_y; y++)\r\n        {\r\n            <span class=\"hljs-comment\">/* you can enable the following normalization if needed.\r\n               personally, I found it detrimental to convergence */</span>\r\n            <span class=\"hljs-comment\">// const double s2pi = sqrt(2.f * M_PI);</span>\r\n            <span class=\"hljs-comment\">// double normalize = 1.f / (alpha * s2pi);</span>\r\n\r\n            <span class=\"hljs-comment\">/* apply scaling inversely proportional to distance from the\r\n               current node */</span>\r\n            <span class=\"hljs-type\">double</span> d2 =\r\n                (d_min_x - x) * (d_min_x - x) + (d_min_y - y) * (d_min_y - y);\r\n            <span class=\"hljs-type\">double</span> scale_factor = <span class=\"hljs-built_in\">exp</span>(-d2 / (<span class=\"hljs-number\">2.f</span> * alpha * alpha));\r\n\r\n            <span class=\"hljs-keyword\">for</span> (k = <span class=\"hljs-number\">0</span>; k &lt; num_features; k++)\r\n            {\r\n                <span class=\"hljs-type\">double</span> *w = kohonen_data_3d(W, x, y, k);\r\n                <span class=\"hljs-comment\">// update weights of nodes in the neighborhood</span>\r\n                w[<span class=\"hljs-number\">0</span>] += alpha * scale_factor * (X[k] - w[<span class=\"hljs-number\">0</span>]);\r\n            }\r\n        }\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> d_min;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Apply incremental algorithm with updating neighborhood and learning rates\r\n * on all samples in the given datset.\r\n *\r\n * \\param[in] X data set\r\n * \\param[in,out] W weights matrix\r\n * \\param[in] num_samples number of output points\r\n * \\param[in] num_features number of features per input sample\r\n * \\param[in] num_out number of output points\r\n * \\param[in] alpha_min terminal value of alpha\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">kohonen_som</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> **X, <span class=\"hljs-keyword\">struct</span> kohonen_array_3d *W, <span class=\"hljs-type\">int</span> num_samples,\r\n                 <span class=\"hljs-type\">int</span> num_features, <span class=\"hljs-type\">int</span> num_out, <span class=\"hljs-type\">double</span> alpha_min)</span>\r\n{\r\n    <span class=\"hljs-type\">int</span> R = num_out &gt;&gt; <span class=\"hljs-number\">2</span>, iter = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">double</span> **D = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(num_out * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; num_out; i++)\r\n        D[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(num_out * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\r\n\r\n    <span class=\"hljs-type\">double</span> dmin = <span class=\"hljs-number\">1.f</span>;  <span class=\"hljs-comment\">// average minimum distance of all samples</span>\r\n\r\n    <span class=\"hljs-comment\">// Loop alpha from 1 to slpha_min</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">double</span> alpha = <span class=\"hljs-number\">1.f</span>; alpha &gt; alpha_min &amp;&amp; dmin &gt; <span class=\"hljs-number\">1e-3</span>;\r\n         alpha -= <span class=\"hljs-number\">0.001</span>, iter++)\r\n    {\r\n        dmin = <span class=\"hljs-number\">0.f</span>;\r\n        <span class=\"hljs-comment\">// Loop for each sample pattern in the data set</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> sample = <span class=\"hljs-number\">0</span>; sample &lt; num_samples; sample++)\r\n        {\r\n            <span class=\"hljs-comment\">// update weights for the current input pattern sample</span>\r\n            dmin += kohonen_update_weights(X[sample], W, D, num_out,\r\n                                           num_features, alpha, R);\r\n        }\r\n\r\n        <span class=\"hljs-comment\">// every 20th iteration, reduce the neighborhood range</span>\r\n        <span class=\"hljs-keyword\">if</span> (iter % <span class=\"hljs-number\">100</span> == <span class=\"hljs-number\">0</span> &amp;&amp; R &gt; <span class=\"hljs-number\">1</span>)\r\n            R--;\r\n\r\n        dmin /= num_samples;\r\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;iter: %5d\\t alpha: %.4g\\t R: %d\\td_min: %.4g\\r&quot;</span>, iter, alpha, R,\r\n               dmin);\r\n    }\r\n    <span class=\"hljs-built_in\">putchar</span>(<span class=\"hljs-string\">&#x27;\\n&#x27;</span>);\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; num_out; i++) <span class=\"hljs-built_in\">free</span>(D[i]);\r\n    <span class=\"hljs-built_in\">free</span>(D);\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @}\r\n * @}\r\n */</span>\r\n\r\n<span class=\"hljs-comment\">/** Creates a random set of points distributed in four clusters in\r\n * 3D space with centroids at the points\r\n * * \\f$(0,5, 0.5, 0.5)\\f$\r\n * * \\f$(0,5,-0.5, -0.5)\\f$\r\n * * \\f$(-0,5, 0.5, 0.5)\\f$\r\n * * \\f$(-0,5,-0.5, -0.5)\\f$\r\n *\r\n * \\param[out] data matrix to store data in\r\n * \\param[in] N number of points required\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test_2d_classes</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> *<span class=\"hljs-type\">const</span> *data, <span class=\"hljs-type\">int</span> N)</span>\r\n{\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.3</span>;  <span class=\"hljs-comment\">// radius of cluster</span>\r\n    <span class=\"hljs-type\">int</span> i;\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> num_classes = <span class=\"hljs-number\">4</span>;\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> centres[][<span class=\"hljs-number\">2</span>] = {\r\n        <span class=\"hljs-comment\">// centres of each class cluster</span>\r\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>},   <span class=\"hljs-comment\">// centre of class 1</span>\r\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>},  <span class=\"hljs-comment\">// centre of class 2</span>\r\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>},  <span class=\"hljs-comment\">// centre of class 3</span>\r\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>}  <span class=\"hljs-comment\">// centre of class 4</span>\r\n    };\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\r\n    {\r\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> =</span>\r\n            rand() % num_classes;  <span class=\"hljs-comment\">// select a random class for the point</span>\r\n\r\n        <span class=\"hljs-comment\">// create random coordinates (x,y,z) around the centre of the class</span>\r\n        data[i][<span class=\"hljs-number\">0</span>] = _random(centres[class][<span class=\"hljs-number\">0</span>] - R, centres[class][<span class=\"hljs-number\">0</span>] + R);\r\n        data[i][<span class=\"hljs-number\">1</span>] = _random(centres[class][<span class=\"hljs-number\">1</span>] - R, centres[class][<span class=\"hljs-number\">1</span>] + R);\r\n\r\n        <span class=\"hljs-comment\">/* The follosing can also be used\r\n        for (int j = 0; j &lt; 2; j++)\r\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\r\n        */</span>\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed in four clusters in\r\n * 2D space and trains an SOM that finds the topological pattern.\r\n * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)\r\n * files are created to validate the execution:\r\n * * `test1.csv`: random test samples points with a circular pattern\r\n * * `w11.csv`: initial random U-matrix\r\n * * `w12.csv`: trained SOM U-matrix\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test1</span><span class=\"hljs-params\">()</span>\r\n{\r\n    <span class=\"hljs-type\">int</span> j, N = <span class=\"hljs-number\">300</span>;\r\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">2</span>;\r\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">30</span>;  <span class=\"hljs-comment\">// image size - N x N</span>\r\n\r\n    <span class=\"hljs-comment\">// 2D space, hence size = number of rows * 2</span>\r\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\r\n\r\n    <span class=\"hljs-comment\">// cluster nodex in &#x27;x&#x27; * cluster nodes in &#x27;y&#x27; * 2</span>\r\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">kohonen_array_3d</span> <span class=\"hljs-title\">W</span>;</span>\r\n    W.dim1 = num_out;\r\n    W.dim2 = num_out;\r\n    W.dim3 = features;\r\n    W.data = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(num_out * num_out * features *\r\n                              <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));  <span class=\"hljs-comment\">// assign rows</span>\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)  <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\r\n    {\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\r\n            X[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\r\n        {\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; num_out; k++)\r\n            {\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n                <span class=\"hljs-comment\">// preallocate with random initial weights</span>\r\n                <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++)\r\n                {\r\n                    <span class=\"hljs-type\">double</span> *w = kohonen_data_3d(&amp;W, i, k, j);\r\n                    w[<span class=\"hljs-number\">0</span>] = _random(<span class=\"hljs-number\">-5</span>, <span class=\"hljs-number\">5</span>);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    test_2d_classes(X, N);  <span class=\"hljs-comment\">// create test data around circumference of a circle</span>\r\n    save_2d_data(<span class=\"hljs-string\">&quot;test1.csv&quot;</span>, X, N, features);  <span class=\"hljs-comment\">// save test data points</span>\r\n    save_u_matrix(<span class=\"hljs-string\">&quot;w11.csv&quot;</span>, &amp;W);               <span class=\"hljs-comment\">// save initial random weights</span>\r\n    kohonen_som(X, &amp;W, N, features, num_out, <span class=\"hljs-number\">1e-4</span>);  <span class=\"hljs-comment\">// train the SOM</span>\r\n    save_u_matrix(<span class=\"hljs-string\">&quot;w12.csv&quot;</span>, &amp;W);  <span class=\"hljs-comment\">// save the resultant weights</span>\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) <span class=\"hljs-built_in\">free</span>(X[i]);\r\n    <span class=\"hljs-built_in\">free</span>(X);\r\n    <span class=\"hljs-built_in\">free</span>(W.data);\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Creates a random set of points distributed in four clusters in\r\n * 3D space with centroids at the points\r\n * * \\f$(0,5, 0.5, 0.5)\\f$\r\n * * \\f$(0,5,-0.5, -0.5)\\f$\r\n * * \\f$(-0,5, 0.5, 0.5)\\f$\r\n * * \\f$(-0,5,-0.5, -0.5)\\f$\r\n *\r\n * \\param[out] data matrix to store data in\r\n * \\param[in] N number of points required\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test_3d_classes1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> *<span class=\"hljs-type\">const</span> *data, <span class=\"hljs-type\">int</span> N)</span>\r\n{\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.2</span>;  <span class=\"hljs-comment\">// radius of cluster</span>\r\n    <span class=\"hljs-type\">int</span> i;\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> num_classes = <span class=\"hljs-number\">4</span>;\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> centres[][<span class=\"hljs-number\">3</span>] = {\r\n        <span class=\"hljs-comment\">// centres of each class cluster</span>\r\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>},    <span class=\"hljs-comment\">// centre of class 1</span>\r\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>},  <span class=\"hljs-comment\">// centre of class 2</span>\r\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>},   <span class=\"hljs-comment\">// centre of class 3</span>\r\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span> - <span class=\"hljs-number\">.5</span>}  <span class=\"hljs-comment\">// centre of class 4</span>\r\n    };\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\r\n    {\r\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> =</span>\r\n            rand() % num_classes;  <span class=\"hljs-comment\">// select a random class for the point</span>\r\n\r\n        <span class=\"hljs-comment\">// create random coordinates (x,y,z) around the centre of the class</span>\r\n        data[i][<span class=\"hljs-number\">0</span>] = _random(centres[class][<span class=\"hljs-number\">0</span>] - R, centres[class][<span class=\"hljs-number\">0</span>] + R);\r\n        data[i][<span class=\"hljs-number\">1</span>] = _random(centres[class][<span class=\"hljs-number\">1</span>] - R, centres[class][<span class=\"hljs-number\">1</span>] + R);\r\n        data[i][<span class=\"hljs-number\">2</span>] = _random(centres[class][<span class=\"hljs-number\">2</span>] - R, centres[class][<span class=\"hljs-number\">2</span>] + R);\r\n\r\n        <span class=\"hljs-comment\">/* The follosing can also be used\r\n        for (int j = 0; j &lt; 3; j++)\r\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\r\n        */</span>\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed in 4 clusters in\r\n * 3D space and trains an SOM that finds the topological pattern. The following\r\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\r\n * to validate the execution:\r\n * * `test2.csv`: random test samples points\r\n * * `w21.csv`: initial random U-matrix\r\n * * `w22.csv`: trained SOM U-matrix\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test2</span><span class=\"hljs-params\">()</span>\r\n{\r\n    <span class=\"hljs-type\">int</span> j, N = <span class=\"hljs-number\">500</span>;\r\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">3</span>;\r\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">30</span>;  <span class=\"hljs-comment\">// image size - N x N</span>\r\n\r\n    <span class=\"hljs-comment\">// 3D space, hence size = number of rows * 3</span>\r\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\r\n\r\n    <span class=\"hljs-comment\">// cluster nodex in &#x27;x&#x27; * cluster nodes in &#x27;y&#x27; * 2</span>\r\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">kohonen_array_3d</span> <span class=\"hljs-title\">W</span>;</span>\r\n    W.dim1 = num_out;\r\n    W.dim2 = num_out;\r\n    W.dim3 = features;\r\n    W.data = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(num_out * num_out * features *\r\n                              <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));  <span class=\"hljs-comment\">// assign rows</span>\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)  <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\r\n    {\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\r\n            X[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\r\n        {\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; num_out; k++)\r\n            {\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n                <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++)\r\n                {  <span class=\"hljs-comment\">// preallocate with random initial weights</span>\r\n                    <span class=\"hljs-type\">double</span> *w = kohonen_data_3d(&amp;W, i, k, j);\r\n                    w[<span class=\"hljs-number\">0</span>] = _random(<span class=\"hljs-number\">-5</span>, <span class=\"hljs-number\">5</span>);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    test_3d_classes1(X, N);                     <span class=\"hljs-comment\">// create test data</span>\r\n    save_2d_data(<span class=\"hljs-string\">&quot;test2.csv&quot;</span>, X, N, features);  <span class=\"hljs-comment\">// save test data points</span>\r\n    save_u_matrix(<span class=\"hljs-string\">&quot;w21.csv&quot;</span>, &amp;W);               <span class=\"hljs-comment\">// save initial random weights</span>\r\n    kohonen_som(X, &amp;W, N, features, num_out, <span class=\"hljs-number\">1e-4</span>);  <span class=\"hljs-comment\">// train the SOM</span>\r\n    save_u_matrix(<span class=\"hljs-string\">&quot;w22.csv&quot;</span>, &amp;W);  <span class=\"hljs-comment\">// save the resultant weights</span>\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) <span class=\"hljs-built_in\">free</span>(X[i]);\r\n    <span class=\"hljs-built_in\">free</span>(X);\r\n    <span class=\"hljs-built_in\">free</span>(W.data);\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Creates a random set of points distributed in four clusters in\r\n * 3D space with centroids at the points\r\n * * \\f$(0,5, 0.5, 0.5)\\f$\r\n * * \\f$(0,5,-0.5, -0.5)\\f$\r\n * * \\f$(-0,5, 0.5, 0.5)\\f$\r\n * * \\f$(-0,5,-0.5, -0.5)\\f$\r\n *\r\n * \\param[out] data matrix to store data in\r\n * \\param[in] N number of points required\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test_3d_classes2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> *<span class=\"hljs-type\">const</span> *data, <span class=\"hljs-type\">int</span> N)</span>\r\n{\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.2</span>;  <span class=\"hljs-comment\">// radius of cluster</span>\r\n    <span class=\"hljs-type\">int</span> i;\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> num_classes = <span class=\"hljs-number\">8</span>;\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> centres[][<span class=\"hljs-number\">3</span>] = {\r\n        <span class=\"hljs-comment\">// centres of each class cluster</span>\r\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>},    <span class=\"hljs-comment\">// centre of class 1</span>\r\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>},   <span class=\"hljs-comment\">// centre of class 2</span>\r\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>},   <span class=\"hljs-comment\">// centre of class 3</span>\r\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>},  <span class=\"hljs-comment\">// centre of class 4</span>\r\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>},   <span class=\"hljs-comment\">// centre of class 5</span>\r\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>},  <span class=\"hljs-comment\">// centre of class 6</span>\r\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>},  <span class=\"hljs-comment\">// centre of class 7</span>\r\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>}  <span class=\"hljs-comment\">// centre of class 8</span>\r\n    };\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\r\n    {\r\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> =</span>\r\n            rand() % num_classes;  <span class=\"hljs-comment\">// select a random class for the point</span>\r\n\r\n        <span class=\"hljs-comment\">// create random coordinates (x,y,z) around the centre of the class</span>\r\n        data[i][<span class=\"hljs-number\">0</span>] = _random(centres[class][<span class=\"hljs-number\">0</span>] - R, centres[class][<span class=\"hljs-number\">0</span>] + R);\r\n        data[i][<span class=\"hljs-number\">1</span>] = _random(centres[class][<span class=\"hljs-number\">1</span>] - R, centres[class][<span class=\"hljs-number\">1</span>] + R);\r\n        data[i][<span class=\"hljs-number\">2</span>] = _random(centres[class][<span class=\"hljs-number\">2</span>] - R, centres[class][<span class=\"hljs-number\">2</span>] + R);\r\n\r\n        <span class=\"hljs-comment\">/* The follosing can also be used\r\n        for (int j = 0; j &lt; 3; j++)\r\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\r\n        */</span>\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed in eight clusters in\r\n * 3D space and trains an SOM that finds the topological pattern. The following\r\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\r\n * to validate the execution:\r\n * * `test3.csv`: random test samples points\r\n * * `w31.csv`: initial random U-matrix\r\n * * `w32.csv`: trained SOM U-matrix\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test3</span><span class=\"hljs-params\">()</span>\r\n{\r\n    <span class=\"hljs-type\">int</span> j, N = <span class=\"hljs-number\">500</span>;\r\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">3</span>;\r\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">30</span>;\r\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\r\n\r\n    <span class=\"hljs-comment\">// cluster nodex in &#x27;x&#x27; * cluster nodes in &#x27;y&#x27; * 2</span>\r\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">kohonen_array_3d</span> <span class=\"hljs-title\">W</span>;</span>\r\n    W.dim1 = num_out;\r\n    W.dim2 = num_out;\r\n    W.dim3 = features;\r\n    W.data = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(num_out * num_out * features *\r\n                              <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));  <span class=\"hljs-comment\">// assign rows</span>\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)  <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\r\n    {\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\r\n            X[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\r\n        {\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; num_out; k++)\r\n            {\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n                <span class=\"hljs-comment\">// preallocate with random initial weights</span>\r\n                <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++)\r\n                {\r\n                    <span class=\"hljs-type\">double</span> *w = kohonen_data_3d(&amp;W, i, k, j);\r\n                    w[<span class=\"hljs-number\">0</span>] = _random(<span class=\"hljs-number\">-5</span>, <span class=\"hljs-number\">5</span>);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    test_3d_classes2(X, N);  <span class=\"hljs-comment\">// create test data around the lamniscate</span>\r\n    save_2d_data(<span class=\"hljs-string\">&quot;test3.csv&quot;</span>, X, N, features);  <span class=\"hljs-comment\">// save test data points</span>\r\n    save_u_matrix(<span class=\"hljs-string\">&quot;w31.csv&quot;</span>, &amp;W);               <span class=\"hljs-comment\">// save initial random weights</span>\r\n    kohonen_som(X, &amp;W, N, features, num_out, <span class=\"hljs-number\">0.01</span>);  <span class=\"hljs-comment\">// train the SOM</span>\r\n    save_u_matrix(<span class=\"hljs-string\">&quot;w32.csv&quot;</span>, &amp;W);  <span class=\"hljs-comment\">// save the resultant weights</span>\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) <span class=\"hljs-built_in\">free</span>(X[i]);\r\n    <span class=\"hljs-built_in\">free</span>(X);\r\n    <span class=\"hljs-built_in\">free</span>(W.data);\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Convert clock cycle difference to time in seconds\r\n *\r\n * \\param[in] start_t start clock\r\n * \\param[in] end_t end clock\r\n * \\returns time difference in seconds\r\n */</span>\r\n<span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">get_clock_diff</span><span class=\"hljs-params\">(<span class=\"hljs-type\">clock_t</span> <span class=\"hljs-type\">start_t</span>, <span class=\"hljs-type\">clock_t</span> <span class=\"hljs-type\">end_t</span>)</span>\r\n{\r\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-type\">double</span>)(<span class=\"hljs-type\">end_t</span> - <span class=\"hljs-type\">start_t</span>) / (<span class=\"hljs-type\">double</span>)CLOCKS_PER_SEC;\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Main function */</span>\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span>\r\n{\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Using OpenMP based parallelization\\n&quot;</span>);\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;NOT using OpenMP based parallelization\\n&quot;</span>);\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-type\">clock_t</span> start_clk, end_clk;\r\n\r\n    start_clk = clock();\r\n    test1();\r\n    end_clk = clock();\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Test 1 completed in %.4g sec\\n&quot;</span>,\r\n           get_clock_diff(start_clk, end_clk));\r\n\r\n    start_clk = clock();\r\n    test2();\r\n    end_clk = clock();\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Test 2 completed in %.4g sec\\n&quot;</span>,\r\n           get_clock_diff(start_clk, end_clk));\r\n\r\n    start_clk = clock();\r\n    test3();\r\n    end_clk = clock();\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Test 3 completed in %.4g sec\\n&quot;</span>,\r\n           get_clock_diff(start_clk, end_clk));\r\n\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;(Note: Calculated times include: writing files to disk.)\\n\\n&quot;</span>);\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 10
    }
  ],
  "explanationUrl": {}
}