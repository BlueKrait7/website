{
  "slug": "depth-first-search-with-stack",
  "name": "Depth First Search with Stack",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "graph\\depth_first_search_with_stack.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph\\depth_first_search_with_stack.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n *\r\n * @file\r\n * @brief [Depth First Search Algorithm using Stack\r\n * (Depth First Search Algorithm)](https://en.wikipedia.org/wiki/Depth-first_search)\r\n *\r\n * @author [Ayaan Khan](http://github.com/ayaankhan98)\r\n * @author [Saurav Uppoor](https://github.com/sauravUppoor)\r\n *\r\n * @details\r\n * Depth First Search also quoted as DFS is a Graph Traversal Algorithm.\r\n * Time Complexity O(|V| + |E|) where V is number of vertices and E\r\n * is number of edges in graph.\r\n *\r\n * Application of Depth First Search are\r\n *\r\n * 1. Finding connected components\r\n * 2. Finding 2-(edge or vertex)-connected components.\r\n * 3. Finding 3-(edge or vertex)-connected components.\r\n * 4. Finding the bridges of a graph.\r\n * 5. Generating words in order to plot the limit set of a group.\r\n * 6. Finding strongly connected components.\r\n *\r\n * &lt;h4&gt;Working&lt;/h4&gt;\r\n * 1. Mark all vertices as unvisited (colour it WHITE).\r\n * 2. Push starting vertex into the stack and colour it GREY.\r\n * 3. Once a node is popped out of the stack and is coloured GREY, we colour it BLACK.\r\n * 4. Push all its neighbours which are not coloured BLACK.\r\n * 5. Repeat steps 4 and 5 until the stack is empty.\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span> \t <span class=\"hljs-comment\">/// for IO operations</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span>    \t <span class=\"hljs-comment\">/// header for std::stack</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>   \t <span class=\"hljs-comment\">/// header for std::vector</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>  \t <span class=\"hljs-comment\">/// header for preprocessor macro assert() </span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;limits&gt;</span>   \t <span class=\"hljs-comment\">/// header for limits of integral types</span></span>\r\n\r\n<span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> WHITE = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">/// indicates the node hasn&#x27;t been explored</span>\r\n<span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> GREY = <span class=\"hljs-number\">1</span>;\t <span class=\"hljs-comment\">/// indicates node is in stack waiting to be explored</span>\r\n<span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> BLACK = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">/// indicates node has already been explored</span>\r\n<span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int64_t</span> INF = std::numeric_limits&lt;<span class=\"hljs-type\">int16_t</span>&gt;::<span class=\"hljs-built_in\">max</span>();\r\n\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace graph\r\n * @brief Graph algorithms\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> graph {\r\n<span class=\"hljs-comment\">/**\r\n * @namespace depth_first_search\r\n * @brief Functions for [Depth First Search](https://en.wikipedia.org/wiki/Depth-first_search) algorithm\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> depth_first_search {\r\n<span class=\"hljs-comment\">/**\r\n * @brief\r\n * Adds and edge between two vertices of graph say u and v in this\r\n * case.\r\n *\r\n * @param adj Adjacency list representation of graph\r\n * @param u first vertex\r\n * @param v second vertex\r\n *\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addEdge</span><span class=\"hljs-params\">(std::vector&lt;std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt;&gt; *adj, <span class=\"hljs-type\">size_t</span> u, <span class=\"hljs-type\">size_t</span> v)</span> </span>{\r\n\t<span class=\"hljs-comment\">/*\r\n\t*\r\n\t* Here we are considering undirected graph that&#x27;s the\r\n\t* reason we are adding v to the adjacency list representation of u\r\n\t* and also adding u to the adjacency list representation of v\r\n\t*\r\n\t*/</span>\r\n\t(*adj)[u - <span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">push_back</span>(v - <span class=\"hljs-number\">1</span>);\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n *\r\n * @brief\r\n * Explores the given vertex, exploring a vertex means traversing\r\n * over all the vertices which are connected to the vertex that is\r\n * currently being explored and push it onto the stack.\r\n *\r\n * @param adj graph\r\n * @param start starting vertex for DFS\r\n * @return vector with nodes stored in the order of DFS traversal\r\n *\r\n */</span>\r\n<span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; &gt; &amp;graph, <span class=\"hljs-type\">size_t</span> start)</span> </span>{\r\n    <span class=\"hljs-comment\">/// checked[i] stores the status of each node</span>\r\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; <span class=\"hljs-title\">checked</span><span class=\"hljs-params\">(graph.size(), WHITE)</span>, traversed_path</span>;\r\n\r\n    checked[start] = GREY;\r\n    std::stack&lt;<span class=\"hljs-type\">size_t</span>&gt; stack;\r\n    stack.<span class=\"hljs-built_in\">push</span>(start);\r\n\r\n    <span class=\"hljs-comment\">/// while stack is not empty we keep exploring the node on top of stack</span>\r\n    <span class=\"hljs-keyword\">while</span> (!stack.<span class=\"hljs-built_in\">empty</span>()) {\r\n        <span class=\"hljs-type\">int</span> act = stack.<span class=\"hljs-built_in\">top</span>();\r\n        stack.<span class=\"hljs-built_in\">pop</span>();\r\n\r\n        <span class=\"hljs-keyword\">if</span> (checked[act] == GREY) {\r\n            <span class=\"hljs-comment\">/// push the node to the final result vector</span>\r\n            traversed_path.<span class=\"hljs-built_in\">push_back</span>(act + <span class=\"hljs-number\">1</span>);\r\n\r\n            <span class=\"hljs-comment\">/// exploring the neighbours of the current node</span>\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it : graph[act]) {\r\n                stack.<span class=\"hljs-built_in\">push</span>(it);\r\n                <span class=\"hljs-keyword\">if</span> (checked[it] != BLACK) {\r\n                    checked[it] = GREY;\r\n                }\r\n            }\r\n            checked[act] = BLACK;  <span class=\"hljs-comment\">/// Node has been explored</span>\r\n        }\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> traversed_path;\r\n}\r\n}  <span class=\"hljs-comment\">// namespace depth_first_search</span>\r\n}  <span class=\"hljs-comment\">// namespace graph</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Self-test implementations\r\n * @returns none\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">tests</span><span class=\"hljs-params\">()</span> </span>{\r\n\t<span class=\"hljs-type\">size_t</span> start_pos;\r\n\r\n\t<span class=\"hljs-comment\">/// Test 1</span>\r\n\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Case 1: &quot;</span> &lt;&lt; std::endl;\r\n\tstart_pos = <span class=\"hljs-number\">1</span>;\r\n\tstd::vector&lt;std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; &gt; <span class=\"hljs-built_in\">g1</span>(<span class=\"hljs-number\">3</span>, std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">size_t</span>&gt;());\r\n\r\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g1, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\r\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g1, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\r\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g1, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>);\r\n\r\n\tstd::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; expected1 {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}; <span class=\"hljs-comment\">/// for the above sample data, this is the expected output</span>\r\n\t<span class=\"hljs-built_in\">assert</span>(graph::depth_first_search::<span class=\"hljs-built_in\">dfs</span>(g1, start_pos - <span class=\"hljs-number\">1</span>) == expected1);\r\n\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Passed&quot;</span> &lt;&lt; std::endl;\r\n\r\n\t<span class=\"hljs-comment\">/// Test 2</span>\r\n\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Case 2: &quot;</span> &lt;&lt; std::endl;\r\n\tstart_pos = <span class=\"hljs-number\">1</span>;\r\n\tstd::vector&lt;std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; &gt; <span class=\"hljs-built_in\">g2</span>(<span class=\"hljs-number\">4</span>, std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">size_t</span>&gt;());\r\n\r\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g2, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\r\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g2, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);\r\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g2, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>);\r\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g2, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>);\r\n\r\n\tstd::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; expected2 {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>}; <span class=\"hljs-comment\">/// for the above sample data, this is the expected output</span>\r\n\t<span class=\"hljs-built_in\">assert</span>(graph::depth_first_search::<span class=\"hljs-built_in\">dfs</span>(g2, start_pos - <span class=\"hljs-number\">1</span>) == expected2);\r\n\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Passed&quot;</span> &lt;&lt; std::endl;\r\n\r\n\t<span class=\"hljs-comment\">/// Test 3</span>\r\n\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Case 3: &quot;</span> &lt;&lt; std::endl;\r\n\tstart_pos = <span class=\"hljs-number\">2</span>;\r\n\tstd::vector&lt;std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; &gt; <span class=\"hljs-built_in\">g3</span>(<span class=\"hljs-number\">4</span>, std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">size_t</span>&gt;());\r\n\r\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g3, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\r\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g3, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);\r\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g3, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>);\r\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g3, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>);\r\n\r\n\tstd::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; expected3 {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>}; <span class=\"hljs-comment\">/// for the above sample data, this is the expected output</span>\r\n\t<span class=\"hljs-built_in\">assert</span>(graph::depth_first_search::<span class=\"hljs-built_in\">dfs</span>(g3, start_pos - <span class=\"hljs-number\">1</span>) == expected3);\r\n\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Passed&quot;</span> &lt;&lt; std::endl;\r\n\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-built_in\">tests</span>();  <span class=\"hljs-comment\">// execute the tests</span>\r\n\r\n    <span class=\"hljs-type\">size_t</span> vertices = <span class=\"hljs-number\">0</span>, edges = <span class=\"hljs-number\">0</span>, start_pos = <span class=\"hljs-number\">1</span>;\r\n\tstd::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; traversal;\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the Vertices : &quot;</span>;\r\n\tstd::cin &gt;&gt; vertices;\r\n\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the Edges : &quot;</span>;\r\n\tstd::cin &gt;&gt; edges;\r\n\r\n    <span class=\"hljs-comment\">/// creating a graph</span>\r\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; &gt; <span class=\"hljs-built_in\">adj</span>(vertices, std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">size_t</span>&gt;());\r\n\r\n    <span class=\"hljs-comment\">/// taking input for the edges</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the vertices which have edges between them : &quot;</span> &lt;&lt; std::endl;\r\n\t<span class=\"hljs-keyword\">while</span> (edges--) {\r\n\t\t<span class=\"hljs-type\">size_t</span> u = <span class=\"hljs-number\">0</span>, v = <span class=\"hljs-number\">0</span>;\r\n\t\tstd::cin &gt;&gt; u &gt;&gt; v;\r\n\t\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj, u, v);\r\n\t}\r\n\r\n    <span class=\"hljs-comment\">/// taking input for the starting position</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the starting vertex [1,n]: &quot;</span> &lt;&lt; std::endl;\r\n\tstd::cin &gt;&gt; start_pos;\r\n\tstart_pos -= <span class=\"hljs-number\">1</span>;\r\n\ttraversal = graph::depth_first_search::<span class=\"hljs-built_in\">dfs</span>(adj, start_pos);\r\n\r\n    <span class=\"hljs-comment\">/// Printing the order of traversal</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> x : traversal) {\r\n\t\tstd::cout &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&#x27; &#x27;</span>;\r\n\t}\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 1
    },
    {
      "name": "Saurav Uppoor",
      "email": "41644947+sauravUppoor@users.noreply.github.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}