{
  "slug": "kruskals-algorithm",
  "name": "Kruskal's Algorithm",
  "categories": [
    "graphs",
    "minimumspanningtree"
  ],
  "body": {},
  "implementations": {
    "c-sharp": {
      "dir": "./Algorithms/Graph/MinimumSpanningTree/Kruskal.cs",
      "url": "https:\\github.com\\TheAlgorithms\\C-Sharp\\tree\\master\\Algorithms\\Graph\\MinimumSpanningTree\\Kruskal.cs",
      "code": "<span class=\"hljs-keyword\">using</span> System;\r\n<span class=\"hljs-keyword\">using</span> System.Collections.Generic;\r\n<span class=\"hljs-keyword\">using</span> DataStructures.DisjointSet;\r\n\r\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">Algorithms.Graph.MinimumSpanningTree</span>\r\n{\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Algorithm to determine the minimum spanning forest of an undirected graph.</span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;remarks&gt;</span></span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Kruskal&#x27;s algorithm is a greedy algorithm that can determine the</span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     minimum spanning tree or minimum spanning forest of any undirected</span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     graph. Unlike Prim&#x27;s algorithm, Kruskal&#x27;s algorithm will work on</span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     graphs that are unconnected. This algorithm will always have a</span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     running time of O(E log V) where E is the number of edges and V is</span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     the number of vertices/nodes.</span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     More information: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm .</span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Pseudocode and analysis: https://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/primAlgor.htm .</span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/remarks&gt;</span></span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Kruskal</span>\r\n    {\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Determine the minimum spanning tree/forest of the given graph.</span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;adjacencyMatrix&quot;&gt;</span>Adjacency matrix representing the graph.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Adjacency matrix of the minimum spanning tree/forest.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">float</span>[,] Solve(<span class=\"hljs-built_in\">float</span>[,] adjacencyMatrix)\r\n        {\r\n            ValidateGraph(adjacencyMatrix);\r\n\r\n            <span class=\"hljs-keyword\">var</span> numNodes = adjacencyMatrix.GetLength(<span class=\"hljs-number\">0</span>);\r\n            <span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">set</span> = <span class=\"hljs-keyword\">new</span> DisjointSet&lt;<span class=\"hljs-built_in\">int</span>&gt;();\r\n            <span class=\"hljs-keyword\">var</span> nodes = <span class=\"hljs-keyword\">new</span> Node&lt;<span class=\"hljs-built_in\">int</span>&gt;[numNodes];\r\n            <span class=\"hljs-keyword\">var</span> edgeWeightList = <span class=\"hljs-keyword\">new</span> List&lt;<span class=\"hljs-built_in\">float</span>&gt;();\r\n            <span class=\"hljs-keyword\">var</span> nodeConnectList = <span class=\"hljs-keyword\">new</span> List&lt;(<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>)&gt;();\r\n\r\n            <span class=\"hljs-comment\">// Add nodes to disjoint set</span>\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numNodes; i++)\r\n            {\r\n                nodes[i] = <span class=\"hljs-keyword\">set</span>.MakeSet(i);\r\n            }\r\n\r\n            <span class=\"hljs-comment\">// Create lists with edge weights and associated connectivity</span>\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numNodes - <span class=\"hljs-number\">1</span>; i++)\r\n            {\r\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = i + <span class=\"hljs-number\">1</span>; j &lt; numNodes; j++)\r\n                {\r\n                    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">float</span>.IsFinite(adjacencyMatrix[i, j]))\r\n                    {\r\n                        edgeWeightList.Add(adjacencyMatrix[i, j]);\r\n                        nodeConnectList.Add((i, j));\r\n                    }\r\n                }\r\n            }\r\n\r\n            <span class=\"hljs-keyword\">var</span> edges = Solve(<span class=\"hljs-keyword\">set</span>, nodes, edgeWeightList.ToArray(), nodeConnectList.ToArray());\r\n\r\n            <span class=\"hljs-comment\">// Initialize minimum spanning tree</span>\r\n            <span class=\"hljs-keyword\">var</span> mst = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">float</span>[numNodes, numNodes];\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numNodes; i++)\r\n            {\r\n                mst[i, i] = <span class=\"hljs-built_in\">float</span>.PositiveInfinity;\r\n\r\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = i + <span class=\"hljs-number\">1</span>; j &lt; numNodes; j++)\r\n                {\r\n                    mst[i, j] = <span class=\"hljs-built_in\">float</span>.PositiveInfinity;\r\n                    mst[j, i] = <span class=\"hljs-built_in\">float</span>.PositiveInfinity;\r\n                }\r\n            }\r\n\r\n            <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> (node1, node2) <span class=\"hljs-keyword\">in</span> edges)\r\n            {\r\n                mst[node1, node2] = adjacencyMatrix[node1, node2];\r\n                mst[node2, node1] = adjacencyMatrix[node1, node2];\r\n            }\r\n\r\n            <span class=\"hljs-keyword\">return</span> mst;\r\n        }\r\n\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Determine the minimum spanning tree/forest of the given graph.</span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;adjacencyList&quot;&gt;</span>Adjacency list representing the graph.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Adjacency list of the minimum spanning tree/forest.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\r\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Dictionary&lt;<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">float</span>&gt;[] <span class=\"hljs-title\">Solve</span>(<span class=\"hljs-params\">Dictionary&lt;<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">float</span>&gt;[] adjacencyList</span>)</span>\r\n        {\r\n            ValidateGraph(adjacencyList);\r\n\r\n            <span class=\"hljs-keyword\">var</span> numNodes = adjacencyList.Length;\r\n            <span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">set</span> = <span class=\"hljs-keyword\">new</span> DisjointSet&lt;<span class=\"hljs-built_in\">int</span>&gt;();\r\n            <span class=\"hljs-keyword\">var</span> nodes = <span class=\"hljs-keyword\">new</span> Node&lt;<span class=\"hljs-built_in\">int</span>&gt;[numNodes];\r\n            <span class=\"hljs-keyword\">var</span> edgeWeightList = <span class=\"hljs-keyword\">new</span> List&lt;<span class=\"hljs-built_in\">float</span>&gt;();\r\n            <span class=\"hljs-keyword\">var</span> nodeConnectList = <span class=\"hljs-keyword\">new</span> List&lt;(<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>)&gt;();\r\n\r\n            <span class=\"hljs-comment\">// Add nodes to disjoint set and create list of edge weights and associated connectivity</span>\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numNodes; i++)\r\n            {\r\n                nodes[i] = <span class=\"hljs-keyword\">set</span>.MakeSet(i);\r\n\r\n                <span class=\"hljs-keyword\">foreach</span>(<span class=\"hljs-keyword\">var</span> (node, weight) <span class=\"hljs-keyword\">in</span> adjacencyList[i])\r\n                {\r\n                    edgeWeightList.Add(weight);\r\n                    nodeConnectList.Add((i, node));\r\n                }\r\n            }\r\n\r\n            <span class=\"hljs-keyword\">var</span> edges = Solve(<span class=\"hljs-keyword\">set</span>, nodes, edgeWeightList.ToArray(), nodeConnectList.ToArray());\r\n\r\n            <span class=\"hljs-comment\">// Create minimum spanning tree</span>\r\n            <span class=\"hljs-keyword\">var</span> mst = <span class=\"hljs-keyword\">new</span> Dictionary&lt;<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">float</span>&gt;[numNodes];\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numNodes; i++)\r\n            {\r\n                mst[i] = <span class=\"hljs-keyword\">new</span> Dictionary&lt;<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">float</span>&gt;();\r\n            }\r\n\r\n            <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> (node1, node2) <span class=\"hljs-keyword\">in</span> edges)\r\n            {\r\n                mst[node1].Add(node2, adjacencyList[node1][node2]);\r\n                mst[node2].Add(node1, adjacencyList[node1][node2]);\r\n            }\r\n\r\n            <span class=\"hljs-keyword\">return</span> mst;\r\n        }\r\n\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Ensure that the given graph is undirected.</span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;adj&quot;&gt;</span>Adjacency matrix of graph to check.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ValidateGraph</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">float</span>[,] adj</span>)</span>\r\n        {\r\n            <span class=\"hljs-keyword\">if</span> (adj.GetLength(<span class=\"hljs-number\">0</span>) != adj.GetLength(<span class=\"hljs-number\">1</span>))\r\n            {\r\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ArgumentException(<span class=\"hljs-string\">&quot;Matrix must be square!&quot;</span>);\r\n            }\r\n\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; adj.GetLength(<span class=\"hljs-number\">0</span>) - <span class=\"hljs-number\">1</span>; i++)\r\n            {\r\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = i + <span class=\"hljs-number\">1</span>; j &lt; adj.GetLength(<span class=\"hljs-number\">1</span>); j++)\r\n                {\r\n                    <span class=\"hljs-keyword\">if</span> (Math.Abs(adj[i, j] - adj[j, i]) &gt; <span class=\"hljs-number\">1e-6</span>)\r\n                    {\r\n                        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ArgumentException(<span class=\"hljs-string\">&quot;Matrix must be symmetric!&quot;</span>);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Ensure that the given graph is undirected.</span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;adj&quot;&gt;</span>Adjacency list of graph to check.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ValidateGraph</span>(<span class=\"hljs-params\">Dictionary&lt;<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">float</span>&gt;[] adj</span>)</span>\r\n        {\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; adj.Length; i++)\r\n            {\r\n                <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> edge <span class=\"hljs-keyword\">in</span> adj[i])\r\n                {\r\n                    <span class=\"hljs-keyword\">if</span> (!adj[edge.Key].ContainsKey(i) || Math.Abs(edge.Value - adj[edge.Key][i]) &gt; <span class=\"hljs-number\">1e-6</span>)\r\n                    {\r\n                        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ArgumentException(<span class=\"hljs-string\">&quot;Graph must be undirected!&quot;</span>);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Determine the minimum spanning tree/forest.</span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;set&quot;&gt;</span>Disjoint set needed for set operations.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;nodes&quot;&gt;</span>List of nodes in disjoint set associated with each node.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;edgeWeights&quot;&gt;</span>Weights of each edge.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;connections&quot;&gt;</span>Nodes associated with each item in the <span class=\"hljs-doctag\">&lt;paramref name=&quot;edgeWeights&quot;/&gt;</span> parameter.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Array of edges in the minimum spanning tree/forest.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\r\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> (<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span></span>)[] <span class=\"hljs-title\">Solve</span>(<span class=\"hljs-params\">DisjointSet&lt;<span class=\"hljs-built_in\">int</span>&gt; <span class=\"hljs-keyword\">set</span>, Node&lt;<span class=\"hljs-built_in\">int</span>&gt;[] nodes, <span class=\"hljs-built_in\">float</span>[] edgeWeights, (<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span></span>)[] connections)</span>\r\n        {\r\n            <span class=\"hljs-keyword\">var</span> edges = <span class=\"hljs-keyword\">new</span> List&lt;(<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>)&gt;();\r\n\r\n            Array.Sort(edgeWeights, connections);\r\n\r\n            <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> (node1, node2) <span class=\"hljs-keyword\">in</span> connections)\r\n            {\r\n                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">set</span>.FindSet(nodes[node1]) != <span class=\"hljs-keyword\">set</span>.FindSet(nodes[node2]))\r\n                {\r\n                    <span class=\"hljs-keyword\">set</span>.UnionSet(nodes[node1], nodes[node2]);\r\n                    edges.Add((node1, node2));\r\n                }\r\n            }\r\n\r\n            <span class=\"hljs-keyword\">return</span> edges.ToArray();\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "khalil2535",
      "email": "khalil2535@localhost",
      "commits": 1
    },
    {
      "name": "Mansi Mittal",
      "email": "m16mittal@gmail.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}