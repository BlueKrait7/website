{
  "slug": "pollard-rho",
  "name": "Pollard Rho",
  "categories": [
    "math"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "maths\\pollard_rho.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/maths\\pollard_rho.py",
      "code": "<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\r\n\r\n<span class=\"hljs-keyword\">from</span> math <span class=\"hljs-keyword\">import</span> gcd\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">pollard_rho</span>(<span class=\"hljs-params\">\r\n    num: <span class=\"hljs-built_in\">int</span>,\r\n    seed: <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">2</span>,\r\n    step: <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">1</span>,\r\n    attempts: <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">3</span>,\r\n</span>) -&gt; <span class=\"hljs-built_in\">int</span> | <span class=\"hljs-literal\">None</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Use Pollard&#x27;s Rho algorithm to return a nontrivial factor of ``num``.\r\n    The returned factor may be composite and require further factorization.\r\n    If the algorithm will return None if it fails to find a factor within\r\n    the specified number of attempts or within the specified number of steps.\r\n    If ``num`` is prime, this algorithm is guaranteed to return None.\r\n    https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm\r\n\r\n    &gt;&gt;&gt; pollard_rho(18446744073709551617)\r\n    274177\r\n    &gt;&gt;&gt; pollard_rho(97546105601219326301)\r\n    9876543191\r\n    &gt;&gt;&gt; pollard_rho(100)\r\n    2\r\n    &gt;&gt;&gt; pollard_rho(17)\r\n    &gt;&gt;&gt; pollard_rho(17**3)\r\n    17\r\n    &gt;&gt;&gt; pollard_rho(17**3, attempts=1)\r\n    &gt;&gt;&gt; pollard_rho(3*5*7)\r\n    21\r\n    &gt;&gt;&gt; pollard_rho(1)\r\n    Traceback (most recent call last):\r\n        ...\r\n    ValueError: The input value cannot be less than 2\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-comment\"># A value less than 2 can cause an infinite loop in the algorithm.</span>\r\n    <span class=\"hljs-keyword\">if</span> num &lt; <span class=\"hljs-number\">2</span>:\r\n        <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&quot;The input value cannot be less than 2&quot;</span>)\r\n\r\n    <span class=\"hljs-comment\"># Because of the relationship between ``f(f(x))`` and ``f(x)``, this</span>\r\n    <span class=\"hljs-comment\"># algorithm struggles to find factors that are divisible by two.</span>\r\n    <span class=\"hljs-comment\"># As a workaround, we specifically check for two and even inputs.</span>\r\n    <span class=\"hljs-comment\">#   See: https://math.stackexchange.com/a/2856214/165820</span>\r\n    <span class=\"hljs-keyword\">if</span> num &gt; <span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">and</span> num % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>\r\n\r\n    <span class=\"hljs-comment\"># Pollard&#x27;s Rho algorithm requires a function that returns pseudorandom</span>\r\n    <span class=\"hljs-comment\"># values between 0 &lt;= X &lt; ``num``.  It doesn&#x27;t need to be random in the</span>\r\n    <span class=\"hljs-comment\"># sense that the output value is cryptographically secure or difficult</span>\r\n    <span class=\"hljs-comment\"># to calculate, it only needs to be random in the sense that all output</span>\r\n    <span class=\"hljs-comment\"># values should be equally likely to appear.</span>\r\n    <span class=\"hljs-comment\"># For this reason, Pollard suggested using ``f(x) = (x**2 - 1) % num``</span>\r\n    <span class=\"hljs-comment\"># However, the success of Pollard&#x27;s algorithm isn&#x27;t guaranteed and is</span>\r\n    <span class=\"hljs-comment\"># determined in part by the initial seed and the chosen random function.</span>\r\n    <span class=\"hljs-comment\"># To make retries easier, we will instead use ``f(x) = (x**2 + C) % num``</span>\r\n    <span class=\"hljs-comment\"># where ``C`` is a value that we can modify between each attempt.</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">rand_fn</span>(<span class=\"hljs-params\">value: <span class=\"hljs-built_in\">int</span>, step: <span class=\"hljs-built_in\">int</span>, modulus: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Returns a pseudorandom value modulo ``modulus`` based on the\r\n        input ``value`` and attempt-specific ``step`` size.\r\n\r\n        &gt;&gt;&gt; rand_fn(0, 0, 0)\r\n        Traceback (most recent call last):\r\n            ...\r\n        ZeroDivisionError: integer division or modulo by zero\r\n        &gt;&gt;&gt; rand_fn(1, 2, 3)\r\n        0\r\n        &gt;&gt;&gt; rand_fn(0, 10, 7)\r\n        3\r\n        &gt;&gt;&gt; rand_fn(1234, 1, 17)\r\n        16\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-built_in\">pow</span>(value, <span class=\"hljs-number\">2</span>) + step) % modulus\r\n\r\n    <span class=\"hljs-keyword\">for</span> attempt <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(attempts):\r\n        <span class=\"hljs-comment\"># These track the position within the cycle detection logic.</span>\r\n        tortoise = seed\r\n        hare = seed\r\n\r\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\r\n            <span class=\"hljs-comment\"># At each iteration, the tortoise moves one step and the hare moves two.</span>\r\n            tortoise = rand_fn(tortoise, step, num)\r\n            hare = rand_fn(hare, step, num)\r\n            hare = rand_fn(hare, step, num)\r\n\r\n            <span class=\"hljs-comment\"># At some point both the tortoise and the hare will enter a cycle whose</span>\r\n            <span class=\"hljs-comment\"># length ``p`` is a divisor of ``num``.  Once in that cycle, at some point</span>\r\n            <span class=\"hljs-comment\"># the tortoise and hare will end up on the same value modulo ``p``.</span>\r\n            <span class=\"hljs-comment\"># We can detect when this happens because the position difference between</span>\r\n            <span class=\"hljs-comment\"># the tortoise and the hare will share a common divisor with ``num``.</span>\r\n            divisor = gcd(hare - tortoise, num)\r\n\r\n            <span class=\"hljs-keyword\">if</span> divisor == <span class=\"hljs-number\">1</span>:\r\n                <span class=\"hljs-comment\"># No common divisor yet, just keep searching.</span>\r\n                <span class=\"hljs-keyword\">continue</span>\r\n            <span class=\"hljs-keyword\">else</span>:\r\n                <span class=\"hljs-comment\"># We found a common divisor!</span>\r\n                <span class=\"hljs-keyword\">if</span> divisor == num:\r\n                    <span class=\"hljs-comment\"># Unfortunately, the divisor is ``num`` itself and is useless.</span>\r\n                    <span class=\"hljs-keyword\">break</span>\r\n                <span class=\"hljs-keyword\">else</span>:\r\n                    <span class=\"hljs-comment\"># The divisor is a nontrivial factor of ``num``!</span>\r\n                    <span class=\"hljs-keyword\">return</span> divisor\r\n\r\n        <span class=\"hljs-comment\"># If we made it here, then this attempt failed.</span>\r\n        <span class=\"hljs-comment\"># We need to pick a new starting seed for the tortoise and hare</span>\r\n        <span class=\"hljs-comment\"># in addition to a new step value for the random function.</span>\r\n        <span class=\"hljs-comment\"># To keep this example implementation deterministic, the</span>\r\n        <span class=\"hljs-comment\"># new values will be generated based on currently available</span>\r\n        <span class=\"hljs-comment\"># values instead of using something like ``random.randint``.</span>\r\n\r\n        <span class=\"hljs-comment\"># We can use the hare&#x27;s position as the new seed.</span>\r\n        <span class=\"hljs-comment\"># This is actually what Richard Brent&#x27;s the &quot;optimized&quot; variant does.</span>\r\n        seed = hare\r\n\r\n        <span class=\"hljs-comment\"># The new step value for the random function can just be incremented.</span>\r\n        <span class=\"hljs-comment\"># At first the results will be similar to what the old function would</span>\r\n        <span class=\"hljs-comment\"># have produced, but the value will quickly diverge after a bit.</span>\r\n        step += <span class=\"hljs-number\">1</span>\r\n\r\n    <span class=\"hljs-comment\"># We haven&#x27;t found a divisor within the requested number of attempts.</span>\r\n    <span class=\"hljs-comment\"># We were unlucky or ``num`` itself is actually prime.</span>\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    <span class=\"hljs-keyword\">import</span> argparse\r\n\r\n    parser = argparse.ArgumentParser()\r\n    parser.add_argument(\r\n        <span class=\"hljs-string\">&quot;num&quot;</span>,\r\n        <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-built_in\">int</span>,\r\n        <span class=\"hljs-built_in\">help</span>=<span class=\"hljs-string\">&quot;The value to find a divisor of&quot;</span>,\r\n    )\r\n    parser.add_argument(\r\n        <span class=\"hljs-string\">&quot;--attempts&quot;</span>,\r\n        <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-built_in\">int</span>,\r\n        default=<span class=\"hljs-number\">3</span>,\r\n        <span class=\"hljs-built_in\">help</span>=<span class=\"hljs-string\">&quot;The number of attempts before giving up&quot;</span>,\r\n    )\r\n    args = parser.parse_args()\r\n\r\n    divisor = pollard_rho(args.num, attempts=args.attempts)\r\n    <span class=\"hljs-keyword\">if</span> divisor <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;<span class=\"hljs-subst\">{args.num}</span> is probably prime&quot;</span>)\r\n    <span class=\"hljs-keyword\">else</span>:\r\n        quotient = args.num // divisor\r\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;<span class=\"hljs-subst\">{args.num}</span> = <span class=\"hljs-subst\">{divisor}</span> * <span class=\"hljs-subst\">{quotient}</span>&quot;</span>)\r\n"
    }
  },
  "contributors": [
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 1
    },
    {
      "name": "Marcus T",
      "email": "marcus.truscello@gmail.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}