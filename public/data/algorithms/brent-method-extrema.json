{
  "slug": "brent-method-extrema",
  "name": "Brent Method Extrema",
  "categories": [
    "numericalmethods"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "numerical_methods\\brent_method_extrema.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/numerical_methods\\brent_method_extrema.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * \\file\r\n * \\brief Find real extrema of a univariate real function in a given interval\r\n * using [Brent&#x27;s method](https://en.wikipedia.org/wiki/Brent%27s_method).\r\n *\r\n * Refer the algorithm discoverer&#x27;s publication\r\n * [online](https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf) and also\r\n * associated book:\r\n * &gt; R. P. Brent, Algorithms for Minimization without\r\n * &gt; Derivatives, Prentice-Hall, Englewood Cliffs, New Jersey, 1973\r\n *\r\n * \\see golden_search_extrema.cpp\r\n *\r\n * \\author [Krishna Vedala](https://github.com/kvedala)\r\n */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> _USE_MATH_DEFINES  <span class=\"hljs-comment\">///&lt; required for MS Visual C++</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;functional&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;limits&gt;</span></span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> EPSILON \\</span>\r\n    std::<span class=\"hljs-built_in\">sqrt</span>(  \\\r\n        std::numeric_limits&lt;<span class=\"hljs-type\">double</span>&gt;::<span class=\"hljs-built_in\">epsilon</span>())  <span class=\"hljs-comment\">///&lt; system accuracy limit</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Get the real root of a function in the given interval.\r\n *\r\n * @param f function to get root for\r\n * @param lim_a lower limit of search window\r\n * @param lim_b upper limit of search window\r\n * @return root found in the interval\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">get_minima</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::function&lt;<span class=\"hljs-type\">double</span>(<span class=\"hljs-type\">double</span>)&gt; &amp;f, <span class=\"hljs-type\">double</span> lim_a,\r\n                  <span class=\"hljs-type\">double</span> lim_b)</span> </span>{\r\n    <span class=\"hljs-type\">uint32_t</span> iters = <span class=\"hljs-number\">0</span>;\r\n\r\n    <span class=\"hljs-keyword\">if</span> (lim_a &gt; lim_b) {\r\n        std::<span class=\"hljs-built_in\">swap</span>(lim_a, lim_b);\r\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (std::<span class=\"hljs-built_in\">abs</span>(lim_a - lim_b) &lt;= EPSILON) {\r\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Search range must be greater than &quot;</span> &lt;&lt; EPSILON &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\r\n        <span class=\"hljs-keyword\">return</span> lim_a;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// golden ratio value</span>\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> M_GOLDEN_RATIO = (<span class=\"hljs-number\">3.f</span> - std::<span class=\"hljs-built_in\">sqrt</span>(<span class=\"hljs-number\">5.f</span>)) / <span class=\"hljs-number\">2.f</span>;\r\n\r\n    <span class=\"hljs-type\">double</span> v = lim_a + M_GOLDEN_RATIO * (lim_b - lim_a);\r\n    <span class=\"hljs-type\">double</span> u, w = v, x = v;\r\n    <span class=\"hljs-type\">double</span> fu, fv = <span class=\"hljs-built_in\">f</span>(v);\r\n    <span class=\"hljs-type\">double</span> fw = fv, fx = fv;\r\n\r\n    <span class=\"hljs-type\">double</span> mid_point = (lim_a + lim_b) / <span class=\"hljs-number\">2.f</span>;\r\n    <span class=\"hljs-type\">double</span> p = <span class=\"hljs-number\">0</span>, q = <span class=\"hljs-number\">0</span>, r = <span class=\"hljs-number\">0</span>;\r\n\r\n    <span class=\"hljs-type\">double</span> d, e = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">double</span> tolerance, tolerance2;\r\n\r\n    <span class=\"hljs-keyword\">do</span> {\r\n        mid_point = (lim_a + lim_b) / <span class=\"hljs-number\">2.f</span>;\r\n        tolerance = EPSILON * std::<span class=\"hljs-built_in\">abs</span>(x);\r\n        tolerance2 = <span class=\"hljs-number\">2</span> * tolerance;\r\n\r\n        <span class=\"hljs-keyword\">if</span> (std::<span class=\"hljs-built_in\">abs</span>(e) &gt; tolerance2) {\r\n            <span class=\"hljs-comment\">// fit parabola</span>\r\n            r = (x - w) * (fx - fv);\r\n            q = (x - v) * (fx - fw);\r\n            p = (x - v) * q - (x - w) * r;\r\n            q = <span class=\"hljs-number\">2.f</span> * (q - r);\r\n            <span class=\"hljs-keyword\">if</span> (q &gt; <span class=\"hljs-number\">0</span>)\r\n                p = -p;\r\n            <span class=\"hljs-keyword\">else</span>\r\n                q = -q;\r\n            r = e;\r\n            e = d;\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">if</span> (std::<span class=\"hljs-built_in\">abs</span>(p) &lt; std::<span class=\"hljs-built_in\">abs</span>(<span class=\"hljs-number\">0.5</span> * q * r) &amp;&amp; p &lt; q * (lim_b - x)) {\r\n            <span class=\"hljs-comment\">// parabolic interpolation step</span>\r\n            d = p / q;\r\n            u = x + d;\r\n            <span class=\"hljs-keyword\">if</span> (u - lim_a &lt; tolerance2 || lim_b - u &lt; tolerance2)\r\n                d = x &lt; mid_point ? tolerance : -tolerance;\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            <span class=\"hljs-comment\">// golden section interpolation step</span>\r\n            e = (x &lt; mid_point ? lim_b : lim_a) - x;\r\n            d = M_GOLDEN_RATIO * e;\r\n        }\r\n\r\n        <span class=\"hljs-comment\">// evaluate not too close to x</span>\r\n        <span class=\"hljs-keyword\">if</span> (std::<span class=\"hljs-built_in\">abs</span>(d) &gt;= tolerance)\r\n            u = d;\r\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (d &gt; <span class=\"hljs-number\">0</span>)\r\n            u = tolerance;\r\n        <span class=\"hljs-keyword\">else</span>\r\n            u = -tolerance;\r\n        u += x;\r\n        fu = <span class=\"hljs-built_in\">f</span>(u);\r\n\r\n        <span class=\"hljs-comment\">// update variables</span>\r\n        <span class=\"hljs-keyword\">if</span> (fu &lt;= fx) {\r\n            <span class=\"hljs-keyword\">if</span> (u &lt; x)\r\n                lim_b = x;\r\n            <span class=\"hljs-keyword\">else</span>\r\n                lim_a = x;\r\n            v = w;\r\n            fv = fw;\r\n            w = x;\r\n            fw = fx;\r\n            x = u;\r\n            fx = fu;\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            <span class=\"hljs-keyword\">if</span> (u &lt; x)\r\n                lim_a = u;\r\n            <span class=\"hljs-keyword\">else</span>\r\n                lim_b = u;\r\n            <span class=\"hljs-keyword\">if</span> (fu &lt;= fw || x == w) {\r\n                v = w;\r\n                fv = fw;\r\n                w = u;\r\n                fw = fu;\r\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (fu &lt;= fv || v == x || v == w) {\r\n                v = u;\r\n                fv = fu;\r\n            }\r\n        }\r\n\r\n        iters++;\r\n    } <span class=\"hljs-keyword\">while</span> (std::<span class=\"hljs-built_in\">abs</span>(x - mid_point) &gt; (tolerance - (lim_b - lim_a) / <span class=\"hljs-number\">2.f</span>));\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot; (iters: &quot;</span> &lt;&lt; iters &lt;&lt; <span class=\"hljs-string\">&quot;) &quot;</span>;\r\n\r\n    <span class=\"hljs-keyword\">return</span> x;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Test function to find root for the function\r\n * \\f$f(x)= (x-2)^2\\f$\r\n * in the interval \\f$[1,5]\\f$\r\n * \\n Expected result = 2\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-comment\">// define the function to minimize as a lambda function</span>\r\n    std::function&lt;<span class=\"hljs-type\">double</span>(<span class=\"hljs-type\">double</span>)&gt; f1 = [](<span class=\"hljs-type\">double</span> x) {\r\n        <span class=\"hljs-built_in\">return</span> (x - <span class=\"hljs-number\">2</span>) * (x - <span class=\"hljs-number\">2</span>);\r\n    };\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1.... &quot;</span>;\r\n\r\n    <span class=\"hljs-type\">double</span> minima = <span class=\"hljs-built_in\">get_minima</span>(f1, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">5</span>);\r\n\r\n    std::cout &lt;&lt; minima &lt;&lt; <span class=\"hljs-string\">&quot;...&quot;</span>;\r\n\r\n    <span class=\"hljs-built_in\">assert</span>(std::<span class=\"hljs-built_in\">abs</span>(minima - <span class=\"hljs-number\">2</span>) &lt; EPSILON);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;passed\\n&quot;</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Test function to find root for the function\r\n * \\f$f(x)= x^{\\frac{1}{x}}\\f$\r\n * in the interval \\f$[-2,10]\\f$\r\n * \\n Expected result: \\f$e\\approx 2.71828182845904509\\f$\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-comment\">// define the function to maximize as a lambda function</span>\r\n    <span class=\"hljs-comment\">// since we are maximixing, we negated the function return value</span>\r\n    std::function&lt;<span class=\"hljs-type\">double</span>(<span class=\"hljs-type\">double</span>)&gt; func = [](<span class=\"hljs-type\">double</span> x) {\r\n        <span class=\"hljs-keyword\">return</span> -std::<span class=\"hljs-built_in\">pow</span>(x, <span class=\"hljs-number\">1.f</span> / x);\r\n    };\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2.... &quot;</span>;\r\n\r\n    <span class=\"hljs-type\">double</span> minima = <span class=\"hljs-built_in\">get_minima</span>(func, <span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">5</span>);\r\n\r\n    std::cout &lt;&lt; minima &lt;&lt; <span class=\"hljs-string\">&quot; (&quot;</span> &lt;&lt; M_E &lt;&lt; <span class=\"hljs-string\">&quot;)...&quot;</span>;\r\n\r\n    <span class=\"hljs-built_in\">assert</span>(std::<span class=\"hljs-built_in\">abs</span>(minima - M_E) &lt; EPSILON);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;passed\\n&quot;</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Test function to find *maxima* for the function\r\n * \\f$f(x)= \\cos x\\f$\r\n * in the interval \\f$[0,12]\\f$\r\n * \\n Expected result: \\f$\\pi\\approx 3.14159265358979312\\f$\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test3</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-comment\">// define the function to maximize as a lambda function</span>\r\n    <span class=\"hljs-comment\">// since we are maximixing, we negated the function return value</span>\r\n    std::function&lt;<span class=\"hljs-type\">double</span>(<span class=\"hljs-type\">double</span>)&gt; func = [](<span class=\"hljs-type\">double</span> x) { <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">cos</span>(x); };\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 3.... &quot;</span>;\r\n\r\n    <span class=\"hljs-type\">double</span> minima = <span class=\"hljs-built_in\">get_minima</span>(func, <span class=\"hljs-number\">-4</span>, <span class=\"hljs-number\">12</span>);\r\n\r\n    std::cout &lt;&lt; minima &lt;&lt; <span class=\"hljs-string\">&quot; (&quot;</span> &lt;&lt; M_PI &lt;&lt; <span class=\"hljs-string\">&quot;)...&quot;</span>;\r\n\r\n    <span class=\"hljs-built_in\">assert</span>(std::<span class=\"hljs-built_in\">abs</span>(minima - M_PI) &lt; EPSILON);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;passed\\n&quot;</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Main function */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    std::cout.<span class=\"hljs-built_in\">precision</span>(<span class=\"hljs-number\">18</span>);\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Computations performed with machine epsilon: &quot;</span> &lt;&lt; EPSILON\r\n              &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\r\n\r\n    <span class=\"hljs-built_in\">test1</span>();\r\n    <span class=\"hljs-built_in\">test2</span>();\r\n    <span class=\"hljs-built_in\">test3</span>();\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 5
    }
  ],
  "explanationUrl": {}
}