{
  "slug": "max-flow-with-ford-fulkerson-and-edmond-karp-algo",
  "name": "Max Flow with Ford Fulkerson and Edmond Karp Algo",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "graph\\max_flow_with_ford_fulkerson_and_edmond_karp_algo.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph\\max_flow_with_ford_fulkerson_and_edmond_karp_algo.cpp",
      "code": "<span class=\"hljs-comment\">/*\r\n * Author: Amit Kumar\r\n * Created: May 24, 2020\r\n * Copyright: 2020, Open-Source\r\n * Last Modified: May 25, 2020\r\n */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bitset&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;limits&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;tuple&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;utility&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\r\n<span class=\"hljs-comment\">// std::max capacity of node in graph</span>\r\n<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> MAXN = <span class=\"hljs-number\">505</span>;\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span> {\r\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; residual_capacity, capacity;\r\n    <span class=\"hljs-type\">int</span> total_nodes = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">int</span> total_edges = <span class=\"hljs-number\">0</span>, source = <span class=\"hljs-number\">0</span>, sink = <span class=\"hljs-number\">0</span>;\r\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; parent;\r\n    std::vector&lt;std::tuple&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; &gt; edge_participated;\r\n    std::bitset&lt;MAXN&gt; visited;\r\n    <span class=\"hljs-type\">int</span> max_flow = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">bfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> source, <span class=\"hljs-type\">int</span> sink)</span> </span>{  <span class=\"hljs-comment\">//  to find the augmented - path</span>\r\n        visited.<span class=\"hljs-built_in\">reset</span>();\r\n        std::queue&lt;<span class=\"hljs-type\">int</span>&gt; q;\r\n        q.<span class=\"hljs-built_in\">push</span>(source);\r\n        <span class=\"hljs-type\">bool</span> is_path_found = <span class=\"hljs-literal\">false</span>;\r\n        <span class=\"hljs-keyword\">while</span> (q.<span class=\"hljs-built_in\">empty</span>() == <span class=\"hljs-literal\">false</span> &amp;&amp; is_path_found == <span class=\"hljs-literal\">false</span>) {\r\n            <span class=\"hljs-type\">int</span> current_node = q.<span class=\"hljs-built_in\">front</span>();\r\n            visited.<span class=\"hljs-built_in\">set</span>(current_node);\r\n            q.<span class=\"hljs-built_in\">pop</span>();\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; total_nodes; ++i) {\r\n                <span class=\"hljs-keyword\">if</span> (residual_capacity[current_node][i] &gt; <span class=\"hljs-number\">0</span> &amp;&amp; !visited[i]) {\r\n                    visited.<span class=\"hljs-built_in\">set</span>(i);\r\n                    parent[i] = current_node;\r\n                    <span class=\"hljs-keyword\">if</span> (i == sink) {\r\n                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n                    }\r\n                    q.<span class=\"hljs-built_in\">push</span>(i);\r\n                }\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n    }\r\n\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_graph</span><span class=\"hljs-params\">()</span> </span>{\r\n        std::cin &gt;&gt; total_nodes &gt;&gt; total_edges &gt;&gt; source &gt;&gt; sink;\r\n        parent = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(total_nodes, <span class=\"hljs-number\">-1</span>);\r\n        capacity = residual_capacity = std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt;(\r\n            total_nodes, std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(total_nodes));\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> start = <span class=\"hljs-number\">0</span>, destination = <span class=\"hljs-number\">0</span>, capacity_ = <span class=\"hljs-number\">0</span>, i = <span class=\"hljs-number\">0</span>;\r\n             i &lt; total_edges; ++i) {\r\n            std::cin &gt;&gt; start &gt;&gt; destination &gt;&gt; capacity_;\r\n            residual_capacity[start][destination] = capacity_;\r\n            capacity[start][destination] = capacity_;\r\n        }\r\n    }\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ford_fulkerson</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">bfs</span>(source, sink)) {\r\n            <span class=\"hljs-type\">int</span> current_node = sink;\r\n            <span class=\"hljs-type\">int</span> flow = std::numeric_limits&lt;<span class=\"hljs-type\">int</span>&gt;::<span class=\"hljs-built_in\">max</span>();\r\n            <span class=\"hljs-keyword\">while</span> (current_node != source) {\r\n                <span class=\"hljs-type\">int</span> parent_ = parent[current_node];\r\n                flow = std::<span class=\"hljs-built_in\">min</span>(flow, residual_capacity[parent_][current_node]);\r\n                current_node = parent_;\r\n            }\r\n            current_node = sink;\r\n            max_flow += flow;\r\n            <span class=\"hljs-keyword\">while</span> (current_node != source) {\r\n                <span class=\"hljs-type\">int</span> parent_ = parent[current_node];\r\n                residual_capacity[parent_][current_node] -= flow;\r\n                residual_capacity[current_node][parent_] += flow;\r\n                current_node = parent_;\r\n            }\r\n        }\r\n    }\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print_flow_info</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; total_nodes; ++i) {\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; total_nodes; ++j) {\r\n                <span class=\"hljs-keyword\">if</span> (capacity[i][j] &amp;&amp;\r\n                    residual_capacity[i][j] &lt; capacity[i][j]) {\r\n                    edge_participated.<span class=\"hljs-built_in\">emplace_back</span>(std::<span class=\"hljs-built_in\">make_tuple</span>(\r\n                        i, j, capacity[i][j] - residual_capacity[i][j]));\r\n                }\r\n            }\r\n        }\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nNodes : &quot;</span> &lt;&lt; total_nodes &lt;&lt; <span class=\"hljs-string\">&quot;\\nMax flow: &quot;</span> &lt;&lt; max_flow\r\n                  &lt;&lt; <span class=\"hljs-string\">&quot;\\nEdge present in flow: &quot;</span> &lt;&lt; edge_participated.<span class=\"hljs-built_in\">size</span>()\r\n                  &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nSource\\tDestination\\tCapacity\\total_nodes&quot;</span>;\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span>&amp; edge_data : edge_participated) {\r\n            <span class=\"hljs-type\">int</span> source = <span class=\"hljs-number\">0</span>, destination = <span class=\"hljs-number\">0</span>, capacity_ = <span class=\"hljs-number\">0</span>;\r\n            std::<span class=\"hljs-built_in\">tie</span>(source, destination, capacity_) = edge_data;\r\n            std::cout &lt;&lt; source &lt;&lt; <span class=\"hljs-string\">&quot;\\t&quot;</span> &lt;&lt; destination &lt;&lt; <span class=\"hljs-string\">&quot;\\t\\t&quot;</span> &lt;&lt; capacity_\r\n                      &lt;&lt; <span class=\"hljs-string\">&#x27;\\t&#x27;</span>;\r\n        }\r\n    }\r\n};\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-comment\">/*\r\n       Input Graph: (for testing )\r\n        4 5 0 3\r\n        0 1 10\r\n        1 2 1\r\n        1 3 1\r\n        0 2 1\r\n        2 3 10\r\n     */</span>\r\n    Graph graph;\r\n    graph.<span class=\"hljs-built_in\">set_graph</span>();\r\n    graph.ford_fulkerson();\r\n    graph.<span class=\"hljs-built_in\">print_flow_info</span>();\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Amit Kumar",
      "email": "offamitkumar@gmail.com",
      "commits": 1
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 3
    }
  ],
  "explanationUrl": {}
}