{
  "slug": "bst-recursive-generic",
  "name": "BST Recursive Generic",
  "categories": [
    "datastructures",
    "tree"
  ],
  "body": {},
  "implementations": {
    "java": {
      "dir": "src\\main\\java\\com\\thealgorithms\\datastructures\\trees\\BSTRecursiveGeneric.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src\\main\\java\\com\\thealgorithms\\datastructures\\trees\\BSTRecursiveGeneric.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.datastructures.trees;\r\n\r\n<span class=\"hljs-keyword\">import</span> java.util.ArrayList;\r\n<span class=\"hljs-keyword\">import</span> java.util.List;\r\n\r\n<span class=\"hljs-comment\">/**\r\n * &lt;h1&gt;Binary Search Tree (Recursive) Generic Type Implementation&lt;/h1&gt;\r\n *\r\n * &lt;p&gt;\r\n * A recursive implementation of generic type BST.\r\n *\r\n * Reference: https://en.wikipedia.org/wiki/Binary_search_tree\r\n * &lt;/p&gt;\r\n *\r\n * <span class=\"hljs-doctag\">@author</span> [Madhur Panwar](https://github.com/mdrpanwar)\r\n */</span>\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BSTRecursiveGeneric</span>&lt;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Comparable</span>&lt;T&gt;&gt; {\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * only data member is root of BST\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> Node&lt;T&gt; root;\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Constructor use to initialize node as null\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">BSTRecursiveGeneric</span><span class=\"hljs-params\">()</span> {\r\n        root = <span class=\"hljs-literal\">null</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * main function for testing\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\r\n        System.out.println(<span class=\"hljs-string\">&quot;Testing for integer data...&quot;</span>);\r\n        <span class=\"hljs-comment\">// Integer</span>\r\n        BSTRecursiveGeneric&lt;Integer&gt; integerTree = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BSTRecursiveGeneric</span>&lt;Integer&gt;();\r\n\r\n        integerTree.add(<span class=\"hljs-number\">5</span>);\r\n        integerTree.add(<span class=\"hljs-number\">10</span>);\r\n        integerTree.add(<span class=\"hljs-number\">9</span>);\r\n        <span class=\"hljs-keyword\">assert</span> !integerTree.find(<span class=\"hljs-number\">4</span>) : <span class=\"hljs-string\">&quot;4 is not yet present in BST&quot;</span>;\r\n        <span class=\"hljs-keyword\">assert</span> integerTree.find(<span class=\"hljs-number\">10</span>) : <span class=\"hljs-string\">&quot;10 should be present in BST&quot;</span>;\r\n        integerTree.remove(<span class=\"hljs-number\">9</span>);\r\n        <span class=\"hljs-keyword\">assert</span> !integerTree.find(<span class=\"hljs-number\">9</span>) : <span class=\"hljs-string\">&quot;9 was just deleted from BST&quot;</span>;\r\n        integerTree.remove(<span class=\"hljs-number\">1</span>);\r\n        <span class=\"hljs-keyword\">assert</span> !integerTree.find(<span class=\"hljs-number\">1</span>) : <span class=\"hljs-string\">&quot;Since 1 was not present so find deleting would do no change&quot;</span>;\r\n        integerTree.add(<span class=\"hljs-number\">20</span>);\r\n        integerTree.add(<span class=\"hljs-number\">70</span>);\r\n        <span class=\"hljs-keyword\">assert</span> integerTree.find(<span class=\"hljs-number\">70</span>) : <span class=\"hljs-string\">&quot;70 was inserted but not found&quot;</span>;\r\n        <span class=\"hljs-comment\">/*\r\n     Will print in following order\r\n     5 10 20 70\r\n         */</span>\r\n        integerTree.inorder();\r\n        System.out.println();\r\n        System.out.println(<span class=\"hljs-string\">&quot;Testing for string data...&quot;</span>);\r\n        <span class=\"hljs-comment\">// String</span>\r\n        BSTRecursiveGeneric&lt;String&gt; stringTree = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BSTRecursiveGeneric</span>&lt;String&gt;();\r\n\r\n        stringTree.add(<span class=\"hljs-string\">&quot;banana&quot;</span>);\r\n        stringTree.add(<span class=\"hljs-string\">&quot;pineapple&quot;</span>);\r\n        stringTree.add(<span class=\"hljs-string\">&quot;date&quot;</span>);\r\n        <span class=\"hljs-keyword\">assert</span> !stringTree.find(<span class=\"hljs-string\">&quot;girl&quot;</span>) : <span class=\"hljs-string\">&quot;girl is not yet present in BST&quot;</span>;\r\n        <span class=\"hljs-keyword\">assert</span> stringTree.find(<span class=\"hljs-string\">&quot;pineapple&quot;</span>) : <span class=\"hljs-string\">&quot;10 should be present in BST&quot;</span>;\r\n        stringTree.remove(<span class=\"hljs-string\">&quot;date&quot;</span>);\r\n        <span class=\"hljs-keyword\">assert</span> !stringTree.find(<span class=\"hljs-string\">&quot;date&quot;</span>) : <span class=\"hljs-string\">&quot;date was just deleted from BST&quot;</span>;\r\n        stringTree.remove(<span class=\"hljs-string\">&quot;boy&quot;</span>);\r\n        <span class=\"hljs-keyword\">assert</span> !stringTree.find(<span class=\"hljs-string\">&quot;boy&quot;</span>) : <span class=\"hljs-string\">&quot;Since boy was not present so deleting would do no change&quot;</span>;\r\n        stringTree.add(<span class=\"hljs-string\">&quot;india&quot;</span>);\r\n        stringTree.add(<span class=\"hljs-string\">&quot;hills&quot;</span>);\r\n        <span class=\"hljs-keyword\">assert</span> stringTree.find(<span class=\"hljs-string\">&quot;hills&quot;</span>) : <span class=\"hljs-string\">&quot;hills was inserted but not found&quot;</span>;\r\n        <span class=\"hljs-comment\">/*\r\n     Will print in following order\r\n     banana hills india pineapple\r\n         */</span>\r\n        stringTree.inorder();\r\n\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Recursive method to delete a data if present in BST.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> node the node under which to (recursively) search for data\r\n     * <span class=\"hljs-doctag\">@param</span> data the value to be deleted\r\n     * <span class=\"hljs-doctag\">@return</span> Node the updated value of root parameter after delete operation\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> Node&lt;T&gt; <span class=\"hljs-title function_\">delete</span><span class=\"hljs-params\">(Node&lt;T&gt; node, T data)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-literal\">null</span>) {\r\n            System.out.println(<span class=\"hljs-string\">&quot;No such data present in BST.&quot;</span>);\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.data.compareTo(data) &gt; <span class=\"hljs-number\">0</span>) {\r\n            node.left = delete(node.left, data);\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.data.compareTo(data) &lt; <span class=\"hljs-number\">0</span>) {\r\n            node.right = delete(node.right, data);\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            <span class=\"hljs-keyword\">if</span> (node.right == <span class=\"hljs-literal\">null</span> &amp;&amp; node.left == <span class=\"hljs-literal\">null</span>) { <span class=\"hljs-comment\">// If it is leaf node</span>\r\n                node = <span class=\"hljs-literal\">null</span>;\r\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.left == <span class=\"hljs-literal\">null</span>) { <span class=\"hljs-comment\">// If only right node is present</span>\r\n                Node&lt;T&gt; temp = node.right;\r\n                node.right = <span class=\"hljs-literal\">null</span>;\r\n                node = temp;\r\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.right == <span class=\"hljs-literal\">null</span>) { <span class=\"hljs-comment\">// Only left node is present</span>\r\n                Node&lt;T&gt; temp = node.left;\r\n                node.left = <span class=\"hljs-literal\">null</span>;\r\n                node = temp;\r\n            } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-comment\">// both child are present</span>\r\n                Node&lt;T&gt; temp = node.right;\r\n                <span class=\"hljs-comment\">// Find leftmost child of right subtree</span>\r\n                <span class=\"hljs-keyword\">while</span> (temp.left != <span class=\"hljs-literal\">null</span>) {\r\n                    temp = temp.left;\r\n                }\r\n                node.data = temp.data;\r\n                node.right = delete(node.right, temp.data);\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> node;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Recursive insertion of value in BST.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> node to check if the data can be inserted in current node or its\r\n     * subtree\r\n     * <span class=\"hljs-doctag\">@param</span> data the value to be inserted\r\n     * <span class=\"hljs-doctag\">@return</span> the modified value of the root parameter after insertion\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> Node&lt;T&gt; <span class=\"hljs-title function_\">insert</span><span class=\"hljs-params\">(Node&lt;T&gt; node, T data)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-literal\">null</span>) {\r\n            node = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>&lt;&gt;(data);\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.data.compareTo(data) &gt; <span class=\"hljs-number\">0</span>) {\r\n            node.left = insert(node.left, data);\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.data.compareTo(data) &lt; <span class=\"hljs-number\">0</span>) {\r\n            node.right = insert(node.right, data);\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> node;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Recursively print Preorder traversal of the BST\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> node the root node\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">preOrder</span><span class=\"hljs-params\">(Node&lt;T&gt; node)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-literal\">null</span>) {\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        System.out.print(node.data + <span class=\"hljs-string\">&quot; &quot;</span>);\r\n        <span class=\"hljs-keyword\">if</span> (node.left != <span class=\"hljs-literal\">null</span>) {\r\n            preOrder(node.left);\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (node.right != <span class=\"hljs-literal\">null</span>) {\r\n            preOrder(node.right);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Recursively print Postorder traversal of BST.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> node the root node\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">postOrder</span><span class=\"hljs-params\">(Node&lt;T&gt; node)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-literal\">null</span>) {\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (node.left != <span class=\"hljs-literal\">null</span>) {\r\n            postOrder(node.left);\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (node.right != <span class=\"hljs-literal\">null</span>) {\r\n            postOrder(node.right);\r\n        }\r\n        System.out.print(node.data + <span class=\"hljs-string\">&quot; &quot;</span>);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Recursively print Inorder traversal of BST.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> node the root node\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">inOrder</span><span class=\"hljs-params\">(Node&lt;T&gt; node)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-literal\">null</span>) {\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (node.left != <span class=\"hljs-literal\">null</span>) {\r\n            inOrder(node.left);\r\n        }\r\n        System.out.print(node.data + <span class=\"hljs-string\">&quot; &quot;</span>);\r\n        <span class=\"hljs-keyword\">if</span> (node.right != <span class=\"hljs-literal\">null</span>) {\r\n            inOrder(node.right);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Recursively traverse the tree using inorder traversal and keep adding\r\n     * elements to argument list.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> node the root node\r\n     * <span class=\"hljs-doctag\">@param</span> sortedList the list to add the srted elements into\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">inOrderSort</span><span class=\"hljs-params\">(Node&lt;T&gt; node, List&lt;T&gt; sortedList)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-literal\">null</span>) {\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (node.left != <span class=\"hljs-literal\">null</span>) {\r\n            inOrderSort(node.left, sortedList);\r\n        }\r\n        sortedList.add(node.data);\r\n        <span class=\"hljs-keyword\">if</span> (node.right != <span class=\"hljs-literal\">null</span>) {\r\n            inOrderSort(node.right, sortedList);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Serach recursively if the given value is present in BST or not.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> node the node under which to check\r\n     * <span class=\"hljs-doctag\">@param</span> data the value to be checked\r\n     * <span class=\"hljs-doctag\">@return</span> boolean if data is present or not\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">search</span><span class=\"hljs-params\">(Node&lt;T&gt; node, T data)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-literal\">null</span>) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.data.compareTo(data) == <span class=\"hljs-number\">0</span>) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.data.compareTo(data) &gt; <span class=\"hljs-number\">0</span>) {\r\n            <span class=\"hljs-keyword\">return</span> search(node.left, data);\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            <span class=\"hljs-keyword\">return</span> search(node.right, data);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * add in BST. if the value is not already present it is inserted or else no\r\n     * change takes place.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> data the value to be inserted\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">add</span><span class=\"hljs-params\">(T data)</span> {\r\n        <span class=\"hljs-built_in\">this</span>.root = insert(<span class=\"hljs-built_in\">this</span>.root, data);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * If data is present in BST delete it else do nothing.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> data the value to be removed\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">(T data)</span> {\r\n        <span class=\"hljs-built_in\">this</span>.root = delete(<span class=\"hljs-built_in\">this</span>.root, data);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * To call inorder traversal on tree\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">inorder</span><span class=\"hljs-params\">()</span> {\r\n        System.out.println(<span class=\"hljs-string\">&quot;Inorder traversal of this tree is:&quot;</span>);\r\n        inOrder(<span class=\"hljs-built_in\">this</span>.root);\r\n        System.out.println(); <span class=\"hljs-comment\">// for next line</span>\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * return a sorted list by traversing the tree elements using inorder\r\n     * traversal\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> List&lt;T&gt; <span class=\"hljs-title function_\">inorderSort</span><span class=\"hljs-params\">()</span> {\r\n        List&lt;T&gt; sortedList = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();\r\n        inOrderSort(<span class=\"hljs-built_in\">this</span>.root, sortedList);\r\n        <span class=\"hljs-keyword\">return</span> sortedList;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * To call postorder traversal on tree\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">postorder</span><span class=\"hljs-params\">()</span> {\r\n        System.out.println(<span class=\"hljs-string\">&quot;Postorder traversal of this tree is:&quot;</span>);\r\n        postOrder(<span class=\"hljs-built_in\">this</span>.root);\r\n        System.out.println(); <span class=\"hljs-comment\">// for next line</span>\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * To call preorder traversal on tree.\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">preorder</span><span class=\"hljs-params\">()</span> {\r\n        System.out.println(<span class=\"hljs-string\">&quot;Preorder traversal of this tree is:&quot;</span>);\r\n        preOrder(<span class=\"hljs-built_in\">this</span>.root);\r\n        System.out.println(); <span class=\"hljs-comment\">// for next line</span>\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * To check if given value is present in tree or not.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> data the data to be found for\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">find</span><span class=\"hljs-params\">(T data)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (search(<span class=\"hljs-built_in\">this</span>.root, data)) {\r\n            System.out.println(data + <span class=\"hljs-string\">&quot; is present in given BST.&quot;</span>);\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n        }\r\n        System.out.println(data + <span class=\"hljs-string\">&quot; not found.&quot;</span>);\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * The generic Node class used for building binary search tree\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span>&lt;T&gt; {\r\n\r\n        T data;\r\n        Node&lt;T&gt; left;\r\n        Node&lt;T&gt; right;\r\n\r\n        <span class=\"hljs-comment\">/**\r\n         * Constructor with data as parameter\r\n         */</span>\r\n        Node(T d) {\r\n            data = d;\r\n            left = <span class=\"hljs-literal\">null</span>;\r\n            right = <span class=\"hljs-literal\">null</span>;\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Aitor Fidalgo SÃ¡nchez",
      "email": "64830228+aitorfi@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Madhur Panwar",
      "email": "39766613+mdrpanwar@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}