{
  "slug": "monte-carlo-tree-search",
  "name": "Monte Carlo Tree Search",
  "categories": [
    "searches"
  ],
  "body": {},
  "implementations": {
    "java": {
      "dir": "src\\main\\java\\com\\thealgorithms\\searches\\MonteCarloTreeSearch.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src\\main\\java\\com\\thealgorithms\\searches\\MonteCarloTreeSearch.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.searches;\r\n\r\n<span class=\"hljs-keyword\">import</span> java.util.Collections;\r\n<span class=\"hljs-keyword\">import</span> java.util.ArrayList;\r\n<span class=\"hljs-keyword\">import</span> java.util.Comparator;\r\n<span class=\"hljs-keyword\">import</span> java.util.Random;\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Monte Carlo Tree Search (MCTS) is a heuristic search algorithm used in\r\n * decition taking problems especially games.\r\n *\r\n * See more: https://en.wikipedia.org/wiki/Monte_Carlo_tree_search,\r\n * https://www.baeldung.com/java-monte-carlo-tree-search\r\n */</span>\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MonteCarloTreeSearch</span> {\r\n\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span> {\r\n\r\n        Node parent;\r\n        ArrayList&lt;Node&gt; childNodes;\r\n        <span class=\"hljs-type\">boolean</span> isPlayersTurn; <span class=\"hljs-comment\">// True if it is the player&#x27;s turn.</span>\r\n        <span class=\"hljs-type\">boolean</span> playerWon; <span class=\"hljs-comment\">// True if the player won; false if the opponent won.</span>\r\n        <span class=\"hljs-type\">int</span> score;\r\n        <span class=\"hljs-type\">int</span> visitCount;\r\n\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Node</span><span class=\"hljs-params\">()</span> {\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Node</span><span class=\"hljs-params\">(Node parent, <span class=\"hljs-type\">boolean</span> isPlayersTurn)</span> {\r\n            <span class=\"hljs-built_in\">this</span>.parent = parent;\r\n            childNodes = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();\r\n            <span class=\"hljs-built_in\">this</span>.isPlayersTurn = isPlayersTurn;\r\n            playerWon = <span class=\"hljs-literal\">false</span>;\r\n            score = <span class=\"hljs-number\">0</span>;\r\n            visitCount = <span class=\"hljs-number\">0</span>;\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">WIN_SCORE</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span>;\r\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">TIME_LIMIT</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">500</span>; <span class=\"hljs-comment\">// Time the algorithm will be running for (in milliseconds).</span>\r\n\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\r\n        <span class=\"hljs-type\">MonteCarloTreeSearch</span> <span class=\"hljs-variable\">mcts</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MonteCarloTreeSearch</span>();\r\n\r\n        mcts.monteCarloTreeSearch(mcts.<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">true</span>));\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Explores a game tree using Monte Carlo Tree Search (MCTS) and returns the\r\n     * most promising node.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> rootNode Root node of the game tree.\r\n     * <span class=\"hljs-doctag\">@return</span> The most promising child of the root node.\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> Node <span class=\"hljs-title function_\">monteCarloTreeSearch</span><span class=\"hljs-params\">(Node rootNode)</span> {\r\n        Node winnerNode;\r\n        <span class=\"hljs-type\">double</span> timeLimit;\r\n\r\n        <span class=\"hljs-comment\">// Expand the root node.</span>\r\n        addChildNodes(rootNode, <span class=\"hljs-number\">10</span>);\r\n\r\n        timeLimit = System.currentTimeMillis() + TIME_LIMIT;\r\n\r\n        <span class=\"hljs-comment\">// Explore the tree until the time limit is reached.</span>\r\n        <span class=\"hljs-keyword\">while</span> (System.currentTimeMillis() &lt; timeLimit) {\r\n            Node promisingNode;\r\n\r\n            <span class=\"hljs-comment\">// Get a promising node using UCT.</span>\r\n            promisingNode = getPromisingNode(rootNode);\r\n\r\n            <span class=\"hljs-comment\">// Expand the promising node.</span>\r\n            <span class=\"hljs-keyword\">if</span> (promisingNode.childNodes.size() == <span class=\"hljs-number\">0</span>) {\r\n                addChildNodes(promisingNode, <span class=\"hljs-number\">10</span>);\r\n            }\r\n\r\n            simulateRandomPlay(promisingNode);\r\n        }\r\n\r\n        winnerNode = getWinnerNode(rootNode);\r\n        printScores(rootNode);\r\n        System.out.format(<span class=\"hljs-string\">&quot;\\nThe optimal node is: %02d\\n&quot;</span>, rootNode.childNodes.indexOf(winnerNode) + <span class=\"hljs-number\">1</span>);\r\n\r\n        <span class=\"hljs-keyword\">return</span> winnerNode;\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">addChildNodes</span><span class=\"hljs-params\">(Node node, <span class=\"hljs-type\">int</span> childCount)</span> {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; childCount; i++) {\r\n            node.childNodes.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(node, !node.isPlayersTurn));\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Uses UCT to find a promising child node to be explored.\r\n     *\r\n     * UCT: Upper Confidence bounds applied to Trees.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> rootNode Root node of the tree.\r\n     * <span class=\"hljs-doctag\">@return</span> The most promising node according to UCT.\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> Node <span class=\"hljs-title function_\">getPromisingNode</span><span class=\"hljs-params\">(Node rootNode)</span> {\r\n        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">promisingNode</span> <span class=\"hljs-operator\">=</span> rootNode;\r\n\r\n        <span class=\"hljs-comment\">// Iterate until a node that hasn&#x27;t been expanded is found.</span>\r\n        <span class=\"hljs-keyword\">while</span> (promisingNode.childNodes.size() != <span class=\"hljs-number\">0</span>) {\r\n            <span class=\"hljs-type\">double</span> <span class=\"hljs-variable\">uctIndex</span> <span class=\"hljs-operator\">=</span> Double.MIN_VALUE;\r\n            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">nodeIndex</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\r\n\r\n            <span class=\"hljs-comment\">// Iterate through child nodes and pick the most promising one</span>\r\n            <span class=\"hljs-comment\">// using UCT (Upper Confidence bounds applied to Trees).</span>\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; promisingNode.childNodes.size(); i++) {\r\n                <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">childNode</span> <span class=\"hljs-operator\">=</span> promisingNode.childNodes.get(i);\r\n                <span class=\"hljs-type\">double</span> uctTemp;\r\n\r\n                <span class=\"hljs-comment\">// If child node has never been visited</span>\r\n                <span class=\"hljs-comment\">// it will have the highest uct value.</span>\r\n                <span class=\"hljs-keyword\">if</span> (childNode.visitCount == <span class=\"hljs-number\">0</span>) {\r\n                    nodeIndex = i;\r\n                    <span class=\"hljs-keyword\">break</span>;\r\n                }\r\n\r\n                uctTemp = ((<span class=\"hljs-type\">double</span>) childNode.score / childNode.visitCount)\r\n                        + <span class=\"hljs-number\">1.41</span> * Math.sqrt(Math.log(promisingNode.visitCount) / (<span class=\"hljs-type\">double</span>) childNode.visitCount);\r\n\r\n                <span class=\"hljs-keyword\">if</span> (uctTemp &gt; uctIndex) {\r\n                    uctIndex = uctTemp;\r\n                    nodeIndex = i;\r\n                }\r\n            }\r\n\r\n            promisingNode = promisingNode.childNodes.get(nodeIndex);\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">return</span> promisingNode;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Simulates a random play from a nodes current state and back propagates\r\n     * the result.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> promisingNode Node that will be simulated.\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">simulateRandomPlay</span><span class=\"hljs-params\">(Node promisingNode)</span> {\r\n        <span class=\"hljs-type\">Random</span> <span class=\"hljs-variable\">rand</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Random</span>();\r\n        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">tempNode</span> <span class=\"hljs-operator\">=</span> promisingNode;\r\n        <span class=\"hljs-type\">boolean</span> isPlayerWinner;\r\n\r\n        <span class=\"hljs-comment\">// The following line randomly determines whether the simulated play is a win or loss.</span>\r\n        <span class=\"hljs-comment\">// To use the MCTS algorithm correctly this should be a simulation of the nodes&#x27; current</span>\r\n        <span class=\"hljs-comment\">// state of the game until it finishes (if possible) and use an evaluation function to</span>\r\n        <span class=\"hljs-comment\">// determine how good or bad the play was.</span>\r\n        <span class=\"hljs-comment\">// e.g. Play tic tac toe choosing random squares until the game ends. </span>\r\n        promisingNode.playerWon = (rand.nextInt(<span class=\"hljs-number\">6</span>) == <span class=\"hljs-number\">0</span>);\r\n\r\n        isPlayerWinner = promisingNode.playerWon;\r\n\r\n        <span class=\"hljs-comment\">// Back propagation of the random play.</span>\r\n        <span class=\"hljs-keyword\">while</span> (tempNode != <span class=\"hljs-literal\">null</span>) {\r\n            tempNode.visitCount++;\r\n\r\n            <span class=\"hljs-comment\">// Add wining scores to bouth player and opponent depending on the turn.</span>\r\n            <span class=\"hljs-keyword\">if</span> ((tempNode.isPlayersTurn &amp;&amp; isPlayerWinner)\r\n                    || (!tempNode.isPlayersTurn &amp;&amp; !isPlayerWinner)) {\r\n                tempNode.score += WIN_SCORE;\r\n            }\r\n\r\n            tempNode = tempNode.parent;\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">public</span> Node <span class=\"hljs-title function_\">getWinnerNode</span><span class=\"hljs-params\">(Node rootNode)</span> {\r\n        <span class=\"hljs-keyword\">return</span> Collections.max(rootNode.childNodes, Comparator.comparing(c -&gt; c.score));\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printScores</span><span class=\"hljs-params\">(Node rootNode)</span> {\r\n        System.out.println(<span class=\"hljs-string\">&quot;N.\\tScore\\t\\tVisits&quot;</span>);\r\n\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; rootNode.childNodes.size(); i++) {\r\n            System.out.println(String.format(<span class=\"hljs-string\">&quot;%02d\\t%d\\t\\t%d&quot;</span>, i + <span class=\"hljs-number\">1</span>,\r\n                    rootNode.childNodes.get(i).score, rootNode.childNodes.get(i).visitCount));\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Aitor Fidalgo Sánchez",
      "email": "64830228+aitorfi@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}