{
  "slug": "cycle-check-directed-graph",
  "name": "Cycle Check Directed Graph",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "graph\\cycle_check_directed_graph.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph\\cycle_check_directed_graph.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file cycle_check_directed graph.cpp\r\n *\r\n * @brief BFS and DFS algorithms to check for cycle in a directed graph.\r\n *\r\n * @author [Anmol3299](mailto:mittalanmol22@gmail.com)\r\n *\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>     <span class=\"hljs-comment\">// for std::cout</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span>          <span class=\"hljs-comment\">// for std::map</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span>        <span class=\"hljs-comment\">// for std::queue</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdexcept&gt;</span>    <span class=\"hljs-comment\">// for throwing errors</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;type_traits&gt;</span>  <span class=\"hljs-comment\">// for std::remove_reference</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;utility&gt;</span>      <span class=\"hljs-comment\">// for std::move</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>       <span class=\"hljs-comment\">// for std::vector</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Implementation of non-weighted directed edge of a graph.\r\n *\r\n * The source vertex of the edge is labelled &quot;src&quot; and destination vertex is\r\n * labelled &quot;dest&quot;.\r\n */</span>\r\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Edge</span> {\r\n    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> src;\r\n    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> dest;\r\n\r\n    <span class=\"hljs-built_in\">Edge</span>() = <span class=\"hljs-keyword\">delete</span>;\r\n    ~<span class=\"hljs-built_in\">Edge</span>() = <span class=\"hljs-keyword\">default</span>;\r\n    <span class=\"hljs-built_in\">Edge</span>(Edge&amp;&amp;) = <span class=\"hljs-keyword\">default</span>;\r\n    Edge&amp; <span class=\"hljs-keyword\">operator</span>=(Edge&amp;&amp;) = <span class=\"hljs-keyword\">default</span>;\r\n    <span class=\"hljs-built_in\">Edge</span>(Edge <span class=\"hljs-type\">const</span>&amp;) = <span class=\"hljs-keyword\">default</span>;\r\n    Edge&amp; <span class=\"hljs-keyword\">operator</span>=(Edge <span class=\"hljs-type\">const</span>&amp;) = <span class=\"hljs-keyword\">default</span>;\r\n\r\n    <span class=\"hljs-comment\">/** Set the source and destination of the vertex.\r\n     *\r\n     * @param source is the source vertex of the edge.\r\n     * @param destination is the destination vertex of the edge.\r\n     */</span>\r\n    <span class=\"hljs-built_in\">Edge</span>(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> source, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> destination)\r\n        : <span class=\"hljs-built_in\">src</span>(source), <span class=\"hljs-built_in\">dest</span>(destination) {}\r\n};\r\n\r\n<span class=\"hljs-keyword\">using</span> AdjList = std::map&lt;<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>, std::vector&lt;<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>&gt;&gt;;\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Implementation of graph class.\r\n *\r\n * The graph will be represented using Adjacency List representation.\r\n * This class contains 2 data members &quot;m_vertices&quot; &amp; &quot;m_adjList&quot; used to\r\n * represent the number of vertices and adjacency list of the graph\r\n * respectively. The vertices are labelled 0 - (m_vertices - 1).\r\n */</span>\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span> {\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-built_in\">Graph</span>() : <span class=\"hljs-built_in\">m_adjList</span>({}) {}\r\n    ~<span class=\"hljs-built_in\">Graph</span>() = <span class=\"hljs-keyword\">default</span>;\r\n    <span class=\"hljs-built_in\">Graph</span>(Graph&amp;&amp;) = <span class=\"hljs-keyword\">default</span>;\r\n    Graph&amp; <span class=\"hljs-keyword\">operator</span>=(Graph&amp;&amp;) = <span class=\"hljs-keyword\">default</span>;\r\n    <span class=\"hljs-built_in\">Graph</span>(Graph <span class=\"hljs-type\">const</span>&amp;) = <span class=\"hljs-keyword\">default</span>;\r\n    Graph&amp; <span class=\"hljs-keyword\">operator</span>=(Graph <span class=\"hljs-type\">const</span>&amp;) = <span class=\"hljs-keyword\">default</span>;\r\n\r\n    <span class=\"hljs-comment\">/** Create a graph from vertices and adjacency list.\r\n     *\r\n     * @param vertices specify the number of vertices the graph would contain.\r\n     * @param adjList is the adjacency list representation of graph.\r\n     */</span>\r\n    <span class=\"hljs-built_in\">Graph</span>(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> vertices, AdjList adjList)\r\n        : <span class=\"hljs-built_in\">m_vertices</span>(vertices), <span class=\"hljs-built_in\">m_adjList</span>(std::<span class=\"hljs-built_in\">move</span>(adjList)) {}\r\n\r\n    <span class=\"hljs-comment\">/** Create a graph from vertices and adjacency list.\r\n     *\r\n     * @param vertices specify the number of vertices the graph would contain.\r\n     * @param adjList is the adjacency list representation of graph.\r\n     */</span>\r\n    <span class=\"hljs-built_in\">Graph</span>(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> vertices, AdjList&amp;&amp; adjList)\r\n        : <span class=\"hljs-built_in\">m_vertices</span>(vertices), <span class=\"hljs-built_in\">m_adjList</span>(std::<span class=\"hljs-built_in\">move</span>(adjList)) {}\r\n\r\n    <span class=\"hljs-comment\">/** Create a graph from vertices and a set of edges.\r\n     *\r\n     * Adjacency list of the graph would be created from the set of edges. If\r\n     * the source or destination of any edge has a value greater or equal to\r\n     * number of vertices, then it would throw a range_error.\r\n     *\r\n     * @param vertices specify the number of vertices the graph would contain.\r\n     * @param edges is a vector of edges.\r\n     */</span>\r\n    <span class=\"hljs-built_in\">Graph</span>(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> vertices, std::vector&lt;Edge&gt; <span class=\"hljs-type\">const</span>&amp; edges)\r\n        : <span class=\"hljs-built_in\">m_vertices</span>(vertices) {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> <span class=\"hljs-type\">const</span>&amp; edge : edges) {\r\n            <span class=\"hljs-keyword\">if</span> (edge.src &gt;= vertices || edge.dest &gt;= vertices) {\r\n                <span class=\"hljs-keyword\">throw</span> std::<span class=\"hljs-built_in\">range_error</span>(\r\n                    <span class=\"hljs-string\">&quot;Either src or dest of edge out of range&quot;</span>);\r\n            }\r\n            m_adjList[edge.src].<span class=\"hljs-built_in\">emplace_back</span>(edge.dest);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/** Return a const reference of the adjacency list.\r\n     *\r\n     * @return const reference to the adjacency list\r\n     */</span>\r\n    std::remove_reference&lt;AdjList&gt;::<span class=\"hljs-function\">type <span class=\"hljs-type\">const</span>&amp; <span class=\"hljs-title\">getAdjList</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> m_adjList;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @return number of vertices in the graph.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">getVertices</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>{ <span class=\"hljs-keyword\">return</span> m_vertices; }\r\n\r\n    <span class=\"hljs-comment\">/** Add vertices in the graph.\r\n     *\r\n     * @param num is the number of vertices to be added. It adds 1 vertex by\r\n     * default.\r\n     *\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addVertices</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> num = <span class=\"hljs-number\">1</span>)</span> </span>{ m_vertices += num; }\r\n\r\n    <span class=\"hljs-comment\">/** Add an edge in the graph.\r\n     *\r\n     * @param edge that needs to be added.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addEdge</span><span class=\"hljs-params\">(Edge <span class=\"hljs-type\">const</span>&amp; edge)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (edge.src &gt;= m_vertices || edge.dest &gt;= m_vertices) {\r\n            <span class=\"hljs-keyword\">throw</span> std::<span class=\"hljs-built_in\">range_error</span>(<span class=\"hljs-string\">&quot;Either src or dest of edge out of range&quot;</span>);\r\n        }\r\n        m_adjList[edge.src].<span class=\"hljs-built_in\">emplace_back</span>(edge.dest);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/** Add an Edge in the graph\r\n     *\r\n     * @param source is source vertex of the edge.\r\n     * @param destination is the destination vertex of the edge.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> source, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> destination)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (source &gt;= m_vertices || destination &gt;= m_vertices) {\r\n            <span class=\"hljs-keyword\">throw</span> std::<span class=\"hljs-built_in\">range_error</span>(\r\n                <span class=\"hljs-string\">&quot;Either source or destination of edge out of range&quot;</span>);\r\n        }\r\n        m_adjList[source].<span class=\"hljs-built_in\">emplace_back</span>(destination);\r\n    }\r\n\r\n <span class=\"hljs-keyword\">private</span>:\r\n    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> m_vertices = <span class=\"hljs-number\">0</span>;\r\n    AdjList m_adjList;\r\n};\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Check if a directed graph has a cycle or not.\r\n *\r\n * This class provides 2 methods to check for cycle in a directed graph:\r\n * isCyclicDFS &amp; isCyclicBFS.\r\n *\r\n * - isCyclicDFS uses DFS traversal method to check for cycle in a graph.\r\n * - isCyclidBFS used BFS traversal method to check for cycle in a graph.\r\n */</span>\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CycleCheck</span> {\r\n <span class=\"hljs-keyword\">private</span>:\r\n    <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">nodeStates</span> : <span class=\"hljs-type\">uint8_t</span> { not_visited = <span class=\"hljs-number\">0</span>, in_stack, visited };\r\n\r\n    <span class=\"hljs-comment\">/** Helper function of &quot;isCyclicDFS&quot;.\r\n     *\r\n     * @param adjList is the adjacency list representation of some graph.\r\n     * @param state is the state of the nodes of the graph.\r\n     * @param node is the node being evaluated.\r\n     *\r\n     * @return true if graph has a cycle, else false.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isCyclicDFSHelper</span><span class=\"hljs-params\">(AdjList <span class=\"hljs-type\">const</span>&amp; adjList,\r\n                                  std::vector&lt;nodeStates&gt;* state,\r\n                                  <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> node)</span> </span>{\r\n        <span class=\"hljs-comment\">// Add node &quot;in_stack&quot; state.</span>\r\n        (*state)[node] = in_stack;\r\n\r\n        <span class=\"hljs-comment\">// If the node has children, then recursively visit all children of the</span>\r\n        <span class=\"hljs-comment\">// node.</span>\r\n        <span class=\"hljs-keyword\">auto</span> <span class=\"hljs-type\">const</span> it = adjList.<span class=\"hljs-built_in\">find</span>(node);\r\n        <span class=\"hljs-keyword\">if</span> (it != adjList.<span class=\"hljs-built_in\">end</span>()) {\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> child : it-&gt;second) {\r\n                <span class=\"hljs-comment\">// If state of child node is &quot;not_visited&quot;, evaluate that child</span>\r\n                <span class=\"hljs-comment\">// for presence of cycle.</span>\r\n                <span class=\"hljs-keyword\">auto</span> state_of_child = (*state)[child];\r\n                <span class=\"hljs-keyword\">if</span> (state_of_child == not_visited) {\r\n                    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isCyclicDFSHelper</span>(adjList, state, child)) {\r\n                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n                    }\r\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (state_of_child == in_stack) {\r\n                    <span class=\"hljs-comment\">// If child node was &quot;in_stack&quot;, then that means that there</span>\r\n                    <span class=\"hljs-comment\">// is a cycle in the graph. Return true for presence of the</span>\r\n                    <span class=\"hljs-comment\">// cycle.</span>\r\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n                }\r\n            }\r\n        }\r\n\r\n        <span class=\"hljs-comment\">// Current node has been evaluated for the presence of cycle and had no</span>\r\n        <span class=\"hljs-comment\">// cycle. Mark current node as &quot;visited&quot;.</span>\r\n        (*state)[node] = visited;\r\n        <span class=\"hljs-comment\">// Return that current node didn&#x27;t result in any cycles.</span>\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n    }\r\n\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-comment\">/** Driver function to check if a graph has a cycle.\r\n     *\r\n     * This function uses DFS to check for cycle in the graph.\r\n     *\r\n     * @param graph which needs to be evaluated for the presence of cycle.\r\n     * @return true if a cycle is detected, else false.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isCyclicDFS</span><span class=\"hljs-params\">(Graph <span class=\"hljs-type\">const</span>&amp; graph)</span> </span>{\r\n        <span class=\"hljs-keyword\">auto</span> vertices = graph.<span class=\"hljs-built_in\">getVertices</span>();\r\n\r\n        <span class=\"hljs-comment\">/** State of the node.\r\n         *\r\n         * It is a vector of &quot;nodeStates&quot; which represents the state node is in.\r\n         * It can take only 3 values: &quot;not_visited&quot;, &quot;in_stack&quot;, and &quot;visited&quot;.\r\n         *\r\n         * Initially, all nodes are in &quot;not_visited&quot; state.\r\n         */</span>\r\n        <span class=\"hljs-function\">std::vector&lt;nodeStates&gt; <span class=\"hljs-title\">state</span><span class=\"hljs-params\">(vertices, not_visited)</span></span>;\r\n\r\n        <span class=\"hljs-comment\">// Start visiting each node.</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> node = <span class=\"hljs-number\">0</span>; node &lt; vertices; node++) {\r\n            <span class=\"hljs-comment\">// If a node is not visited, only then check for presence of cycle.</span>\r\n            <span class=\"hljs-comment\">// There is no need to check for presence of cycle for a visited</span>\r\n            <span class=\"hljs-comment\">// node as it has already been checked for presence of cycle.</span>\r\n            <span class=\"hljs-keyword\">if</span> (state[node] == not_visited) {\r\n                <span class=\"hljs-comment\">// Check for cycle.</span>\r\n                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isCyclicDFSHelper</span>(graph.<span class=\"hljs-built_in\">getAdjList</span>(), &amp;state, node)) {\r\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n                }\r\n            }\r\n        }\r\n\r\n        <span class=\"hljs-comment\">// All nodes have been safely traversed, that means there is no cycle in</span>\r\n        <span class=\"hljs-comment\">// the graph. Return false.</span>\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/** Check if a graph has cycle or not.\r\n     *\r\n     * This function uses BFS to check if a graph is cyclic or not.\r\n     *\r\n     * @param graph which needs to be evaluated for the presence of cycle.\r\n     * @return true if a cycle is detected, else false.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isCyclicBFS</span><span class=\"hljs-params\">(Graph <span class=\"hljs-type\">const</span>&amp; graph)</span> </span>{\r\n        <span class=\"hljs-keyword\">auto</span> graphAjdList = graph.<span class=\"hljs-built_in\">getAdjList</span>();\r\n        <span class=\"hljs-keyword\">auto</span> vertices = graph.<span class=\"hljs-built_in\">getVertices</span>();\r\n\r\n        <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">indegree</span><span class=\"hljs-params\">(vertices, <span class=\"hljs-number\">0</span>)</span></span>;\r\n        <span class=\"hljs-comment\">// Calculate the indegree i.e. the number of incident edges to the node.</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> <span class=\"hljs-type\">const</span>&amp; list : graphAjdList) {\r\n            <span class=\"hljs-keyword\">auto</span> children = list.second;\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> <span class=\"hljs-type\">const</span>&amp; child : children) {\r\n                indegree[child]++;\r\n            }\r\n        }\r\n\r\n        std::queue&lt;<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>&gt; can_be_solved;\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> node = <span class=\"hljs-number\">0</span>; node &lt; vertices; node++) {\r\n            <span class=\"hljs-comment\">// If a node doesn&#x27;t have any input edges, then that node will</span>\r\n            <span class=\"hljs-comment\">// definately not result in a cycle and can be visited safely.</span>\r\n            <span class=\"hljs-keyword\">if</span> (!indegree[node]) {\r\n                can_be_solved.<span class=\"hljs-built_in\">emplace</span>(node);\r\n            }\r\n        }\r\n\r\n        <span class=\"hljs-comment\">// Vertices that need to be traversed.</span>\r\n        <span class=\"hljs-keyword\">auto</span> remain = vertices;\r\n        <span class=\"hljs-comment\">// While there are safe nodes that we can visit.</span>\r\n        <span class=\"hljs-keyword\">while</span> (!can_be_solved.<span class=\"hljs-built_in\">empty</span>()) {\r\n            <span class=\"hljs-keyword\">auto</span> solved = can_be_solved.<span class=\"hljs-built_in\">front</span>();\r\n            <span class=\"hljs-comment\">// Visit the node.</span>\r\n            can_be_solved.<span class=\"hljs-built_in\">pop</span>();\r\n            <span class=\"hljs-comment\">// Decrease number of nodes that need to be traversed.</span>\r\n            remain--;\r\n\r\n            <span class=\"hljs-comment\">// Visit all the children of the visited node.</span>\r\n            <span class=\"hljs-keyword\">auto</span> it = graphAjdList.<span class=\"hljs-built_in\">find</span>(solved);\r\n            <span class=\"hljs-keyword\">if</span> (it != graphAjdList.<span class=\"hljs-built_in\">end</span>()) {\r\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> child : it-&gt;second) {\r\n                    <span class=\"hljs-comment\">// Check if we can visited the node safely.</span>\r\n                    <span class=\"hljs-keyword\">if</span> (--indegree[child] == <span class=\"hljs-number\">0</span>) {\r\n                        <span class=\"hljs-comment\">// if node can be visited safely, then add that node to</span>\r\n                        <span class=\"hljs-comment\">// the visit queue.</span>\r\n                        can_be_solved.<span class=\"hljs-built_in\">emplace</span>(child);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        <span class=\"hljs-comment\">// If there are still nodes that we can&#x27;t visit, then it means that</span>\r\n        <span class=\"hljs-comment\">// there is a cycle and return true, else return false.</span>\r\n        <span class=\"hljs-keyword\">return</span> !(remain == <span class=\"hljs-number\">0</span>);\r\n    }\r\n};\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Main function.\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-comment\">// Instantiate the graph.</span>\r\n    <span class=\"hljs-function\">Graph <span class=\"hljs-title\">g</span><span class=\"hljs-params\">(<span class=\"hljs-number\">7</span>, std::vector&lt;Edge&gt;{{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>}, {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>}})</span></span>;\r\n    <span class=\"hljs-comment\">// Check for cycle using BFS method.</span>\r\n    std::cout &lt;&lt; CycleCheck::<span class=\"hljs-built_in\">isCyclicBFS</span>(g) &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;\r\n\r\n    <span class=\"hljs-comment\">// Check for cycle using DFS method.</span>\r\n    std::cout &lt;&lt; CycleCheck::<span class=\"hljs-built_in\">isCyclicDFS</span>(g) &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Ayaan Khan",
      "email": "ayaankhan98@gmail.com",
      "commits": 1
    },
    {
      "name": "Anmol Mittal",
      "email": "mittalanmol22@gmail.com",
      "commits": 1
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}