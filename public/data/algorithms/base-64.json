{
  "slug": "base-64",
  "name": "Base 64",
  "categories": [
    "ciphers"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "ciphers\\base64.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/ciphers\\base64.py",
      "code": "B64_CHARSET = <span class=\"hljs-string\">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">base64_encode</span>(<span class=\"hljs-params\">data: <span class=\"hljs-built_in\">bytes</span></span>) -&gt; <span class=\"hljs-built_in\">bytes</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;Encodes data according to RFC4648.\r\n\r\n    The data is first transformed to binary and appended with binary digits so that its\r\n    length becomes a multiple of 6, then each 6 binary digits will match a character in\r\n    the B64_CHARSET string. The number of appended binary digits would later determine\r\n    how many &quot;=&quot; signs should be added, the padding.\r\n    For every 2 binary digits added, a &quot;=&quot; sign is added in the output.\r\n    We can add any binary digits to make it a multiple of 6, for instance, consider the\r\n    following example:\r\n    &quot;AA&quot; -&gt; 0010100100101001 -&gt; 001010 010010 1001\r\n    As can be seen above, 2 more binary digits should be added, so there&#x27;s 4\r\n    possibilities here: 00, 01, 10 or 11.\r\n    That being said, Base64 encoding can be used in Steganography to hide data in these\r\n    appended digits.\r\n\r\n    &gt;&gt;&gt; from base64 import b64encode\r\n    &gt;&gt;&gt; a = b&quot;This pull request is part of Hacktoberfest20!&quot;\r\n    &gt;&gt;&gt; b = b&quot;https://tools.ietf.org/html/rfc4648&quot;\r\n    &gt;&gt;&gt; c = b&quot;A&quot;\r\n    &gt;&gt;&gt; base64_encode(a) == b64encode(a)\r\n    True\r\n    &gt;&gt;&gt; base64_encode(b) == b64encode(b)\r\n    True\r\n    &gt;&gt;&gt; base64_encode(c) == b64encode(c)\r\n    True\r\n    &gt;&gt;&gt; base64_encode(&quot;abc&quot;)\r\n    Traceback (most recent call last):\r\n      ...\r\n    TypeError: a bytes-like object is required, not &#x27;str&#x27;\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-comment\"># Make sure the supplied data is a bytes-like object</span>\r\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-built_in\">isinstance</span>(data, <span class=\"hljs-built_in\">bytes</span>):\r\n        <span class=\"hljs-keyword\">raise</span> TypeError(\r\n            <span class=\"hljs-string\">f&quot;a bytes-like object is required, not &#x27;<span class=\"hljs-subst\">{data.__class__.__name__}</span>&#x27;&quot;</span>\r\n        )\r\n\r\n    binary_stream = <span class=\"hljs-string\">&quot;&quot;</span>.join(<span class=\"hljs-built_in\">bin</span>(byte)[<span class=\"hljs-number\">2</span>:].zfill(<span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">for</span> byte <span class=\"hljs-keyword\">in</span> data)\r\n\r\n    padding_needed = <span class=\"hljs-built_in\">len</span>(binary_stream) % <span class=\"hljs-number\">6</span> != <span class=\"hljs-number\">0</span>\r\n\r\n    <span class=\"hljs-keyword\">if</span> padding_needed:\r\n        <span class=\"hljs-comment\"># The padding that will be added later</span>\r\n        padding = <span class=\"hljs-string\">b&quot;=&quot;</span> * ((<span class=\"hljs-number\">6</span> - <span class=\"hljs-built_in\">len</span>(binary_stream) % <span class=\"hljs-number\">6</span>) // <span class=\"hljs-number\">2</span>)\r\n\r\n        <span class=\"hljs-comment\"># Append binary_stream with arbitrary binary digits (0&#x27;s by default) to make its</span>\r\n        <span class=\"hljs-comment\"># length a multiple of 6.</span>\r\n        binary_stream += <span class=\"hljs-string\">&quot;0&quot;</span> * (<span class=\"hljs-number\">6</span> - <span class=\"hljs-built_in\">len</span>(binary_stream) % <span class=\"hljs-number\">6</span>)\r\n    <span class=\"hljs-keyword\">else</span>:\r\n        padding = <span class=\"hljs-string\">b&quot;&quot;</span>\r\n\r\n    <span class=\"hljs-comment\"># Encode every 6 binary digits to their corresponding Base64 character</span>\r\n    <span class=\"hljs-keyword\">return</span> (\r\n        <span class=\"hljs-string\">&quot;&quot;</span>.join(\r\n            B64_CHARSET[<span class=\"hljs-built_in\">int</span>(binary_stream[index : index + <span class=\"hljs-number\">6</span>], <span class=\"hljs-number\">2</span>)]\r\n            <span class=\"hljs-keyword\">for</span> index <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(binary_stream), <span class=\"hljs-number\">6</span>)\r\n        ).encode()\r\n        + padding\r\n    )\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">base64_decode</span>(<span class=\"hljs-params\">encoded_data: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bytes</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;Decodes data according to RFC4648.\r\n\r\n    This does the reverse operation of base64_encode.\r\n    We first transform the encoded data back to a binary stream, take off the\r\n    previously appended binary digits according to the padding, at this point we\r\n    would have a binary stream whose length is multiple of 8, the last step is\r\n    to convert every 8 bits to a byte.\r\n\r\n    &gt;&gt;&gt; from base64 import b64decode\r\n    &gt;&gt;&gt; a = &quot;VGhpcyBwdWxsIHJlcXVlc3QgaXMgcGFydCBvZiBIYWNrdG9iZXJmZXN0MjAh&quot;\r\n    &gt;&gt;&gt; b = &quot;aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ2NDg=&quot;\r\n    &gt;&gt;&gt; c = &quot;QQ==&quot;\r\n    &gt;&gt;&gt; base64_decode(a) == b64decode(a)\r\n    True\r\n    &gt;&gt;&gt; base64_decode(b) == b64decode(b)\r\n    True\r\n    &gt;&gt;&gt; base64_decode(c) == b64decode(c)\r\n    True\r\n    &gt;&gt;&gt; base64_decode(&quot;abc&quot;)\r\n    Traceback (most recent call last):\r\n      ...\r\n    AssertionError: Incorrect padding\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-comment\"># Make sure encoded_data is either a string or a bytes-like object</span>\r\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-built_in\">isinstance</span>(encoded_data, <span class=\"hljs-built_in\">bytes</span>) <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-built_in\">isinstance</span>(encoded_data, <span class=\"hljs-built_in\">str</span>):\r\n        <span class=\"hljs-keyword\">raise</span> TypeError(\r\n            <span class=\"hljs-string\">&quot;argument should be a bytes-like object or ASCII string, not &quot;</span>\r\n            <span class=\"hljs-string\">f&quot;&#x27;<span class=\"hljs-subst\">{encoded_data.__class__.__name__}</span>&#x27;&quot;</span>\r\n        )\r\n\r\n    <span class=\"hljs-comment\"># In case encoded_data is a bytes-like object, make sure it contains only</span>\r\n    <span class=\"hljs-comment\"># ASCII characters so we convert it to a string object</span>\r\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">isinstance</span>(encoded_data, <span class=\"hljs-built_in\">bytes</span>):\r\n        <span class=\"hljs-keyword\">try</span>:\r\n            encoded_data = encoded_data.decode(<span class=\"hljs-string\">&quot;utf-8&quot;</span>)\r\n        <span class=\"hljs-keyword\">except</span> UnicodeDecodeError:\r\n            <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&quot;base64 encoded data should only contain ASCII characters&quot;</span>)\r\n\r\n    padding = encoded_data.count(<span class=\"hljs-string\">&quot;=&quot;</span>)\r\n\r\n    <span class=\"hljs-comment\"># Check if the encoded string contains non base64 characters</span>\r\n    <span class=\"hljs-keyword\">if</span> padding:\r\n        <span class=\"hljs-keyword\">assert</span> <span class=\"hljs-built_in\">all</span>(\r\n            char <span class=\"hljs-keyword\">in</span> B64_CHARSET <span class=\"hljs-keyword\">for</span> char <span class=\"hljs-keyword\">in</span> encoded_data[:-padding]\r\n        ), <span class=\"hljs-string\">&quot;Invalid base64 character(s) found.&quot;</span>\r\n    <span class=\"hljs-keyword\">else</span>:\r\n        <span class=\"hljs-keyword\">assert</span> <span class=\"hljs-built_in\">all</span>(\r\n            char <span class=\"hljs-keyword\">in</span> B64_CHARSET <span class=\"hljs-keyword\">for</span> char <span class=\"hljs-keyword\">in</span> encoded_data\r\n        ), <span class=\"hljs-string\">&quot;Invalid base64 character(s) found.&quot;</span>\r\n\r\n    <span class=\"hljs-comment\"># Check the padding</span>\r\n    <span class=\"hljs-keyword\">assert</span> <span class=\"hljs-built_in\">len</span>(encoded_data) % <span class=\"hljs-number\">4</span> == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> padding &lt; <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&quot;Incorrect padding&quot;</span>\r\n\r\n    <span class=\"hljs-keyword\">if</span> padding:\r\n        <span class=\"hljs-comment\"># Remove padding if there is one</span>\r\n        encoded_data = encoded_data[:-padding]\r\n\r\n        binary_stream = <span class=\"hljs-string\">&quot;&quot;</span>.join(\r\n            <span class=\"hljs-built_in\">bin</span>(B64_CHARSET.index(char))[<span class=\"hljs-number\">2</span>:].zfill(<span class=\"hljs-number\">6</span>) <span class=\"hljs-keyword\">for</span> char <span class=\"hljs-keyword\">in</span> encoded_data\r\n        )[: -padding * <span class=\"hljs-number\">2</span>]\r\n    <span class=\"hljs-keyword\">else</span>:\r\n        binary_stream = <span class=\"hljs-string\">&quot;&quot;</span>.join(\r\n            <span class=\"hljs-built_in\">bin</span>(B64_CHARSET.index(char))[<span class=\"hljs-number\">2</span>:].zfill(<span class=\"hljs-number\">6</span>) <span class=\"hljs-keyword\">for</span> char <span class=\"hljs-keyword\">in</span> encoded_data\r\n        )\r\n\r\n    data = [\r\n        <span class=\"hljs-built_in\">int</span>(binary_stream[index : index + <span class=\"hljs-number\">8</span>], <span class=\"hljs-number\">2</span>)\r\n        <span class=\"hljs-keyword\">for</span> index <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(binary_stream), <span class=\"hljs-number\">8</span>)\r\n    ]\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">bytes</span>(data)\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    <span class=\"hljs-keyword\">import</span> doctest\r\n\r\n    doctest.testmod()\r\n"
    },
    "go": {
      "dir": "conversion\\base64.go",
      "url": "https://github.com/TheAlgorithms/go/tree/master/conversion\\base64.go",
      "code": "<span class=\"hljs-comment\">// base64.go</span>\r\n<span class=\"hljs-comment\">// description: The base64 encoding algorithm as defined in the RFC4648 standard.</span>\r\n<span class=\"hljs-comment\">// author: [Paul Leydier] (https://github.com/paul-leydier)</span>\r\n<span class=\"hljs-comment\">// ref: https://datatracker.ietf.org/doc/html/rfc4648#section-4</span>\r\n<span class=\"hljs-comment\">// ref: https://en.wikipedia.org/wiki/Base64</span>\r\n<span class=\"hljs-comment\">// see base64_test.go</span>\r\n\r\n<span class=\"hljs-keyword\">package</span> conversion\r\n\r\n<span class=\"hljs-keyword\">import</span> (\r\n\t<span class=\"hljs-string\">&quot;strings&quot;</span> <span class=\"hljs-comment\">// Used for efficient string builder (more efficient than simply appending strings)</span>\r\n)\r\n\r\n<span class=\"hljs-keyword\">const</span> Alphabet = <span class=\"hljs-string\">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>\r\n\r\n<span class=\"hljs-comment\">// Base64Encode encodes the received input bytes slice into a base64 string.</span>\r\n<span class=\"hljs-comment\">// The implementation follows the RFC4648 standard, which is documented</span>\r\n<span class=\"hljs-comment\">// at https://datatracker.ietf.org/doc/html/rfc4648#section-4</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Base64Encode</span><span class=\"hljs-params\">(input []<span class=\"hljs-type\">byte</span>)</span></span> <span class=\"hljs-type\">string</span> {\r\n\t<span class=\"hljs-keyword\">var</span> sb strings.Builder\r\n\t<span class=\"hljs-comment\">// If not 24 bits (3 bytes) multiple, pad with 0 value bytes, and with &quot;=&quot; for the output</span>\r\n\t<span class=\"hljs-keyword\">var</span> padding <span class=\"hljs-type\">string</span>\r\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-built_in\">len</span>(input) % <span class=\"hljs-number\">3</span>; i &gt; <span class=\"hljs-number\">0</span> &amp;&amp; i &lt; <span class=\"hljs-number\">3</span>; i++ {\r\n\t\t<span class=\"hljs-keyword\">var</span> zeroByte <span class=\"hljs-type\">byte</span>\r\n\t\tinput = <span class=\"hljs-built_in\">append</span>(input, zeroByte)\r\n\t\tpadding += <span class=\"hljs-string\">&quot;=&quot;</span>\r\n\t}\r\n\r\n\t<span class=\"hljs-comment\">// encode 24 bits per 24 bits (3 bytes per 3 bytes)</span>\r\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(input); i += <span class=\"hljs-number\">3</span> {\r\n\t\t<span class=\"hljs-comment\">// select 3 8-bit input groups, and re-arrange them into 4 6-bit groups</span>\r\n\t\t<span class=\"hljs-comment\">// the literal 0x3F corresponds to the byte &quot;0011 1111&quot;</span>\r\n\t\t<span class=\"hljs-comment\">// the operation &quot;byte &amp; 0x3F&quot; masks the two left-most bits</span>\r\n\t\tgroup := [<span class=\"hljs-number\">4</span>]<span class=\"hljs-type\">byte</span>{\r\n\t\t\tinput[i] &gt;&gt; <span class=\"hljs-number\">2</span>,\r\n\t\t\t(input[i]&lt;&lt;<span class=\"hljs-number\">4</span>)&amp;<span class=\"hljs-number\">0x3F</span> + input[i+<span class=\"hljs-number\">1</span>]&gt;&gt;<span class=\"hljs-number\">4</span>,\r\n\t\t\t(input[i+<span class=\"hljs-number\">1</span>]&lt;&lt;<span class=\"hljs-number\">2</span>)&amp;<span class=\"hljs-number\">0x3F</span> + input[i+<span class=\"hljs-number\">2</span>]&gt;&gt;<span class=\"hljs-number\">6</span>,\r\n\t\t\tinput[i+<span class=\"hljs-number\">2</span>] &amp; <span class=\"hljs-number\">0x3F</span>,\r\n\t\t}\r\n\r\n\t\t<span class=\"hljs-comment\">// translate each group into a char using the static map</span>\r\n\t\t<span class=\"hljs-keyword\">for</span> _, b := <span class=\"hljs-keyword\">range</span> group {\r\n\t\t\tsb.WriteString(<span class=\"hljs-type\">string</span>(Alphabet[<span class=\"hljs-type\">int</span>(b)]))\r\n\t\t}\r\n\t}\r\n\tencoded := sb.String()\r\n\r\n\t<span class=\"hljs-comment\">// Apply the output padding</span>\r\n\tencoded = encoded[:<span class=\"hljs-built_in\">len</span>(encoded)-<span class=\"hljs-built_in\">len</span>(padding)] + padding[:]\r\n\r\n\t<span class=\"hljs-keyword\">return</span> encoded\r\n}\r\n\r\n<span class=\"hljs-comment\">// Base64Decode decodes the received input base64 string into a byte slice.</span>\r\n<span class=\"hljs-comment\">// The implementation follows the RFC4648 standard, which is documented</span>\r\n<span class=\"hljs-comment\">// at https://datatracker.ietf.org/doc/html/rfc4648#section-4</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Base64Decode</span><span class=\"hljs-params\">(input <span class=\"hljs-type\">string</span>)</span></span> []<span class=\"hljs-type\">byte</span> {\r\n\tpadding := strings.Count(input, <span class=\"hljs-string\">&quot;=&quot;</span>) <span class=\"hljs-comment\">// Number of bytes which will be ignored</span>\r\n\t<span class=\"hljs-keyword\">var</span> decoded []<span class=\"hljs-type\">byte</span>\r\n\r\n\t<span class=\"hljs-comment\">// select 4 6-bit input groups, and re-arrange them into 3 8-bit groups</span>\r\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(input); i += <span class=\"hljs-number\">4</span> {\r\n\t\t<span class=\"hljs-comment\">// translate each group into a byte using the static map</span>\r\n\t\tbyteInput := [<span class=\"hljs-number\">4</span>]<span class=\"hljs-type\">byte</span>{\r\n\t\t\t<span class=\"hljs-type\">byte</span>(strings.IndexByte(Alphabet, input[i])),\r\n\t\t\t<span class=\"hljs-type\">byte</span>(strings.IndexByte(Alphabet, input[i+<span class=\"hljs-number\">1</span>])),\r\n\t\t\t<span class=\"hljs-type\">byte</span>(strings.IndexByte(Alphabet, input[i+<span class=\"hljs-number\">2</span>])),\r\n\t\t\t<span class=\"hljs-type\">byte</span>(strings.IndexByte(Alphabet, input[i+<span class=\"hljs-number\">3</span>])),\r\n\t\t}\r\n\r\n\t\tgroup := [<span class=\"hljs-number\">3</span>]<span class=\"hljs-type\">byte</span>{\r\n\t\t\tbyteInput[<span class=\"hljs-number\">0</span>]&lt;&lt;<span class=\"hljs-number\">2</span> + byteInput[<span class=\"hljs-number\">1</span>]&gt;&gt;<span class=\"hljs-number\">4</span>,\r\n\t\t\tbyteInput[<span class=\"hljs-number\">1</span>]&lt;&lt;<span class=\"hljs-number\">4</span> + byteInput[<span class=\"hljs-number\">2</span>]&gt;&gt;<span class=\"hljs-number\">2</span>,\r\n\t\t\tbyteInput[<span class=\"hljs-number\">2</span>]&lt;&lt;<span class=\"hljs-number\">6</span> + byteInput[<span class=\"hljs-number\">3</span>],\r\n\t\t}\r\n\r\n\t\tdecoded = <span class=\"hljs-built_in\">append</span>(decoded, group[:]...)\r\n\t}\r\n\r\n\t<span class=\"hljs-keyword\">return</span> decoded[:<span class=\"hljs-built_in\">len</span>(decoded)-padding]\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Paul Leydier",
      "email": "75126792+paul-leydier@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}