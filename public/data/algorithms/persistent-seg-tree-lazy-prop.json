{
  "slug": "persistent-seg-tree-lazy-prop",
  "name": "Persistent Seg Tree Lazy Prop",
  "categories": [
    "rangequeries"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "range_queries\\persistent_seg_tree_lazy_prop.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/range_queries\\persistent_seg_tree_lazy_prop.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @brief [Persistent segment tree with range updates (lazy\r\n * propagation)](https://en.wikipedia.org/wiki/Persistent_data_structure)\r\n *\r\n * @details\r\n * A normal segment tree facilitates making point updates and range queries in\r\n * logarithmic time. Lazy propagation preserves the logarithmic time with range\r\n * updates. So, a segment tree with lazy propagation enables doing range updates\r\n * and range queries in logarithmic time, but it doesn&#x27;t save any information\r\n * about itself before the last update. A persistent data structure always\r\n * preserves the previous version of itself when it is modified. That is, a new\r\n * version of the segment tree is generated after every update. It saves all\r\n * previous versions of itself (before every update) to facilitate doing range\r\n * queries in any version. More memory is used ,but the logarithmic time is\r\n * preserved because the new version points to the same nodes, that the previous\r\n * version points to, that are not affected by the update. That is, only the\r\n * nodes that are affected by the update and their ancestors are copied. The\r\n * rest is copied using lazy propagation in the next queries. Thus preserving\r\n * the logarithmic time because the number of nodes copied after any update is\r\n * logarithmic.\r\n *\r\n * @author [Magdy Sedra](https://github.com/MSedra)\r\n */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">/// for IO operations</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;memory&gt;</span>    <span class=\"hljs-comment\">/// to manage dynamic memory</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>    <span class=\"hljs-comment\">/// for std::vector</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace range_queries\r\n * @brief Range queries algorithms\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> range_queries {\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Range query here is range sum, but the code can be modified to make\r\n * different queries like range max or min.\r\n */</span>\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">perSegTree</span> {\r\n <span class=\"hljs-keyword\">private</span>:\r\n    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span> {\r\n     <span class=\"hljs-keyword\">public</span>:\r\n        std::shared_ptr&lt;Node&gt; left = <span class=\"hljs-literal\">nullptr</span>;   <span class=\"hljs-comment\">/// pointer to the left node</span>\r\n        std::shared_ptr&lt;Node&gt; right = <span class=\"hljs-literal\">nullptr</span>;  <span class=\"hljs-comment\">/// pointer to the right node</span>\r\n        <span class=\"hljs-type\">int64_t</span> val = <span class=\"hljs-number\">0</span>,\r\n                prop = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">/// val is the value of the node (here equals to the</span>\r\n                           <span class=\"hljs-comment\">/// sum of the leaf nodes children of that node),</span>\r\n                           <span class=\"hljs-comment\">/// prop is the value to be propagated/added to all</span>\r\n                           <span class=\"hljs-comment\">/// the leaf nodes children of that node</span>\r\n    };\r\n\r\n    <span class=\"hljs-type\">uint32_t</span> n = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">/// number of elements/leaf nodes in the segment tree</span>\r\n    std::vector&lt;std::shared_ptr&lt;Node&gt;&gt;\r\n        ptrs{};  <span class=\"hljs-comment\">/// ptrs[i] holds a root pointer to the segment tree after the</span>\r\n                 <span class=\"hljs-comment\">/// ith update. ptrs[0] holds a root pointer to the segment</span>\r\n                 <span class=\"hljs-comment\">/// tree before any updates</span>\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; vec{};  <span class=\"hljs-comment\">/// values of the leaf nodes that the segment</span>\r\n                                 <span class=\"hljs-comment\">/// tree will be constructed with</span>\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Creating a new node with the same values of curr node\r\n     * @param curr node that would be copied\r\n     * @returns the new node\r\n     */</span>\r\n    <span class=\"hljs-function\">std::shared_ptr&lt;Node&gt; <span class=\"hljs-title\">newKid</span><span class=\"hljs-params\">(std::shared_ptr&lt;Node&gt; <span class=\"hljs-type\">const</span> &amp;curr)</span> </span>{\r\n        <span class=\"hljs-keyword\">auto</span> newNode = std::<span class=\"hljs-built_in\">make_shared</span>&lt;Node&gt;(<span class=\"hljs-built_in\">Node</span>());\r\n        newNode-&gt;left = curr-&gt;left;\r\n        newNode-&gt;right = curr-&gt;right;\r\n        newNode-&gt;prop = curr-&gt;prop;\r\n        newNode-&gt;val = curr-&gt;val;\r\n        <span class=\"hljs-keyword\">return</span> newNode;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief If there is some value to be propagated to the passed node, value\r\n     * is added to the node and the children of the node, if exist, are copied\r\n     * and the propagated value is also added to them\r\n     * @param i the left index of the range that the passed node holds its sum\r\n     * @param j the right index of the range that the passed node holds its sum\r\n     * @param curr pointer to the node to be propagated\r\n     * @returns void\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">lazy</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;i, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;j,\r\n              std::shared_ptr&lt;Node&gt; <span class=\"hljs-type\">const</span> &amp;curr)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (!curr-&gt;prop) {\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        curr-&gt;val += (j - i + <span class=\"hljs-number\">1</span>) * curr-&gt;prop;\r\n        <span class=\"hljs-keyword\">if</span> (i != j) {\r\n            curr-&gt;left = <span class=\"hljs-built_in\">newKid</span>(curr-&gt;left);\r\n            curr-&gt;right = <span class=\"hljs-built_in\">newKid</span>(curr-&gt;right);\r\n            curr-&gt;left-&gt;prop += curr-&gt;prop;\r\n            curr-&gt;right-&gt;prop += curr-&gt;prop;\r\n        }\r\n        curr-&gt;prop = <span class=\"hljs-number\">0</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Constructing the segment tree with the early passed vector. Every\r\n     * call creates a node to hold the sum of the given range, set its pointers\r\n     * to the children, and set its value to the sum of the children&#x27;s values\r\n     * @param i the left index of the range that the created node holds its sum\r\n     * @param j the right index of the range that the created node holds its sum\r\n     * @returns pointer to the newly created node\r\n     */</span>\r\n    <span class=\"hljs-function\">std::shared_ptr&lt;Node&gt; <span class=\"hljs-title\">construct</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;i, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;j)</span> </span>{\r\n        <span class=\"hljs-keyword\">auto</span> newNode = std::<span class=\"hljs-built_in\">make_shared</span>&lt;Node&gt;(<span class=\"hljs-built_in\">Node</span>());\r\n        <span class=\"hljs-keyword\">if</span> (i == j) {\r\n            newNode-&gt;val = vec[i];\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            <span class=\"hljs-type\">uint32_t</span> mid = i + (j - i) / <span class=\"hljs-number\">2</span>;\r\n            <span class=\"hljs-keyword\">auto</span> leftt = <span class=\"hljs-built_in\">construct</span>(i, mid);\r\n            <span class=\"hljs-keyword\">auto</span> right = <span class=\"hljs-built_in\">construct</span>(mid + <span class=\"hljs-number\">1</span>, j);\r\n            newNode-&gt;val = leftt-&gt;val + right-&gt;val;\r\n            newNode-&gt;left = leftt;\r\n            newNode-&gt;right = right;\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> newNode;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Doing range update, checking at every node if it has some value to\r\n     * be propagated. All nodes affected by the update are copied and\r\n     * propagation value is added to the leaf of them\r\n     * @param i the left index of the range that the passed node holds its sum\r\n     * @param j the right index of the range that the passed node holds its sum\r\n     * @param l the left index of the range to be updated\r\n     * @param r the right index of the range to be updated\r\n     * @param value the value to be added to every element whose index x\r\n     * satisfies l&lt;=x&lt;=r\r\n     * @param curr pointer to the current node, which has value = the sum of\r\n     * elements whose index x satisfies i&lt;=x&lt;=j\r\n     * @returns pointer to the current newly created node\r\n     */</span>\r\n    <span class=\"hljs-function\">std::shared_ptr&lt;Node&gt; <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;i, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;j,\r\n                                 <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;l, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;r,\r\n                                 <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int64_t</span> &amp;value,\r\n                                 std::shared_ptr&lt;Node&gt; <span class=\"hljs-type\">const</span> &amp;curr)</span> </span>{\r\n        <span class=\"hljs-built_in\">lazy</span>(i, j, curr);\r\n        <span class=\"hljs-keyword\">if</span> (i &gt;= l &amp;&amp; j &lt;= r) {\r\n            std::shared_ptr&lt;Node&gt; newNode = <span class=\"hljs-built_in\">newKid</span>(curr);\r\n            newNode-&gt;prop += value;\r\n            <span class=\"hljs-built_in\">lazy</span>(i, j, newNode);\r\n            <span class=\"hljs-keyword\">return</span> newNode;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (i &gt; r || j &lt; l) {\r\n            <span class=\"hljs-keyword\">return</span> curr;\r\n        }\r\n        <span class=\"hljs-keyword\">auto</span> newNode = std::<span class=\"hljs-built_in\">make_shared</span>&lt;Node&gt;(<span class=\"hljs-built_in\">Node</span>());\r\n        <span class=\"hljs-type\">uint32_t</span> mid = i + (j - i) / <span class=\"hljs-number\">2</span>;\r\n        newNode-&gt;left = <span class=\"hljs-built_in\">update</span>(i, mid, l, r, value, curr-&gt;left);\r\n        newNode-&gt;right = <span class=\"hljs-built_in\">update</span>(mid + <span class=\"hljs-number\">1</span>, j, l, r, value, curr-&gt;right);\r\n        newNode-&gt;val = newNode-&gt;left-&gt;val + newNode-&gt;right-&gt;val;\r\n        <span class=\"hljs-keyword\">return</span> newNode;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Querying the range from index l to index r, checking at every node\r\n     * if it has some value to be propagated. Current node&#x27;s value is returned\r\n     * if its range is completely inside the wanted range, else 0 is returned\r\n     * @param i the left index of the range that the passed node holds its sum\r\n     * @param j the right index of the range that the passed node holds its sum\r\n     * @param l the left index of the range whose sum should be returned as a\r\n     * result\r\n     * @param r the right index of the range whose sum should be returned as a\r\n     * result\r\n     * @param curr pointer to the current node, which has value = the sum of\r\n     * elements whose index x satisfies i&lt;=x&lt;=j\r\n     * @returns sum of elements whose index x satisfies l&lt;=x&lt;=r\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">query</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;i, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;j, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;l,\r\n                  <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;r, std::shared_ptr&lt;Node&gt; <span class=\"hljs-type\">const</span> &amp;curr)</span> </span>{\r\n        <span class=\"hljs-built_in\">lazy</span>(i, j, curr);\r\n        <span class=\"hljs-keyword\">if</span> (j &lt; l || r &lt; i) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (i &gt;= l &amp;&amp; j &lt;= r) {\r\n            <span class=\"hljs-keyword\">return</span> curr-&gt;val;\r\n        }\r\n        <span class=\"hljs-type\">uint32_t</span> mid = i + (j - i) / <span class=\"hljs-number\">2</span>;\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">query</span>(i, mid, l, r, curr-&gt;left) +\r\n               <span class=\"hljs-built_in\">query</span>(mid + <span class=\"hljs-number\">1</span>, j, l, r, curr-&gt;right);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * public methods that can be used directly from outside the class. They\r\n     * call the private functions that do all the work\r\n     */</span>\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Constructing the segment tree with the values in the passed\r\n     * vector. Returned root pointer is pushed in the pointers vector to have\r\n     * access to the original version if the segment tree is updated\r\n     * @param vec vector whose values will be used to build the segment tree\r\n     * @returns void\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">construct</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;\r\n                       &amp;vec)</span>  <span class=\"hljs-comment\">// the segment tree will be built from the values</span>\r\n                              <span class=\"hljs-comment\">// in &quot;vec&quot;, &quot;vec&quot; is 0 indexed</span>\r\n    </span>{\r\n        <span class=\"hljs-keyword\">if</span> (vec.<span class=\"hljs-built_in\">empty</span>()) {\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        n = vec.<span class=\"hljs-built_in\">size</span>();\r\n        <span class=\"hljs-keyword\">this</span>-&gt;vec = vec;\r\n        <span class=\"hljs-keyword\">auto</span> root = <span class=\"hljs-built_in\">construct</span>(<span class=\"hljs-number\">0</span>, n - <span class=\"hljs-number\">1</span>);\r\n        ptrs.<span class=\"hljs-built_in\">push_back</span>(root);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Doing range update by passing the left and right indexes of the\r\n     * range as well as the value to be added.\r\n     * @param l the left index of the range to be updated\r\n     * @param r the right index of the range to be updated\r\n     * @param value the value to be added to every element whose index x\r\n     * satisfies l&lt;=x&lt;=r\r\n     * @returns void\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;l, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;r,\r\n                <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int64_t</span>\r\n                    &amp;value)</span>  <span class=\"hljs-comment\">// all elements from index &quot;l&quot; to index &quot;r&quot; would</span>\r\n                             <span class=\"hljs-comment\">// by updated by &quot;value&quot;, &quot;l&quot; and &quot;r&quot; are 0 indexed</span>\r\n    </span>{\r\n        ptrs.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-built_in\">update</span>(\r\n            <span class=\"hljs-number\">0</span>, n - <span class=\"hljs-number\">1</span>, l, r, value,\r\n            ptrs[ptrs.<span class=\"hljs-built_in\">size</span>() -\r\n                 <span class=\"hljs-number\">1</span>]));  <span class=\"hljs-comment\">// saving the root pointer to the new segment tree</span>\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Querying the range from index l to index r, getting the sum of the\r\n     * elements whose index x satisfies l&lt;=x&lt;=r\r\n     * @param l the left index of the range whose sum should be returned as a\r\n     * result\r\n     * @param r the right index of the range whose sum should be returned as a\r\n     * result\r\n     * @param version the version to query on. If equals to 0, the original\r\n     * segment tree will be queried\r\n     * @returns sum of elements whose index x satisfies l&lt;=x&lt;=r\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">query</span><span class=\"hljs-params\">(\r\n        <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;l, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;r,\r\n        <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span>\r\n            &amp;version)</span>  <span class=\"hljs-comment\">// querying the range from &quot;l&quot; to &quot;r&quot; in a segment tree</span>\r\n                       <span class=\"hljs-comment\">// after &quot;version&quot; updates, &quot;l&quot; and &quot;r&quot; are 0 indexed</span>\r\n    </span>{\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">query</span>(<span class=\"hljs-number\">0</span>, n - <span class=\"hljs-number\">1</span>, l, r, ptrs[version]);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Getting the number of versions after updates so far which is equal\r\n     * to the size of the pointers vector\r\n     * @returns the number of versions\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span>  <span class=\"hljs-comment\">// returns the number of segment trees (versions) , the</span>\r\n                     <span class=\"hljs-comment\">// number of updates done so far = returned value - 1</span>\r\n                     <span class=\"hljs-comment\">// ,because one of the trees is the original segment tree</span>\r\n    </span>{\r\n        <span class=\"hljs-keyword\">return</span> ptrs.<span class=\"hljs-built_in\">size</span>();\r\n    }\r\n};\r\n}  <span class=\"hljs-comment\">// namespace range_queries</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Test implementations\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; arr = {<span class=\"hljs-number\">-5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>};\r\n    range_queries::perSegTree tree;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Elements before any updates are {&quot;</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-built_in\">size</span>(); ++i) {\r\n        std::cout &lt;&lt; arr[i];\r\n        <span class=\"hljs-keyword\">if</span> (i != arr.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>) {\r\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span>;\r\n        }\r\n    }\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;}\\n&quot;</span>;\r\n    tree.<span class=\"hljs-built_in\">construct</span>(\r\n        arr);  <span class=\"hljs-comment\">// constructing the original segment tree (version = 0)</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Querying range sum on version 0 from index 2 to 4 = 3+11-2 = &quot;</span>\r\n              &lt;&lt; tree.<span class=\"hljs-built_in\">query</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>) &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;\r\n    std::cout\r\n        &lt;&lt; <span class=\"hljs-string\">&quot;Subtract 7 from all elements from index 1 to index 5 inclusive\\n&quot;</span>;\r\n    tree.<span class=\"hljs-built_in\">update</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">-7</span>);  <span class=\"hljs-comment\">// subtracting 7 from index 1 to index 5</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Elements of the segment tree whose version = 1 (after 1 &quot;</span>\r\n                 <span class=\"hljs-string\">&quot;update) are {&quot;</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-built_in\">size</span>(); ++i) {\r\n        std::cout &lt;&lt; tree.<span class=\"hljs-built_in\">query</span>(i, i, <span class=\"hljs-number\">1</span>);\r\n        <span class=\"hljs-keyword\">if</span> (i != arr.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>) {\r\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span>;\r\n        }\r\n    }\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;}\\n&quot;</span>;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Add 10 to all elements from index 0 to index 7 inclusive\\n&quot;</span>;\r\n    tree.<span class=\"hljs-built_in\">update</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">10</span>);  <span class=\"hljs-comment\">// adding 10 to all elements</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Elements of the segment tree whose version = 2 (after 2 &quot;</span>\r\n                 <span class=\"hljs-string\">&quot;updates) are {&quot;</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-built_in\">size</span>(); ++i) {\r\n        std::cout &lt;&lt; tree.<span class=\"hljs-built_in\">query</span>(i, i, <span class=\"hljs-number\">2</span>);\r\n        <span class=\"hljs-keyword\">if</span> (i != arr.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>) {\r\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span>;\r\n        }\r\n    }\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;}\\n&quot;</span>;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Number of segment trees (versions) now = &quot;</span> &lt;&lt; tree.<span class=\"hljs-built_in\">size</span>()\r\n              &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Querying range sum on version 0 from index 3 to 5 = 11-2+7 = &quot;</span>\r\n              &lt;&lt; tree.<span class=\"hljs-built_in\">query</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">0</span>) &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Querying range sum on version 1 from index 3 to 5 = 4-9+0 = &quot;</span>\r\n              &lt;&lt; tree.<span class=\"hljs-built_in\">query</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">1</span>) &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// run self-test implementations</span>\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Magdy Sedra",
      "email": "62825437+MSedra@users.noreply.github.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}