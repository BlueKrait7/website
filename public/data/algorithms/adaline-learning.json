{
  "slug": "adaline-learning",
  "name": "Adaline Learning",
  "categories": [
    "machinelearning"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "machine_learning\\adaline_learning.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/machine_learning\\adaline_learning.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * \\addtogroup machine_learning Machine Learning Algorithms\r\n * @{\r\n * \\file\r\n * \\brief [Adaptive Linear Neuron\r\n * (ADALINE)](https://en.wikipedia.org/wiki/ADALINE) implementation\r\n *\r\n * \\author [Krishna Vedala](https://github.com/kvedala)\r\n *\r\n * \\details\r\n * &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Adaline_flow_chart.gif&quot;&gt;&lt;img\r\n * src=&quot;https://upload.wikimedia.org/wikipedia/commons/b/be/Adaline_flow_chart.gif&quot;\r\n * alt=&quot;Structure of an ADALINE network. Source: Wikipedia&quot;\r\n * style=&quot;width:200px; float:right;&quot;&gt;&lt;/a&gt;\r\n *\r\n * ADALINE is one of the first and simplest single layer artificial neural\r\n * network. The algorithm essentially implements a linear function\r\n * \\f[ f\\left(x_0,x_1,x_2,\\ldots\\right) =\r\n * \\sum_j x_jw_j+\\theta\r\n * \\f]\r\n * where \\f$x_j\\f$ are the input features of a sample, \\f$w_j\\f$ are the\r\n * coefficients of the linear function and \\f$\\theta\\f$ is a constant. If we\r\n * know the \\f$w_j\\f$, then for any given set of features, \\f$y\\f$ can be\r\n * computed. Computing the \\f$w_j\\f$ is a supervised learning algorithm wherein\r\n * a set of features and their corresponding outputs are given and weights are\r\n * computed using stochastic gradient descent method.\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;array&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;climits&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ctime&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;numeric&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\r\n\r\n<span class=\"hljs-comment\">/** Maximum number of iterations to learn */</span>\r\n<span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> MAX_ITER = <span class=\"hljs-number\">500</span>;  <span class=\"hljs-comment\">// INT_MAX</span>\r\n\r\n<span class=\"hljs-comment\">/** \\namespace machine_learning\r\n * \\brief Machine learning algorithms\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> machine_learning {\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">adaline</span> {\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-comment\">/**\r\n     * Default constructor\r\n     * \\param[in] num_features number of features present\r\n     * \\param[in] eta learning rate (optional, default=0.1)\r\n     * \\param[in] convergence accuracy (optional,\r\n     * default=\\f$1\\times10^{-5}\\f$)\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">adaline</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num_features, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> eta = <span class=\"hljs-number\">0.01f</span>,\r\n                     <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> accuracy = <span class=\"hljs-number\">1e-5</span>)</span>\r\n        : eta(eta), accuracy(accuracy) {</span>\r\n        <span class=\"hljs-keyword\">if</span> (eta &lt;= <span class=\"hljs-number\">0</span>) {\r\n            std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;learning rate should be positive and nonzero&quot;</span>\r\n                      &lt;&lt; std::endl;\r\n            std::<span class=\"hljs-built_in\">exit</span>(EXIT_FAILURE);\r\n        }\r\n\r\n        weights = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;(\r\n            num_features +\r\n            <span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">// additional weight is for the constant bias term</span>\r\n\r\n        <span class=\"hljs-comment\">// initialize with random weights in the range [-50, 49]</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">double</span> &amp;weight : weights) weight = <span class=\"hljs-number\">1.f</span>;\r\n        <span class=\"hljs-comment\">// weights[i] = (static_cast&lt;double&gt;(std::rand() % 100) - 50);</span>\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Operator to print the weights of the model\r\n     */</span>\r\n    <span class=\"hljs-keyword\">friend</span> std::ostream &amp;<span class=\"hljs-keyword\">operator</span>&lt;&lt;(std::ostream &amp;out, <span class=\"hljs-type\">const</span> adaline &amp;ada) {\r\n        out &lt;&lt; <span class=\"hljs-string\">&quot;&lt;&quot;</span>;\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; ada.weights.<span class=\"hljs-built_in\">size</span>(); i++) {\r\n            out &lt;&lt; ada.weights[i];\r\n            <span class=\"hljs-keyword\">if</span> (i &lt; ada.weights.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>) {\r\n                out &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span>;\r\n            }\r\n        }\r\n        out &lt;&lt; <span class=\"hljs-string\">&quot;&gt;&quot;</span>;\r\n        <span class=\"hljs-keyword\">return</span> out;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * predict the output of the model for given set of features\r\n     * \\param[in] x input vector\r\n     * \\param[out] out optional argument to return neuron output before\r\n     * applying activation function (optional, `nullptr` to ignore) \\returns\r\n     * model prediction output\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">predict</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::vector&lt;<span class=\"hljs-type\">double</span>&gt; &amp;x, <span class=\"hljs-type\">double</span> *out = <span class=\"hljs-literal\">nullptr</span>)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">check_size_match</span>(x)) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n        }\r\n\r\n        <span class=\"hljs-type\">double</span> y = weights.<span class=\"hljs-built_in\">back</span>();  <span class=\"hljs-comment\">// assign bias value</span>\r\n\r\n        <span class=\"hljs-comment\">// for (int i = 0; i &lt; x.size(); i++) y += x[i] * weights[i];</span>\r\n        y = std::<span class=\"hljs-built_in\">inner_product</span>(x.<span class=\"hljs-built_in\">begin</span>(), x.<span class=\"hljs-built_in\">end</span>(), weights.<span class=\"hljs-built_in\">begin</span>(), y);\r\n\r\n        <span class=\"hljs-keyword\">if</span> (out != <span class=\"hljs-literal\">nullptr</span>) {  <span class=\"hljs-comment\">// if out variable is provided</span>\r\n            *out = y;\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">activation</span>(y);  <span class=\"hljs-comment\">// quantizer: apply ADALINE threshold function</span>\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Update the weights of the model using supervised learning for one\r\n     * feature vector\r\n     * \\param[in] x feature vector\r\n     * \\param[in] y known output value\r\n     * \\returns correction factor\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">fit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::vector&lt;<span class=\"hljs-type\">double</span>&gt; &amp;x, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> &amp;y)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">check_size_match</span>(x)) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n        }\r\n\r\n        <span class=\"hljs-comment\">/* output of the model with current weights */</span>\r\n        <span class=\"hljs-type\">int</span> p = <span class=\"hljs-built_in\">predict</span>(x);\r\n        <span class=\"hljs-type\">int</span> prediction_error = y - p;  <span class=\"hljs-comment\">// error in estimation</span>\r\n        <span class=\"hljs-type\">double</span> correction_factor = eta * prediction_error;\r\n\r\n        <span class=\"hljs-comment\">/* update each weight, the last weight is the bias term */</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; x.<span class=\"hljs-built_in\">size</span>(); i++) {\r\n            weights[i] += correction_factor * x[i];\r\n        }\r\n        weights[x.<span class=\"hljs-built_in\">size</span>()] += correction_factor;  <span class=\"hljs-comment\">// update bias</span>\r\n\r\n        <span class=\"hljs-keyword\">return</span> correction_factor;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Update the weights of the model using supervised learning for an\r\n     * array of vectors.\r\n     * \\param[in] X array of feature vector\r\n     * \\param[in] y known output value for each feature vector\r\n     */</span>\r\n    <span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-type\">size_t</span> N&gt;\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fit</span><span class=\"hljs-params\">(std::array&lt;std::vector&lt;<span class=\"hljs-type\">double</span>&gt;, N&gt; <span class=\"hljs-type\">const</span> &amp;X,\r\n             std::array&lt;<span class=\"hljs-type\">int</span>, N&gt; <span class=\"hljs-type\">const</span> &amp;Y)</span> </span>{\r\n        <span class=\"hljs-type\">double</span> avg_pred_error = <span class=\"hljs-number\">1.f</span>;\r\n\r\n        <span class=\"hljs-type\">int</span> iter = <span class=\"hljs-number\">0</span>;\r\n        <span class=\"hljs-keyword\">for</span> (iter = <span class=\"hljs-number\">0</span>; (iter &lt; MAX_ITER) &amp;&amp; (avg_pred_error &gt; accuracy);\r\n             iter++) {\r\n            avg_pred_error = <span class=\"hljs-number\">0.f</span>;\r\n\r\n            <span class=\"hljs-comment\">// perform fit for each sample</span>\r\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\r\n                <span class=\"hljs-type\">double</span> err = <span class=\"hljs-built_in\">fit</span>(X[i], Y[i]);\r\n                avg_pred_error += std::<span class=\"hljs-built_in\">abs</span>(err);\r\n            }\r\n            avg_pred_error /= N;\r\n\r\n            <span class=\"hljs-comment\">// Print updates every 200th iteration</span>\r\n            <span class=\"hljs-comment\">// if (iter % 100 == 0)</span>\r\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\tIter &quot;</span> &lt;&lt; iter &lt;&lt; <span class=\"hljs-string\">&quot;: Training weights: &quot;</span> &lt;&lt; *<span class=\"hljs-keyword\">this</span>\r\n                      &lt;&lt; <span class=\"hljs-string\">&quot;\\tAvg error: &quot;</span> &lt;&lt; avg_pred_error &lt;&lt; std::endl;\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">if</span> (iter &lt; MAX_ITER) {\r\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Converged after &quot;</span> &lt;&lt; iter &lt;&lt; <span class=\"hljs-string\">&quot; iterations.&quot;</span>\r\n                      &lt;&lt; std::endl;\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Did not converge after &quot;</span> &lt;&lt; iter &lt;&lt; <span class=\"hljs-string\">&quot; iterations.&quot;</span>\r\n                      &lt;&lt; std::endl;\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/** Defines activation function as Heaviside&#x27;s step function.\r\n     * \\f[\r\n     * f(x) = \\begin{cases}\r\n     * -1 &amp; \\forall x \\le 0\\\\\r\n     *  1 &amp; \\forall x &gt; 0\r\n     * \\end{cases}\r\n     * \\f]\r\n     * @param x input value to apply activation on\r\n     * @return activation output\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">activation</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> x)</span> </span>{ <span class=\"hljs-keyword\">return</span> x &gt; <span class=\"hljs-number\">0</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>; }\r\n\r\n <span class=\"hljs-keyword\">private</span>:\r\n    <span class=\"hljs-comment\">/**\r\n     * convenient function to check if input feature vector size matches the\r\n     * model weights size\r\n     * \\param[in] x fecture vector to check\r\n     * \\returns `true` size matches\r\n     * \\returns `false` size does not match\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">check_size_match</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::vector&lt;<span class=\"hljs-type\">double</span>&gt; &amp;x)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (x.<span class=\"hljs-built_in\">size</span>() != (weights.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>)) {\r\n            std::cerr &lt;&lt; __func__ &lt;&lt; <span class=\"hljs-string\">&quot;: &quot;</span>\r\n                      &lt;&lt; <span class=\"hljs-string\">&quot;Number of features in x does not match the feature &quot;</span>\r\n                         <span class=\"hljs-string\">&quot;dimension in model!&quot;</span>\r\n                      &lt;&lt; std::endl;\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n    }\r\n\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> eta;             <span class=\"hljs-comment\">///&lt; learning rate of the algorithm</span>\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> accuracy;        <span class=\"hljs-comment\">///&lt; model fit convergence accuracy</span>\r\n    std::vector&lt;<span class=\"hljs-type\">double</span>&gt; weights;  <span class=\"hljs-comment\">///&lt; weights of the neural network</span>\r\n};\r\n\r\n}  <span class=\"hljs-comment\">// namespace machine_learning</span>\r\n\r\n<span class=\"hljs-keyword\">using</span> machine_learning::adaline;\r\n\r\n<span class=\"hljs-comment\">/** @} */</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * test function to predict points in a 2D coordinate system above the line\r\n * \\f$x=y\\f$ as +1 and others as -1.\r\n * Note that each point is defined by 2 values or 2 features.\r\n * \\param[in] eta learning rate (optional, default=0.01)\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> eta = <span class=\"hljs-number\">0.01</span>)</span> </span>{\r\n    <span class=\"hljs-function\">adaline <span class=\"hljs-title\">ada</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>, eta)</span></span>;  <span class=\"hljs-comment\">// 2 features</span>\r\n\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N = <span class=\"hljs-number\">10</span>;  <span class=\"hljs-comment\">// number of sample points</span>\r\n\r\n    std::array&lt;std::vector&lt;<span class=\"hljs-type\">double</span>&gt;, N&gt; X = {\r\n        std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}),   std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-2</span>}),\r\n        std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}),   std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">-1</span>}),\r\n        std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>}),   std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">-5</span>}),\r\n        std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">-7</span>, <span class=\"hljs-number\">-3</span>}), std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">-8</span>, <span class=\"hljs-number\">5</span>}),\r\n        std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">-9</span>, <span class=\"hljs-number\">2</span>}),  std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">-10</span>, <span class=\"hljs-number\">-15</span>})};\r\n    std::array&lt;<span class=\"hljs-type\">int</span>, N&gt; y = {<span class=\"hljs-number\">1</span>,  <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>,\r\n                            <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>,  <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>,  <span class=\"hljs-number\">-1</span>};  <span class=\"hljs-comment\">// corresponding y-values</span>\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;------- Test 1 -------&quot;</span> &lt;&lt; std::endl;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Model before fit: &quot;</span> &lt;&lt; ada &lt;&lt; std::endl;\r\n\r\n    ada.<span class=\"hljs-built_in\">fit</span>&lt;N&gt;(X, y);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Model after fit: &quot;</span> &lt;&lt; ada &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-type\">int</span> predict = ada.<span class=\"hljs-built_in\">predict</span>({<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">-3</span>});\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Predict for x=(5,-3): &quot;</span> &lt;&lt; predict;\r\n    <span class=\"hljs-built_in\">assert</span>(predict == <span class=\"hljs-number\">-1</span>);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot; ...passed&quot;</span> &lt;&lt; std::endl;\r\n\r\n    predict = ada.<span class=\"hljs-built_in\">predict</span>({<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>});\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Predict for x=(5,8): &quot;</span> &lt;&lt; predict;\r\n    <span class=\"hljs-built_in\">assert</span>(predict == <span class=\"hljs-number\">1</span>);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot; ...passed&quot;</span> &lt;&lt; std::endl;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * test function to predict points in a 2D coordinate system above the line\r\n * \\f$x+3y=-1\\f$ as +1 and others as -1.\r\n * Note that each point is defined by 2 values or 2 features.\r\n * The function will create random sample points for training and test purposes.\r\n * \\param[in] eta learning rate (optional, default=0.01)\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> eta = <span class=\"hljs-number\">0.01</span>)</span> </span>{\r\n    <span class=\"hljs-function\">adaline <span class=\"hljs-title\">ada</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>, eta)</span></span>;  <span class=\"hljs-comment\">// 2 features</span>\r\n\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N = <span class=\"hljs-number\">50</span>;  <span class=\"hljs-comment\">// number of sample points</span>\r\n\r\n    std::array&lt;std::vector&lt;<span class=\"hljs-type\">double</span>&gt;, N&gt; X;\r\n    std::array&lt;<span class=\"hljs-type\">int</span>, N&gt; Y{};  <span class=\"hljs-comment\">// corresponding y-values</span>\r\n\r\n    <span class=\"hljs-comment\">// generate sample points in the interval</span>\r\n    <span class=\"hljs-comment\">// [-range2/100 , (range2-1)/100]</span>\r\n    <span class=\"hljs-type\">int</span> range = <span class=\"hljs-number\">500</span>;          <span class=\"hljs-comment\">// sample points full-range</span>\r\n    <span class=\"hljs-type\">int</span> range2 = range &gt;&gt; <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">// sample points half-range</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\r\n        <span class=\"hljs-type\">double</span> x0 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n        <span class=\"hljs-type\">double</span> x1 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n        X[i] = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({x0, x1});\r\n        Y[i] = (x0 + <span class=\"hljs-number\">3.</span> * x1) &gt; <span class=\"hljs-number\">-1</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>;\r\n    }\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;------- Test 2 -------&quot;</span> &lt;&lt; std::endl;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Model before fit: &quot;</span> &lt;&lt; ada &lt;&lt; std::endl;\r\n\r\n    ada.<span class=\"hljs-built_in\">fit</span>(X, Y);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Model after fit: &quot;</span> &lt;&lt; ada &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-type\">int</span> N_test_cases = <span class=\"hljs-number\">5</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N_test_cases; i++) {\r\n        <span class=\"hljs-type\">double</span> x0 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n        <span class=\"hljs-type\">double</span> x1 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n\r\n        <span class=\"hljs-type\">int</span> predict = ada.<span class=\"hljs-built_in\">predict</span>({x0, x1});\r\n\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Predict for x=(&quot;</span> &lt;&lt; x0 &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; x1 &lt;&lt; <span class=\"hljs-string\">&quot;): &quot;</span> &lt;&lt; predict;\r\n\r\n        <span class=\"hljs-type\">int</span> expected_val = (x0 + <span class=\"hljs-number\">3.</span> * x1) &gt; <span class=\"hljs-number\">-1</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>;\r\n        <span class=\"hljs-built_in\">assert</span>(predict == expected_val);\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot; ...passed&quot;</span> &lt;&lt; std::endl;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * test function to predict points in a 3D coordinate system lying within the\r\n * sphere of radius 1 and centre at origin as +1 and others as -1. Note that\r\n * each point is defined by 3 values but we use 6 features. The function will\r\n * create random sample points for training and test purposes.\r\n * The sphere centred at origin and radius 1 is defined as:\r\n * \\f$x^2+y^2+z^2=r^2=1\\f$ and if the \\f$r^2&lt;1\\f$, point lies within the sphere\r\n * else, outside.\r\n *\r\n * \\param[in] eta learning rate (optional, default=0.01)\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test3</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> eta = <span class=\"hljs-number\">0.01</span>)</span> </span>{\r\n    <span class=\"hljs-function\">adaline <span class=\"hljs-title\">ada</span><span class=\"hljs-params\">(<span class=\"hljs-number\">6</span>, eta)</span></span>;  <span class=\"hljs-comment\">// 2 features</span>\r\n\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N = <span class=\"hljs-number\">100</span>;  <span class=\"hljs-comment\">// number of sample points</span>\r\n\r\n    std::array&lt;std::vector&lt;<span class=\"hljs-type\">double</span>&gt;, N&gt; X;\r\n    std::array&lt;<span class=\"hljs-type\">int</span>, N&gt; Y{};  <span class=\"hljs-comment\">// corresponding y-values</span>\r\n\r\n    <span class=\"hljs-comment\">// generate sample points in the interval</span>\r\n    <span class=\"hljs-comment\">// [-range2/100 , (range2-1)/100]</span>\r\n    <span class=\"hljs-type\">int</span> range = <span class=\"hljs-number\">200</span>;          <span class=\"hljs-comment\">// sample points full-range</span>\r\n    <span class=\"hljs-type\">int</span> range2 = range &gt;&gt; <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">// sample points half-range</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\r\n        <span class=\"hljs-type\">double</span> x0 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n        <span class=\"hljs-type\">double</span> x1 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n        <span class=\"hljs-type\">double</span> x2 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n        X[i] = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({x0, x1, x2, x0 * x0, x1 * x1, x2 * x2});\r\n        Y[i] = ((x0 * x0) + (x1 * x1) + (x2 * x2)) &lt;= <span class=\"hljs-number\">1.f</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>;\r\n    }\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;------- Test 3 -------&quot;</span> &lt;&lt; std::endl;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Model before fit: &quot;</span> &lt;&lt; ada &lt;&lt; std::endl;\r\n\r\n    ada.<span class=\"hljs-built_in\">fit</span>(X, Y);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Model after fit: &quot;</span> &lt;&lt; ada &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-type\">int</span> N_test_cases = <span class=\"hljs-number\">5</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N_test_cases; i++) {\r\n        <span class=\"hljs-type\">double</span> x0 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n        <span class=\"hljs-type\">double</span> x1 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n        <span class=\"hljs-type\">double</span> x2 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n\r\n        <span class=\"hljs-type\">int</span> predict = ada.<span class=\"hljs-built_in\">predict</span>({x0, x1, x2, x0 * x0, x1 * x1, x2 * x2});\r\n\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Predict for x=(&quot;</span> &lt;&lt; x0 &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; x1 &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; x2\r\n                  &lt;&lt; <span class=\"hljs-string\">&quot;): &quot;</span> &lt;&lt; predict;\r\n\r\n        <span class=\"hljs-type\">int</span> expected_val = ((x0 * x0) + (x1 * x1) + (x2 * x2)) &lt;= <span class=\"hljs-number\">1.f</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>;\r\n        <span class=\"hljs-built_in\">assert</span>(predict == expected_val);\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot; ...passed&quot;</span> &lt;&lt; std::endl;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Main function */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span> </span>{\r\n    std::<span class=\"hljs-built_in\">srand</span>(std::<span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">nullptr</span>));  <span class=\"hljs-comment\">// initialize random number generator</span>\r\n\r\n    <span class=\"hljs-type\">double</span> eta = <span class=\"hljs-number\">0.1</span>;  <span class=\"hljs-comment\">// default value of eta</span>\r\n    <span class=\"hljs-keyword\">if</span> (argc == <span class=\"hljs-number\">2</span>) {   <span class=\"hljs-comment\">// read eta value from commandline argument if present</span>\r\n        eta = <span class=\"hljs-built_in\">strtof</span>(argv[<span class=\"hljs-number\">1</span>], <span class=\"hljs-literal\">nullptr</span>);\r\n    }\r\n\r\n    <span class=\"hljs-built_in\">test1</span>(eta);\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Press ENTER to continue...&quot;</span> &lt;&lt; std::endl;\r\n    std::cin.<span class=\"hljs-built_in\">get</span>();\r\n\r\n    <span class=\"hljs-built_in\">test2</span>(eta);\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Press ENTER to continue...&quot;</span> &lt;&lt; std::endl;\r\n    std::cin.<span class=\"hljs-built_in\">get</span>();\r\n\r\n    <span class=\"hljs-built_in\">test3</span>(eta);\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    },
    "c": {
      "dir": "machine_learning\\adaline_learning.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/machine_learning\\adaline_learning.c",
      "code": "<span class=\"hljs-comment\">/**\r\n * \\file\r\n * \\brief [Adaptive Linear Neuron\r\n * (ADALINE)](https://en.wikipedia.org/wiki/ADALINE) implementation\r\n * \\details\r\n * &lt;img\r\n * src=&quot;https://upload.wikimedia.org/wikipedia/commons/b/be/Adaline_flow_chart.gif&quot;\r\n * width=&quot;200px&quot;&gt;\r\n * [source](https://commons.wikimedia.org/wiki/File:Adaline_flow_chart.gif)\r\n * ADALINE is one of the first and simplest single layer artificial neural\r\n * network. The algorithm essentially implements a linear function\r\n * \\f[ f\\left(x_0,x_1,x_2,\\ldots\\right) =\r\n * \\sum_j x_jw_j+\\theta\r\n * \\f]\r\n * where \\f$x_j\\f$ are the input features of a sample, \\f$w_j\\f$ are the\r\n * coefficients of the linear function and \\f$\\theta\\f$ is a constant. If we\r\n * know the \\f$w_j\\f$, then for any given set of features, \\f$y\\f$ can be\r\n * computed. Computing the \\f$w_j\\f$ is a supervised learning algorithm wherein\r\n * a set of features and their corresponding outputs are given and weights are\r\n * computed using stochastic gradient descent method.\r\n * \\author [Krishna Vedala](https://github.com/kvedala)\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;limits.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;math.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdbool.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;time.h&gt;</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @addtogroup machine_learning Machine learning algorithms\r\n * @{\r\n * @addtogroup adaline Adaline learning algorithm\r\n * @{\r\n */</span>\r\n\r\n<span class=\"hljs-comment\">/** Maximum number of iterations to learn */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> MAX_ADALINE_ITER 500  <span class=\"hljs-comment\">// INT_MAX</span></span>\r\n\r\n<span class=\"hljs-comment\">/** structure to hold adaline model parameters */</span>\r\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">adaline</span>\r\n{</span>\r\n    <span class=\"hljs-type\">double</span> eta;      <span class=\"hljs-comment\">/**&lt; learning rate of the algorithm */</span>\r\n    <span class=\"hljs-type\">double</span> *weights; <span class=\"hljs-comment\">/**&lt; weights of the neural network */</span>\r\n    <span class=\"hljs-type\">int</span> num_weights; <span class=\"hljs-comment\">/**&lt; number of weights of the neural network */</span>\r\n};\r\n\r\n<span class=\"hljs-comment\">/** convergence accuracy \\f$=1\\times10^{-5}\\f$ */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ADALINE_ACCURACY 1e-5</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Default constructor\r\n * \\param[in] num_features number of features present\r\n * \\param[in] eta learning rate (optional, default=0.1)\r\n * \\returns new adaline model\r\n */</span>\r\n<span class=\"hljs-keyword\">struct</span> adaline <span class=\"hljs-title function_\">new_adaline</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> num_features, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> eta)</span>\r\n{\r\n    <span class=\"hljs-keyword\">if</span> (eta &lt;= <span class=\"hljs-number\">0.f</span> || eta &gt;= <span class=\"hljs-number\">1.f</span>)\r\n    {\r\n        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;learning rate should be &gt; 0 and &lt; 1\\n&quot;</span>);\r\n        <span class=\"hljs-built_in\">exit</span>(EXIT_FAILURE);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// additional weight is for the constant bias term</span>\r\n    <span class=\"hljs-type\">int</span> num_weights = num_features + <span class=\"hljs-number\">1</span>;\r\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">adaline</span> <span class=\"hljs-title\">ada</span>;</span>\r\n    ada.eta = eta;\r\n    ada.num_weights = num_weights;\r\n    ada.weights = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(num_weights * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\r\n    <span class=\"hljs-keyword\">if</span> (!ada.weights)\r\n    {\r\n        perror(<span class=\"hljs-string\">&quot;Unable to allocate error for weights!&quot;</span>);\r\n        <span class=\"hljs-keyword\">return</span> ada;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// initialize with random weights in the range [-50, 49]</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; num_weights; i++) ada.weights[i] = <span class=\"hljs-number\">1.f</span>;\r\n    <span class=\"hljs-comment\">// ada.weights[i] = (double)(rand() % 100) - 50);</span>\r\n\r\n    <span class=\"hljs-keyword\">return</span> ada;\r\n}\r\n\r\n<span class=\"hljs-comment\">/** delete dynamically allocated memory\r\n * \\param[in] ada model from which the memory is to be freed.\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">delete_adaline</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> adaline *ada)</span>\r\n{\r\n    <span class=\"hljs-keyword\">if</span> (ada == <span class=\"hljs-literal\">NULL</span>)\r\n        <span class=\"hljs-keyword\">return</span>;\r\n\r\n    <span class=\"hljs-built_in\">free</span>(ada-&gt;weights);\r\n};\r\n\r\n<span class=\"hljs-comment\">/** [Heaviside activation\r\n * function](https://en.wikipedia.org/wiki/Heaviside_step_function) &lt;img\r\n * src=&quot;https://upload.wikimedia.org/wikipedia/commons/d/d9/Dirac_distribution_CDF.svg&quot;\r\n * width=&quot;200px&quot;/&gt;\r\n * @param x activation function input\r\n * @returns \\f$f(x)= \\begin{cases}1 &amp; \\forall\\; x &gt; 0\\\\ -1 &amp; \\forall\\; x \\le0\r\n * \\end{cases}\\f$\r\n */</span>\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">adaline_activation</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> x)</span> { <span class=\"hljs-keyword\">return</span> x &gt; <span class=\"hljs-number\">0</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>; }\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Operator to print the weights of the model\r\n * @param ada model for which the values to print\r\n * @returns pointer to a NULL terminated string of formatted weights\r\n */</span>\r\n<span class=\"hljs-type\">char</span> *<span class=\"hljs-title function_\">adaline_get_weights_str</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">struct</span> adaline *ada)</span>\r\n{\r\n    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> out[<span class=\"hljs-number\">100</span>];  <span class=\"hljs-comment\">// static so the value is persistent</span>\r\n\r\n    <span class=\"hljs-built_in\">sprintf</span>(out, <span class=\"hljs-string\">&quot;&lt;&quot;</span>);\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; ada-&gt;num_weights; i++)\r\n    {\r\n        <span class=\"hljs-built_in\">sprintf</span>(out, <span class=\"hljs-string\">&quot;%s%.4g&quot;</span>, out, ada-&gt;weights[i]);\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; ada-&gt;num_weights - <span class=\"hljs-number\">1</span>)\r\n            <span class=\"hljs-built_in\">sprintf</span>(out, <span class=\"hljs-string\">&quot;%s, &quot;</span>, out);\r\n    }\r\n    <span class=\"hljs-built_in\">sprintf</span>(out, <span class=\"hljs-string\">&quot;%s&gt;&quot;</span>, out);\r\n    <span class=\"hljs-keyword\">return</span> out;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * predict the output of the model for given set of features\r\n *\r\n * \\param[in] ada adaline model to predict\r\n * \\param[in] x input vector\r\n * \\param[out] out optional argument to return neuron output before applying\r\n * activation function (`NULL` to ignore)\r\n * \\returns model prediction output\r\n */</span>\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">adaline_predict</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> adaline *ada, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> *x, <span class=\"hljs-type\">double</span> *out)</span>\r\n{\r\n    <span class=\"hljs-type\">double</span> y = ada-&gt;weights[ada-&gt;num_weights - <span class=\"hljs-number\">1</span>];  <span class=\"hljs-comment\">// assign bias value</span>\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; ada-&gt;num_weights - <span class=\"hljs-number\">1</span>; i++) y += x[i] * ada-&gt;weights[i];\r\n\r\n    <span class=\"hljs-keyword\">if</span> (out)  <span class=\"hljs-comment\">// if out variable is not NULL</span>\r\n        *out = y;\r\n\r\n    <span class=\"hljs-comment\">// quantizer: apply ADALINE threshold function</span>\r\n    <span class=\"hljs-keyword\">return</span> adaline_activation(y);\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Update the weights of the model using supervised learning for one feature\r\n * vector\r\n *\r\n * \\param[in] ada adaline model to fit\r\n * \\param[in] x feature vector\r\n * \\param[in] y known output  value\r\n * \\returns correction factor\r\n */</span>\r\n<span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">adaline_fit_sample</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> adaline *ada, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> *x, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> y)</span>\r\n{\r\n    <span class=\"hljs-comment\">/* output of the model with current weights */</span>\r\n    <span class=\"hljs-type\">int</span> p = adaline_predict(ada, x, <span class=\"hljs-literal\">NULL</span>);\r\n    <span class=\"hljs-type\">int</span> prediction_error = y - p;  <span class=\"hljs-comment\">// error in estimation</span>\r\n    <span class=\"hljs-type\">double</span> correction_factor = ada-&gt;eta * prediction_error;\r\n\r\n    <span class=\"hljs-comment\">/* update each weight, the last weight is the bias term */</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; ada-&gt;num_weights - <span class=\"hljs-number\">1</span>; i++)\r\n    {\r\n        ada-&gt;weights[i] += correction_factor * x[i];\r\n    }\r\n    ada-&gt;weights[ada-&gt;num_weights - <span class=\"hljs-number\">1</span>] += correction_factor;  <span class=\"hljs-comment\">// update bias</span>\r\n\r\n    <span class=\"hljs-keyword\">return</span> correction_factor;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Update the weights of the model using supervised learning for an array of\r\n * vectors.\r\n *\r\n * \\param[in] ada adaline model to train\r\n * \\param[in] X array of feature vector\r\n * \\param[in] y known output value for each feature vector\r\n * \\param[in] N number of training samples\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">adaline_fit</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> adaline *ada, <span class=\"hljs-type\">double</span> **X, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *y, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N)</span>\r\n{\r\n    <span class=\"hljs-type\">double</span> avg_pred_error = <span class=\"hljs-number\">1.f</span>;\r\n\r\n    <span class=\"hljs-type\">int</span> iter;\r\n    <span class=\"hljs-keyword\">for</span> (iter = <span class=\"hljs-number\">0</span>;\r\n         (iter &lt; MAX_ADALINE_ITER) &amp;&amp; (avg_pred_error &gt; ADALINE_ACCURACY);\r\n         iter++)\r\n    {\r\n        avg_pred_error = <span class=\"hljs-number\">0.f</span>;\r\n\r\n        <span class=\"hljs-comment\">// perform fit for each sample</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\r\n        {\r\n            <span class=\"hljs-type\">double</span> err = adaline_fit_sample(ada, X[i], y[i]);\r\n            avg_pred_error += <span class=\"hljs-built_in\">fabs</span>(err);\r\n        }\r\n        avg_pred_error /= N;\r\n\r\n        <span class=\"hljs-comment\">// Print updates every 200th iteration</span>\r\n        <span class=\"hljs-comment\">// if (iter % 100 == 0)</span>\r\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\tIter %3d: Training weights: %s\\tAvg error: %.4f\\n&quot;</span>, iter,\r\n               adaline_get_weights_str(ada), avg_pred_error);\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">if</span> (iter &lt; MAX_ADALINE_ITER)\r\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Converged after %d iterations.\\n&quot;</span>, iter);\r\n    <span class=\"hljs-keyword\">else</span>\r\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Did not converged after %d iterations.\\n&quot;</span>, iter);\r\n}\r\n\r\n<span class=\"hljs-comment\">/** @}\r\n *  @}\r\n */</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * test function to predict points in a 2D coordinate system above the line\r\n * \\f$x=y\\f$ as +1 and others as -1.\r\n * Note that each point is defined by 2 values or 2 features.\r\n * \\param[in] eta learning rate (optional, default=0.01)\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> eta)</span>\r\n{\r\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">adaline</span> <span class=\"hljs-title\">ada</span> =</span> new_adaline(<span class=\"hljs-number\">2</span>, eta);  <span class=\"hljs-comment\">// 2 features</span>\r\n\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N = <span class=\"hljs-number\">10</span>;  <span class=\"hljs-comment\">// number of sample points</span>\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> saved_X[<span class=\"hljs-number\">10</span>][<span class=\"hljs-number\">2</span>] = {{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>},  {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-2</span>},   {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>},   {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">-1</span>},\r\n                                   {<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>},  {<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">-5</span>},   {<span class=\"hljs-number\">-7</span>, <span class=\"hljs-number\">-3</span>}, {<span class=\"hljs-number\">-8</span>, <span class=\"hljs-number\">5</span>},\r\n                                   {<span class=\"hljs-number\">-9</span>, <span class=\"hljs-number\">2</span>}, {<span class=\"hljs-number\">-10</span>, <span class=\"hljs-number\">-15</span>}};\r\n\r\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> Y[<span class=\"hljs-number\">10</span>] = {<span class=\"hljs-number\">1</span>,  <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>,\r\n                       <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>,  <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>,  <span class=\"hljs-number\">-1</span>};  <span class=\"hljs-comment\">// corresponding y-values</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\r\n    {\r\n        X[i] = (<span class=\"hljs-type\">double</span> *)saved_X[i];\r\n    }\r\n\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;------- Test 1 -------\\n&quot;</span>);\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Model before fit: %s\\n&quot;</span>, adaline_get_weights_str(&amp;ada));\r\n\r\n    adaline_fit(&amp;ada, X, Y, N);\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Model after fit: %s\\n&quot;</span>, adaline_get_weights_str(&amp;ada));\r\n\r\n    <span class=\"hljs-type\">double</span> test_x[] = {<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">-3</span>};\r\n    <span class=\"hljs-type\">int</span> pred = adaline_predict(&amp;ada, test_x, <span class=\"hljs-literal\">NULL</span>);\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Predict for x=(5,-3): % d\\n&quot;</span>, pred);\r\n    assert(pred == <span class=\"hljs-number\">-1</span>);\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot; ...passed\\n&quot;</span>);\r\n\r\n    <span class=\"hljs-type\">double</span> test_x2[] = {<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>};\r\n    pred = adaline_predict(&amp;ada, test_x2, <span class=\"hljs-literal\">NULL</span>);\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Predict for x=(5, 8): % d\\n&quot;</span>, pred);\r\n    assert(pred == <span class=\"hljs-number\">1</span>);\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot; ...passed\\n&quot;</span>);\r\n\r\n    <span class=\"hljs-comment\">// for (int i = 0; i &lt; N; i++)</span>\r\n    <span class=\"hljs-comment\">//     free(X[i]);</span>\r\n    <span class=\"hljs-built_in\">free</span>(X);\r\n    delete_adaline(&amp;ada);\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * test function to predict points in a 2D coordinate system above the line\r\n * \\f$x+3y=-1\\f$ as +1 and others as -1.\r\n * Note that each point is defined by 2 values or 2 features.\r\n * The function will create random sample points for training and test purposes.\r\n * \\param[in] eta learning rate (optional, default=0.01)\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> eta)</span>\r\n{\r\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">adaline</span> <span class=\"hljs-title\">ada</span> =</span> new_adaline(<span class=\"hljs-number\">2</span>, eta);  <span class=\"hljs-comment\">// 2 features</span>\r\n\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N = <span class=\"hljs-number\">50</span>;  <span class=\"hljs-comment\">// number of sample points</span>\r\n\r\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\r\n    <span class=\"hljs-type\">int</span> *Y = (<span class=\"hljs-type\">int</span> *)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>));  <span class=\"hljs-comment\">// corresponding y-values</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) X[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">2</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\r\n\r\n    <span class=\"hljs-comment\">// generate sample points in the interval</span>\r\n    <span class=\"hljs-comment\">// [-range2/100 , (range2-1)/100]</span>\r\n    <span class=\"hljs-type\">int</span> range = <span class=\"hljs-number\">500</span>;          <span class=\"hljs-comment\">// sample points full-range</span>\r\n    <span class=\"hljs-type\">int</span> range2 = range &gt;&gt; <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">// sample points half-range</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\r\n    {\r\n        <span class=\"hljs-type\">double</span> x0 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n        <span class=\"hljs-type\">double</span> x1 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n        X[i][<span class=\"hljs-number\">0</span>] = x0;\r\n        X[i][<span class=\"hljs-number\">1</span>] = x1;\r\n        Y[i] = (x0 + <span class=\"hljs-number\">3.</span> * x1) &gt; <span class=\"hljs-number\">-1</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>;\r\n    }\r\n\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;------- Test 2 -------\\n&quot;</span>);\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Model before fit: %s\\n&quot;</span>, adaline_get_weights_str(&amp;ada));\r\n\r\n    adaline_fit(&amp;ada, X, Y, N);\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Model after fit: %s\\n&quot;</span>, adaline_get_weights_str(&amp;ada));\r\n\r\n    <span class=\"hljs-type\">int</span> N_test_cases = <span class=\"hljs-number\">5</span>;\r\n    <span class=\"hljs-type\">double</span> test_x[<span class=\"hljs-number\">2</span>];\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N_test_cases; i++)\r\n    {\r\n        <span class=\"hljs-type\">double</span> x0 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n        <span class=\"hljs-type\">double</span> x1 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n\r\n        test_x[<span class=\"hljs-number\">0</span>] = x0;\r\n        test_x[<span class=\"hljs-number\">1</span>] = x1;\r\n        <span class=\"hljs-type\">int</span> pred = adaline_predict(&amp;ada, test_x, <span class=\"hljs-literal\">NULL</span>);\r\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Predict for x=(% 3.2f,% 3.2f): % d\\n&quot;</span>, x0, x1, pred);\r\n\r\n        <span class=\"hljs-type\">int</span> expected_val = (x0 + <span class=\"hljs-number\">3.</span> * x1) &gt; <span class=\"hljs-number\">-1</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>;\r\n        assert(pred == expected_val);\r\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot; ...passed\\n&quot;</span>);\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) <span class=\"hljs-built_in\">free</span>(X[i]);\r\n    <span class=\"hljs-built_in\">free</span>(X);\r\n    <span class=\"hljs-built_in\">free</span>(Y);\r\n    delete_adaline(&amp;ada);\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * test function to predict points in a 3D coordinate system lying within the\r\n * sphere of radius 1 and centre at origin as +1 and others as -1. Note that\r\n * each point is defined by 3 values but we use 6 features. The function will\r\n * create random sample points for training and test purposes.\r\n * The sphere centred at origin and radius 1 is defined as:\r\n * \\f$x^2+y^2+z^2=r^2=1\\f$ and if the \\f$r^2&lt;1\\f$, point lies within the sphere\r\n * else, outside.\r\n *\r\n * \\param[in] eta learning rate (optional, default=0.01)\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test3</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> eta)</span>\r\n{\r\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">adaline</span> <span class=\"hljs-title\">ada</span> =</span> new_adaline(<span class=\"hljs-number\">6</span>, eta);  <span class=\"hljs-comment\">// 2 features</span>\r\n\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N = <span class=\"hljs-number\">50</span>;  <span class=\"hljs-comment\">// number of sample points</span>\r\n\r\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\r\n    <span class=\"hljs-type\">int</span> *Y = (<span class=\"hljs-type\">int</span> *)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>));  <span class=\"hljs-comment\">// corresponding y-values</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) X[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">6</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\r\n\r\n    <span class=\"hljs-comment\">// generate sample points in the interval</span>\r\n    <span class=\"hljs-comment\">// [-range2/100 , (range2-1)/100]</span>\r\n    <span class=\"hljs-type\">int</span> range = <span class=\"hljs-number\">200</span>;          <span class=\"hljs-comment\">// sample points full-range</span>\r\n    <span class=\"hljs-type\">int</span> range2 = range &gt;&gt; <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">// sample points half-range</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\r\n    {\r\n        <span class=\"hljs-type\">double</span> x0 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n        <span class=\"hljs-type\">double</span> x1 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n        <span class=\"hljs-type\">double</span> x2 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n        X[i][<span class=\"hljs-number\">0</span>] = x0;\r\n        X[i][<span class=\"hljs-number\">1</span>] = x1;\r\n        X[i][<span class=\"hljs-number\">2</span>] = x2;\r\n        X[i][<span class=\"hljs-number\">3</span>] = x0 * x0;\r\n        X[i][<span class=\"hljs-number\">4</span>] = x1 * x1;\r\n        X[i][<span class=\"hljs-number\">5</span>] = x2 * x2;\r\n        Y[i] = (x0 * x0 + x1 * x1 + x2 * x2) &lt;= <span class=\"hljs-number\">1</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>;\r\n    }\r\n\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;------- Test 3 -------\\n&quot;</span>);\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Model before fit: %s\\n&quot;</span>, adaline_get_weights_str(&amp;ada));\r\n\r\n    adaline_fit(&amp;ada, X, Y, N);\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Model after fit: %s\\n&quot;</span>, adaline_get_weights_str(&amp;ada));\r\n\r\n    <span class=\"hljs-type\">int</span> N_test_cases = <span class=\"hljs-number\">5</span>;\r\n    <span class=\"hljs-type\">double</span> test_x[<span class=\"hljs-number\">6</span>];\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N_test_cases; i++)\r\n    {\r\n        <span class=\"hljs-type\">double</span> x0 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n        <span class=\"hljs-type\">double</span> x1 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n        <span class=\"hljs-type\">double</span> x2 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\r\n        test_x[<span class=\"hljs-number\">0</span>] = x0;\r\n        test_x[<span class=\"hljs-number\">1</span>] = x1;\r\n        test_x[<span class=\"hljs-number\">2</span>] = x2;\r\n        test_x[<span class=\"hljs-number\">3</span>] = x0 * x0;\r\n        test_x[<span class=\"hljs-number\">4</span>] = x1 * x1;\r\n        test_x[<span class=\"hljs-number\">5</span>] = x2 * x2;\r\n        <span class=\"hljs-type\">int</span> pred = adaline_predict(&amp;ada, test_x, <span class=\"hljs-literal\">NULL</span>);\r\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Predict for x=(% 3.2f,% 3.2f): % d\\n&quot;</span>, x0, x1, pred);\r\n\r\n        <span class=\"hljs-type\">int</span> expected_val = (x0 * x0 + x1 * x1 + x2 * x2) &lt;= <span class=\"hljs-number\">1</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>;\r\n        assert(pred == expected_val);\r\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot; ...passed\\n&quot;</span>);\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) <span class=\"hljs-built_in\">free</span>(X[i]);\r\n    <span class=\"hljs-built_in\">free</span>(X);\r\n    <span class=\"hljs-built_in\">free</span>(Y);\r\n    delete_adaline(&amp;ada);\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Main function */</span>\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span>\r\n{\r\n    srand(time(<span class=\"hljs-literal\">NULL</span>));  <span class=\"hljs-comment\">// initialize random number generator</span>\r\n\r\n    <span class=\"hljs-type\">double</span> eta = <span class=\"hljs-number\">0.1</span>;  <span class=\"hljs-comment\">// default value of eta</span>\r\n    <span class=\"hljs-keyword\">if</span> (argc == <span class=\"hljs-number\">2</span>)     <span class=\"hljs-comment\">// read eta value from commandline argument if present</span>\r\n        eta = strtof(argv[<span class=\"hljs-number\">1</span>], <span class=\"hljs-literal\">NULL</span>);\r\n\r\n    test1(eta);\r\n\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Press ENTER to continue...\\n&quot;</span>);\r\n    getchar();\r\n\r\n    test2(eta);\r\n\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Press ENTER to continue...\\n&quot;</span>);\r\n    getchar();\r\n\r\n    test3(eta);\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Piyush Kumar",
      "email": "81097447+piyush168713@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 11
    }
  ],
  "explanationUrl": {}
}