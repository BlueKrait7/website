{
  "slug": "optimal-binary-search-tree",
  "name": "Optimal Binary Search Tree",
  "categories": [
    "dynamicprogramming"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "dynamic_programming\\optimal_binary_search_tree.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/dynamic_programming\\optimal_binary_search_tree.py",
      "code": "<span class=\"hljs-comment\">#!/usr/bin/env python3</span>\r\n\r\n<span class=\"hljs-comment\"># This Python program implements an optimal binary search tree (abbreviated BST)</span>\r\n<span class=\"hljs-comment\"># building dynamic programming algorithm that delivers O(n^2) performance.</span>\r\n<span class=\"hljs-comment\">#</span>\r\n<span class=\"hljs-comment\"># The goal of the optimal BST problem is to build a low-cost BST for a</span>\r\n<span class=\"hljs-comment\"># given set of nodes, each with its own key and frequency. The frequency</span>\r\n<span class=\"hljs-comment\"># of the node is defined as how many time the node is being searched.</span>\r\n<span class=\"hljs-comment\"># The search cost of binary search tree is given by this formula:</span>\r\n<span class=\"hljs-comment\">#</span>\r\n<span class=\"hljs-comment\"># cost(1, n) = sum{i = 1 to n}((depth(node_i) + 1) * node_i_freq)</span>\r\n<span class=\"hljs-comment\">#</span>\r\n<span class=\"hljs-comment\"># where n is number of nodes in the BST. The characteristic of low-cost</span>\r\n<span class=\"hljs-comment\"># BSTs is having a faster overall search time than other implementations.</span>\r\n<span class=\"hljs-comment\"># The reason for their fast search time is that the nodes with high</span>\r\n<span class=\"hljs-comment\"># frequencies will be placed near the root of the tree while the nodes</span>\r\n<span class=\"hljs-comment\"># with low frequencies will be placed near the leaves of the tree thus</span>\r\n<span class=\"hljs-comment\"># reducing search time in the most frequent instances.</span>\r\n<span class=\"hljs-keyword\">import</span> sys\r\n<span class=\"hljs-keyword\">from</span> random <span class=\"hljs-keyword\">import</span> randint\r\n\r\n\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;Binary Search Tree Node&quot;&quot;&quot;</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, key, freq</span>):\r\n        self.key = key\r\n        self.freq = freq\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__str__</span>(<span class=\"hljs-params\">self</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        &gt;&gt;&gt; str(Node(1, 2))\r\n        &#x27;Node(key=1, freq=2)&#x27;\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">f&quot;Node(key=<span class=\"hljs-subst\">{self.key}</span>, freq=<span class=\"hljs-subst\">{self.freq}</span>)&quot;</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print_binary_search_tree</span>(<span class=\"hljs-params\">root, key, i, j, parent, is_left</span>):\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Recursive function to print a BST from a root table.\r\n\r\n    &gt;&gt;&gt; key = [3, 8, 9, 10, 17, 21]\r\n    &gt;&gt;&gt; root = [[0, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 3], [0, 0, 2, 3, 3, 3], \\\r\n                [0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 4, 5], [0, 0, 0, 0, 0, 5]]\r\n    &gt;&gt;&gt; print_binary_search_tree(root, key, 0, 5, -1, False)\r\n    8 is the root of the binary search tree.\r\n    3 is the left child of key 8.\r\n    10 is the right child of key 8.\r\n    9 is the left child of key 10.\r\n    21 is the right child of key 10.\r\n    17 is the left child of key 21.\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-keyword\">if</span> i &gt; j <span class=\"hljs-keyword\">or</span> i &lt; <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">or</span> j &gt; <span class=\"hljs-built_in\">len</span>(root) - <span class=\"hljs-number\">1</span>:\r\n        <span class=\"hljs-keyword\">return</span>\r\n\r\n    node = root[i][j]\r\n    <span class=\"hljs-keyword\">if</span> parent == -<span class=\"hljs-number\">1</span>:  <span class=\"hljs-comment\"># root does not have a parent</span>\r\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;<span class=\"hljs-subst\">{key[node]}</span> is the root of the binary search tree.&quot;</span>)\r\n    <span class=\"hljs-keyword\">elif</span> is_left:\r\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;<span class=\"hljs-subst\">{key[node]}</span> is the left child of key <span class=\"hljs-subst\">{parent}</span>.&quot;</span>)\r\n    <span class=\"hljs-keyword\">else</span>:\r\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;<span class=\"hljs-subst\">{key[node]}</span> is the right child of key <span class=\"hljs-subst\">{parent}</span>.&quot;</span>)\r\n\r\n    print_binary_search_tree(root, key, i, node - <span class=\"hljs-number\">1</span>, key[node], <span class=\"hljs-literal\">True</span>)\r\n    print_binary_search_tree(root, key, node + <span class=\"hljs-number\">1</span>, j, key[node], <span class=\"hljs-literal\">False</span>)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">find_optimal_binary_search_tree</span>(<span class=\"hljs-params\">nodes</span>):\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    This function calculates and prints the optimal binary search tree.\r\n    The dynamic programming algorithm below runs in O(n^2) time.\r\n    Implemented from CLRS (Introduction to Algorithms) book.\r\n    https://en.wikipedia.org/wiki/Introduction_to_Algorithms\r\n\r\n    &gt;&gt;&gt; find_optimal_binary_search_tree([Node(12, 8), Node(10, 34), Node(20, 50), \\\r\n                                         Node(42, 3), Node(25, 40), Node(37, 30)])\r\n    Binary search tree nodes:\r\n    Node(key=10, freq=34)\r\n    Node(key=12, freq=8)\r\n    Node(key=20, freq=50)\r\n    Node(key=25, freq=40)\r\n    Node(key=37, freq=30)\r\n    Node(key=42, freq=3)\r\n    &lt;BLANKLINE&gt;\r\n    The cost of optimal BST for given tree nodes is 324.\r\n    20 is the root of the binary search tree.\r\n    10 is the left child of key 20.\r\n    12 is the right child of key 10.\r\n    25 is the right child of key 20.\r\n    37 is the right child of key 25.\r\n    42 is the right child of key 37.\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-comment\"># Tree nodes must be sorted first, the code below sorts the keys in</span>\r\n    <span class=\"hljs-comment\"># increasing order and rearrange its frequencies accordingly.</span>\r\n    nodes.sort(key=<span class=\"hljs-keyword\">lambda</span> node: node.key)\r\n\r\n    n = <span class=\"hljs-built_in\">len</span>(nodes)\r\n\r\n    keys = [nodes[i].key <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n)]\r\n    freqs = [nodes[i].freq <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n)]\r\n\r\n    <span class=\"hljs-comment\"># This 2D array stores the overall tree cost (which&#x27;s as minimized as possible);</span>\r\n    <span class=\"hljs-comment\"># for a single key, cost is equal to frequency of the key.</span>\r\n    dp = [[freqs[i] <span class=\"hljs-keyword\">if</span> i == j <span class=\"hljs-keyword\">else</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n)] <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n)]\r\n    <span class=\"hljs-comment\"># sum[i][j] stores the sum of key frequencies between i and j inclusive in nodes</span>\r\n    <span class=\"hljs-comment\"># array</span>\r\n    <span class=\"hljs-built_in\">sum</span> = [[freqs[i] <span class=\"hljs-keyword\">if</span> i == j <span class=\"hljs-keyword\">else</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n)] <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n)]\r\n    <span class=\"hljs-comment\"># stores tree roots that will be used later for constructing binary search tree</span>\r\n    root = [[i <span class=\"hljs-keyword\">if</span> i == j <span class=\"hljs-keyword\">else</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n)] <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n)]\r\n\r\n    <span class=\"hljs-keyword\">for</span> interval_length <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">2</span>, n + <span class=\"hljs-number\">1</span>):\r\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n - interval_length + <span class=\"hljs-number\">1</span>):\r\n            j = i + interval_length - <span class=\"hljs-number\">1</span>\r\n\r\n            dp[i][j] = sys.maxsize  <span class=\"hljs-comment\"># set the value to &quot;infinity&quot;</span>\r\n            <span class=\"hljs-built_in\">sum</span>[i][j] = <span class=\"hljs-built_in\">sum</span>[i][j - <span class=\"hljs-number\">1</span>] + freqs[j]\r\n\r\n            <span class=\"hljs-comment\"># Apply Knuth&#x27;s optimization</span>\r\n            <span class=\"hljs-comment\"># Loop without optimization: for r in range(i, j + 1):</span>\r\n            <span class=\"hljs-keyword\">for</span> r <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(root[i][j - <span class=\"hljs-number\">1</span>], root[i + <span class=\"hljs-number\">1</span>][j] + <span class=\"hljs-number\">1</span>):  <span class=\"hljs-comment\"># r is a temporal root</span>\r\n                left = dp[i][r - <span class=\"hljs-number\">1</span>] <span class=\"hljs-keyword\">if</span> r != i <span class=\"hljs-keyword\">else</span> <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\"># optimal cost for left subtree</span>\r\n                right = dp[r + <span class=\"hljs-number\">1</span>][j] <span class=\"hljs-keyword\">if</span> r != j <span class=\"hljs-keyword\">else</span> <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\"># optimal cost for right subtree</span>\r\n                cost = left + <span class=\"hljs-built_in\">sum</span>[i][j] + right\r\n\r\n                <span class=\"hljs-keyword\">if</span> dp[i][j] &gt; cost:\r\n                    dp[i][j] = cost\r\n                    root[i][j] = r\r\n\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Binary search tree nodes:&quot;</span>)\r\n    <span class=\"hljs-keyword\">for</span> node <span class=\"hljs-keyword\">in</span> nodes:\r\n        <span class=\"hljs-built_in\">print</span>(node)\r\n\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;\\nThe cost of optimal BST for given tree nodes is <span class=\"hljs-subst\">{dp[<span class=\"hljs-number\">0</span>][n - <span class=\"hljs-number\">1</span>]}</span>.&quot;</span>)\r\n    print_binary_search_tree(root, keys, <span class=\"hljs-number\">0</span>, n - <span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">False</span>)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">main</span>():\r\n    <span class=\"hljs-comment\"># A sample binary search tree</span>\r\n    nodes = [Node(i, randint(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">50</span>)) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">1</span>)]\r\n    find_optimal_binary_search_tree(nodes)\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    main()\r\n"
    }
  },
  "contributors": [
    {
      "name": "onlinejudge95",
      "email": "44158581+onlinejudge95@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Jimmy Y",
      "email": "codingExpert123@gmail.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}