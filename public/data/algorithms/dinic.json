{
  "slug": "dinic",
  "name": "Dinic",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "graphs\\dinic.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/graphs\\dinic.py",
      "code": "INF = <span class=\"hljs-built_in\">float</span>(<span class=\"hljs-string\">&quot;inf&quot;</span>)\r\n\r\n\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dinic</span>:\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, n</span>):\r\n        self.lvl = [<span class=\"hljs-number\">0</span>] * n\r\n        self.ptr = [<span class=\"hljs-number\">0</span>] * n\r\n        self.q = [<span class=\"hljs-number\">0</span>] * n\r\n        self.adj = [[] <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n)]\r\n\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Here we will add our edges containing with the following parameters:\r\n    vertex closest to source, vertex closest to sink and flow capacity\r\n    through that edge ...\r\n    &quot;&quot;&quot;</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_edge</span>(<span class=\"hljs-params\">self, a, b, c, rcap=<span class=\"hljs-number\">0</span></span>):\r\n        self.adj[a].append([b, <span class=\"hljs-built_in\">len</span>(self.adj[b]), c, <span class=\"hljs-number\">0</span>])\r\n        self.adj[b].append([a, <span class=\"hljs-built_in\">len</span>(self.adj[a]) - <span class=\"hljs-number\">1</span>, rcap, <span class=\"hljs-number\">0</span>])\r\n\r\n    <span class=\"hljs-comment\"># This is a sample depth first search to be used at max_flow</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">depth_first_search</span>(<span class=\"hljs-params\">self, vertex, sink, flow</span>):\r\n        <span class=\"hljs-keyword\">if</span> vertex == sink <span class=\"hljs-keyword\">or</span> <span class=\"hljs-keyword\">not</span> flow:\r\n            <span class=\"hljs-keyword\">return</span> flow\r\n\r\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(self.ptr[vertex], <span class=\"hljs-built_in\">len</span>(self.adj[vertex])):\r\n            e = self.adj[vertex][i]\r\n            <span class=\"hljs-keyword\">if</span> self.lvl[e[<span class=\"hljs-number\">0</span>]] == self.lvl[vertex] + <span class=\"hljs-number\">1</span>:\r\n                p = self.depth_first_search(e[<span class=\"hljs-number\">0</span>], sink, <span class=\"hljs-built_in\">min</span>(flow, e[<span class=\"hljs-number\">2</span>] - e[<span class=\"hljs-number\">3</span>]))\r\n                <span class=\"hljs-keyword\">if</span> p:\r\n                    self.adj[vertex][i][<span class=\"hljs-number\">3</span>] += p\r\n                    self.adj[e[<span class=\"hljs-number\">0</span>]][e[<span class=\"hljs-number\">1</span>]][<span class=\"hljs-number\">3</span>] -= p\r\n                    <span class=\"hljs-keyword\">return</span> p\r\n            self.ptr[vertex] = self.ptr[vertex] + <span class=\"hljs-number\">1</span>\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\r\n\r\n    <span class=\"hljs-comment\"># Here we calculate the flow that reaches the sink</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">max_flow</span>(<span class=\"hljs-params\">self, source, sink</span>):\r\n        flow, self.q[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>, source\r\n        <span class=\"hljs-keyword\">for</span> l <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">31</span>):  <span class=\"hljs-comment\"># noqa: E741  l = 30 maybe faster for random data</span>\r\n            <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\r\n                self.lvl, self.ptr = [<span class=\"hljs-number\">0</span>] * <span class=\"hljs-built_in\">len</span>(self.q), [<span class=\"hljs-number\">0</span>] * <span class=\"hljs-built_in\">len</span>(self.q)\r\n                qi, qe, self.lvl[source] = <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>\r\n                <span class=\"hljs-keyword\">while</span> qi &lt; qe <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">not</span> self.lvl[sink]:\r\n                    v = self.q[qi]\r\n                    qi += <span class=\"hljs-number\">1</span>\r\n                    <span class=\"hljs-keyword\">for</span> e <span class=\"hljs-keyword\">in</span> self.adj[v]:\r\n                        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> self.lvl[e[<span class=\"hljs-number\">0</span>]] <span class=\"hljs-keyword\">and</span> (e[<span class=\"hljs-number\">2</span>] - e[<span class=\"hljs-number\">3</span>]) &gt;&gt; (<span class=\"hljs-number\">30</span> - l):\r\n                            self.q[qe] = e[<span class=\"hljs-number\">0</span>]\r\n                            qe += <span class=\"hljs-number\">1</span>\r\n                            self.lvl[e[<span class=\"hljs-number\">0</span>]] = self.lvl[v] + <span class=\"hljs-number\">1</span>\r\n\r\n                p = self.depth_first_search(source, sink, INF)\r\n                <span class=\"hljs-keyword\">while</span> p:\r\n                    flow += p\r\n                    p = self.depth_first_search(source, sink, INF)\r\n\r\n                <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> self.lvl[sink]:\r\n                    <span class=\"hljs-keyword\">break</span>\r\n\r\n        <span class=\"hljs-keyword\">return</span> flow\r\n\r\n\r\n<span class=\"hljs-comment\"># Example to use</span>\r\n\r\n<span class=\"hljs-string\">&quot;&quot;&quot;\r\nWill be a bipartite graph, than it has the vertices near the source(4)\r\nand the vertices near the sink(4)\r\n&quot;&quot;&quot;</span>\r\n<span class=\"hljs-comment\"># Here we make a graphs with 10 vertex(source and sink includes)</span>\r\ngraph = Dinic(<span class=\"hljs-number\">10</span>)\r\nsource = <span class=\"hljs-number\">0</span>\r\nsink = <span class=\"hljs-number\">9</span>\r\n<span class=\"hljs-string\">&quot;&quot;&quot;\r\nNow we add the vertices next to the font in the font with 1 capacity in this edge\r\n(source -&gt; source vertices)\r\n&quot;&quot;&quot;</span>\r\n<span class=\"hljs-keyword\">for</span> vertex <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>):\r\n    graph.add_edge(source, vertex, <span class=\"hljs-number\">1</span>)\r\n<span class=\"hljs-string\">&quot;&quot;&quot;\r\nWe will do the same thing for the vertices near the sink, but from vertex to sink\r\n(sink vertices -&gt; sink)\r\n&quot;&quot;&quot;</span>\r\n<span class=\"hljs-keyword\">for</span> vertex <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">9</span>):\r\n    graph.add_edge(vertex, sink, <span class=\"hljs-number\">1</span>)\r\n<span class=\"hljs-string\">&quot;&quot;&quot;\r\nFinally we add the verices near the sink to the vertices near the source.\r\n(source vertices -&gt; sink vertices)\r\n&quot;&quot;&quot;</span>\r\n<span class=\"hljs-keyword\">for</span> vertex <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>):\r\n    graph.add_edge(vertex, vertex + <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>)\r\n\r\n<span class=\"hljs-comment\"># Now we can know that is the maximum flow(source -&gt; sink)</span>\r\n<span class=\"hljs-built_in\">print</span>(graph.max_flow(source, sink))\r\n"
    }
  },
  "contributors": [
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 1
    },
    {
      "name": "Ankur Chattopadhyay",
      "email": "39518771+chttrjeankr@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Daniel Melo",
      "email": "38673841+danielx285@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}