{
  "slug": "k-means-clust",
  "name": "K Means Clust",
  "categories": [
    "machinelearning"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "machine_learning\\k_means_clust.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/machine_learning\\k_means_clust.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;README, Author - Anurag Kumar(mailto:anuragkumarak95@gmail.com)\r\nRequirements:\r\n  - sklearn\r\n  - numpy\r\n  - matplotlib\r\nPython:\r\n  - 3.5\r\nInputs:\r\n  - X , a 2D numpy array of features.\r\n  - k , number of clusters to create.\r\n  - initial_centroids , initial centroid values generated by utility function(mentioned\r\n    in usage).\r\n  - maxiter , maximum number of iterations to process.\r\n  - heterogeneity , empty list that will be filled with hetrogeneity values if passed\r\n    to kmeans func.\r\nUsage:\r\n  1. define &#x27;k&#x27; value, &#x27;X&#x27; features array and &#x27;hetrogeneity&#x27; empty list\r\n  2. create initial_centroids,\r\n        initial_centroids = get_initial_centroids(\r\n            X,\r\n            k,\r\n            seed=0 # seed value for initial centroid generation,\r\n                   # None for randomness(default=None)\r\n            )\r\n  3. find centroids and clusters using kmeans function.\r\n        centroids, cluster_assignment = kmeans(\r\n            X,\r\n            k,\r\n            initial_centroids,\r\n            maxiter=400,\r\n            record_heterogeneity=heterogeneity,\r\n            verbose=True # whether to print logs in console or not.(default=False)\r\n            )\r\n  4. Plot the loss function, hetrogeneity values for every iteration saved in\r\n     hetrogeneity list.\r\n        plot_heterogeneity(\r\n            heterogeneity,\r\n            k\r\n        )\r\n  5. Transfers Dataframe into excel format it must have feature called\r\n      &#x27;Clust&#x27; with k means clustering numbers in it.\r\n&quot;&quot;&quot;</span>\r\n<span class=\"hljs-keyword\">import</span> warnings\r\n\r\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\r\n<span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\r\n<span class=\"hljs-keyword\">from</span> matplotlib <span class=\"hljs-keyword\">import</span> pyplot <span class=\"hljs-keyword\">as</span> plt\r\n<span class=\"hljs-keyword\">from</span> sklearn.metrics <span class=\"hljs-keyword\">import</span> pairwise_distances\r\n\r\nwarnings.filterwarnings(<span class=\"hljs-string\">&quot;ignore&quot;</span>)\r\n\r\nTAG = <span class=\"hljs-string\">&quot;K-MEANS-CLUST/ &quot;</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_initial_centroids</span>(<span class=\"hljs-params\">data, k, seed=<span class=\"hljs-literal\">None</span></span>):\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;Randomly choose k data points as initial centroids&quot;&quot;&quot;</span>\r\n    <span class=\"hljs-keyword\">if</span> seed <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span>:  <span class=\"hljs-comment\"># useful for obtaining consistent results</span>\r\n        np.random.seed(seed)\r\n    n = data.shape[<span class=\"hljs-number\">0</span>]  <span class=\"hljs-comment\"># number of data points</span>\r\n\r\n    <span class=\"hljs-comment\"># Pick K indices from range [0, N).</span>\r\n    rand_indices = np.random.randint(<span class=\"hljs-number\">0</span>, n, k)\r\n\r\n    <span class=\"hljs-comment\"># Keep centroids as dense format, as many entries will be nonzero due to averaging.</span>\r\n    <span class=\"hljs-comment\"># As long as at least one document in a cluster contains a word,</span>\r\n    <span class=\"hljs-comment\"># it will carry a nonzero weight in the TF-IDF vector of the centroid.</span>\r\n    centroids = data[rand_indices, :]\r\n\r\n    <span class=\"hljs-keyword\">return</span> centroids\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">centroid_pairwise_dist</span>(<span class=\"hljs-params\">X, centroids</span>):\r\n    <span class=\"hljs-keyword\">return</span> pairwise_distances(X, centroids, metric=<span class=\"hljs-string\">&quot;euclidean&quot;</span>)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">assign_clusters</span>(<span class=\"hljs-params\">data, centroids</span>):\r\n\r\n    <span class=\"hljs-comment\"># Compute distances between each data point and the set of centroids:</span>\r\n    <span class=\"hljs-comment\"># Fill in the blank (RHS only)</span>\r\n    distances_from_centroids = centroid_pairwise_dist(data, centroids)\r\n\r\n    <span class=\"hljs-comment\"># Compute cluster assignments for each data point:</span>\r\n    <span class=\"hljs-comment\"># Fill in the blank (RHS only)</span>\r\n    cluster_assignment = np.argmin(distances_from_centroids, axis=<span class=\"hljs-number\">1</span>)\r\n\r\n    <span class=\"hljs-keyword\">return</span> cluster_assignment\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">revise_centroids</span>(<span class=\"hljs-params\">data, k, cluster_assignment</span>):\r\n    new_centroids = []\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(k):\r\n        <span class=\"hljs-comment\"># Select all data points that belong to cluster i. Fill in the blank (RHS only)</span>\r\n        member_data_points = data[cluster_assignment == i]\r\n        <span class=\"hljs-comment\"># Compute the mean of the data points. Fill in the blank (RHS only)</span>\r\n        centroid = member_data_points.mean(axis=<span class=\"hljs-number\">0</span>)\r\n        new_centroids.append(centroid)\r\n    new_centroids = np.array(new_centroids)\r\n\r\n    <span class=\"hljs-keyword\">return</span> new_centroids\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">compute_heterogeneity</span>(<span class=\"hljs-params\">data, k, centroids, cluster_assignment</span>):\r\n\r\n    heterogeneity = <span class=\"hljs-number\">0.0</span>\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(k):\r\n\r\n        <span class=\"hljs-comment\"># Select all data points that belong to cluster i. Fill in the blank (RHS only)</span>\r\n        member_data_points = data[cluster_assignment == i, :]\r\n\r\n        <span class=\"hljs-keyword\">if</span> member_data_points.shape[<span class=\"hljs-number\">0</span>] &gt; <span class=\"hljs-number\">0</span>:  <span class=\"hljs-comment\"># check if i-th cluster is non-empty</span>\r\n            <span class=\"hljs-comment\"># Compute distances from centroid to data points (RHS only)</span>\r\n            distances = pairwise_distances(\r\n                member_data_points, [centroids[i]], metric=<span class=\"hljs-string\">&quot;euclidean&quot;</span>\r\n            )\r\n            squared_distances = distances**<span class=\"hljs-number\">2</span>\r\n            heterogeneity += np.<span class=\"hljs-built_in\">sum</span>(squared_distances)\r\n\r\n    <span class=\"hljs-keyword\">return</span> heterogeneity\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">plot_heterogeneity</span>(<span class=\"hljs-params\">heterogeneity, k</span>):\r\n    plt.figure(figsize=(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">4</span>))\r\n    plt.plot(heterogeneity, linewidth=<span class=\"hljs-number\">4</span>)\r\n    plt.xlabel(<span class=\"hljs-string\">&quot;# Iterations&quot;</span>)\r\n    plt.ylabel(<span class=\"hljs-string\">&quot;Heterogeneity&quot;</span>)\r\n    plt.title(<span class=\"hljs-string\">f&quot;Heterogeneity of clustering over time, K=<span class=\"hljs-subst\">{k:d}</span>&quot;</span>)\r\n    plt.rcParams.update({<span class=\"hljs-string\">&quot;font.size&quot;</span>: <span class=\"hljs-number\">16</span>})\r\n    plt.show()\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">kmeans</span>(<span class=\"hljs-params\">\r\n    data, k, initial_centroids, maxiter=<span class=\"hljs-number\">500</span>, record_heterogeneity=<span class=\"hljs-literal\">None</span>, verbose=<span class=\"hljs-literal\">False</span>\r\n</span>):\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;This function runs k-means on given data and initial set of centroids.\r\n    maxiter: maximum number of iterations to run.(default=500)\r\n    record_heterogeneity: (optional) a list, to store the history of heterogeneity\r\n                          as function of iterations\r\n                          if None, do not store the history.\r\n    verbose: if True, print how many data points changed their cluster labels in\r\n                          each iteration&quot;&quot;&quot;</span>\r\n    centroids = initial_centroids[:]\r\n    prev_cluster_assignment = <span class=\"hljs-literal\">None</span>\r\n\r\n    <span class=\"hljs-keyword\">for</span> itr <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(maxiter):\r\n        <span class=\"hljs-keyword\">if</span> verbose:\r\n            <span class=\"hljs-built_in\">print</span>(itr, end=<span class=\"hljs-string\">&quot;&quot;</span>)\r\n\r\n        <span class=\"hljs-comment\"># 1. Make cluster assignments using nearest centroids</span>\r\n        cluster_assignment = assign_clusters(data, centroids)\r\n\r\n        <span class=\"hljs-comment\"># 2. Compute a new centroid for each of the k clusters, averaging all data</span>\r\n        <span class=\"hljs-comment\">#    points assigned to that cluster.</span>\r\n        centroids = revise_centroids(data, k, cluster_assignment)\r\n\r\n        <span class=\"hljs-comment\"># Check for convergence: if none of the assignments changed, stop</span>\r\n        <span class=\"hljs-keyword\">if</span> (\r\n            prev_cluster_assignment <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span>\r\n            <span class=\"hljs-keyword\">and</span> (prev_cluster_assignment == cluster_assignment).<span class=\"hljs-built_in\">all</span>()\r\n        ):\r\n            <span class=\"hljs-keyword\">break</span>\r\n\r\n        <span class=\"hljs-comment\"># Print number of new assignments</span>\r\n        <span class=\"hljs-keyword\">if</span> prev_cluster_assignment <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span>:\r\n            num_changed = np.<span class=\"hljs-built_in\">sum</span>(prev_cluster_assignment != cluster_assignment)\r\n            <span class=\"hljs-keyword\">if</span> verbose:\r\n                <span class=\"hljs-built_in\">print</span>(\r\n                    <span class=\"hljs-string\">&quot;    {:5d} elements changed their cluster assignment.&quot;</span>.<span class=\"hljs-built_in\">format</span>(\r\n                        num_changed\r\n                    )\r\n                )\r\n\r\n        <span class=\"hljs-comment\"># Record heterogeneity convergence metric</span>\r\n        <span class=\"hljs-keyword\">if</span> record_heterogeneity <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span>:\r\n            <span class=\"hljs-comment\"># YOUR CODE HERE</span>\r\n            score = compute_heterogeneity(data, k, centroids, cluster_assignment)\r\n            record_heterogeneity.append(score)\r\n\r\n        prev_cluster_assignment = cluster_assignment[:]\r\n\r\n    <span class=\"hljs-keyword\">return</span> centroids, cluster_assignment\r\n\r\n\r\n<span class=\"hljs-comment\"># Mock test below</span>\r\n<span class=\"hljs-keyword\">if</span> <span class=\"hljs-literal\">False</span>:  <span class=\"hljs-comment\"># change to true to run this test case.</span>\r\n    <span class=\"hljs-keyword\">from</span> sklearn <span class=\"hljs-keyword\">import</span> datasets <span class=\"hljs-keyword\">as</span> ds\r\n\r\n    dataset = ds.load_iris()\r\n    k = <span class=\"hljs-number\">3</span>\r\n    heterogeneity = []\r\n    initial_centroids = get_initial_centroids(dataset[<span class=\"hljs-string\">&quot;data&quot;</span>], k, seed=<span class=\"hljs-number\">0</span>)\r\n    centroids, cluster_assignment = kmeans(\r\n        dataset[<span class=\"hljs-string\">&quot;data&quot;</span>],\r\n        k,\r\n        initial_centroids,\r\n        maxiter=<span class=\"hljs-number\">400</span>,\r\n        record_heterogeneity=heterogeneity,\r\n        verbose=<span class=\"hljs-literal\">True</span>,\r\n    )\r\n    plot_heterogeneity(heterogeneity, k)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">ReportGenerator</span>(<span class=\"hljs-params\">\r\n    df: pd.DataFrame, ClusteringVariables: np.ndarray, FillMissingReport=<span class=\"hljs-literal\">None</span>\r\n</span>) -&gt; pd.DataFrame:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Function generates easy-erading clustering report. It takes 2 arguments as an input:\r\n        DataFrame - dataframe with predicted cluester column;\r\n        FillMissingReport - dictionary of rules how we are going to fill missing\r\n        values of for final report generate (not included in modeling);\r\n    in order to run the function following libraries must be imported:\r\n        import pandas as pd\r\n        import numpy as np\r\n    &gt;&gt;&gt; data = pd.DataFrame()\r\n    &gt;&gt;&gt; data[&#x27;numbers&#x27;] = [1, 2, 3]\r\n    &gt;&gt;&gt; data[&#x27;col1&#x27;] = [0.5, 2.5, 4.5]\r\n    &gt;&gt;&gt; data[&#x27;col2&#x27;] = [100, 200, 300]\r\n    &gt;&gt;&gt; data[&#x27;col3&#x27;] = [10, 20, 30]\r\n    &gt;&gt;&gt; data[&#x27;Cluster&#x27;] = [1, 1, 2]\r\n    &gt;&gt;&gt; ReportGenerator(data, [&#x27;col1&#x27;, &#x27;col2&#x27;], 0)\r\n               Features               Type   Mark           1           2\r\n    0    # of Customers        ClusterSize  False    2.000000    1.000000\r\n    1    % of Customers  ClusterProportion  False    0.666667    0.333333\r\n    2              col1    mean_with_zeros   True    1.500000    4.500000\r\n    3              col2    mean_with_zeros   True  150.000000  300.000000\r\n    4           numbers    mean_with_zeros  False    1.500000    3.000000\r\n    ..              ...                ...    ...         ...         ...\r\n    99            dummy                 5%  False    1.000000    1.000000\r\n    100           dummy                95%  False    1.000000    1.000000\r\n    101           dummy              stdev  False    0.000000         NaN\r\n    102           dummy               mode  False    1.000000    1.000000\r\n    103           dummy             median  False    1.000000    1.000000\r\n    &lt;BLANKLINE&gt;\r\n    [104 rows x 5 columns]\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-comment\"># Fill missing values with given rules</span>\r\n    <span class=\"hljs-keyword\">if</span> FillMissingReport:\r\n        df.fillna(value=FillMissingReport, inplace=<span class=\"hljs-literal\">True</span>)\r\n    df[<span class=\"hljs-string\">&quot;dummy&quot;</span>] = <span class=\"hljs-number\">1</span>\r\n    numeric_cols = df.select_dtypes(np.number).columns\r\n    report = (\r\n        df.groupby([<span class=\"hljs-string\">&quot;Cluster&quot;</span>])[  <span class=\"hljs-comment\"># construct report dataframe</span>\r\n            numeric_cols\r\n        ]  <span class=\"hljs-comment\"># group by cluster number</span>\r\n        .agg(\r\n            [\r\n                (<span class=\"hljs-string\">&quot;sum&quot;</span>, np.<span class=\"hljs-built_in\">sum</span>),\r\n                (<span class=\"hljs-string\">&quot;mean_with_zeros&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: np.mean(np.nan_to_num(x))),\r\n                (<span class=\"hljs-string\">&quot;mean_without_zeros&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.replace(<span class=\"hljs-number\">0</span>, np.NaN).mean()),\r\n                (\r\n                    <span class=\"hljs-string\">&quot;mean_25-75&quot;</span>,\r\n                    <span class=\"hljs-keyword\">lambda</span> x: np.mean(\r\n                        np.nan_to_num(\r\n                            <span class=\"hljs-built_in\">sorted</span>(x)[\r\n                                <span class=\"hljs-built_in\">round</span>(<span class=\"hljs-built_in\">len</span>(x) * <span class=\"hljs-number\">25</span> / <span class=\"hljs-number\">100</span>) : <span class=\"hljs-built_in\">round</span>(<span class=\"hljs-built_in\">len</span>(x) * <span class=\"hljs-number\">75</span> / <span class=\"hljs-number\">100</span>)\r\n                            ]\r\n                        )\r\n                    ),\r\n                ),\r\n                (<span class=\"hljs-string\">&quot;mean_with_na&quot;</span>, np.mean),\r\n                (<span class=\"hljs-string\">&quot;min&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.<span class=\"hljs-built_in\">min</span>()),\r\n                (<span class=\"hljs-string\">&quot;5%&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.quantile(<span class=\"hljs-number\">0.05</span>)),\r\n                (<span class=\"hljs-string\">&quot;25%&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.quantile(<span class=\"hljs-number\">0.25</span>)),\r\n                (<span class=\"hljs-string\">&quot;50%&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.quantile(<span class=\"hljs-number\">0.50</span>)),\r\n                (<span class=\"hljs-string\">&quot;75%&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.quantile(<span class=\"hljs-number\">0.75</span>)),\r\n                (<span class=\"hljs-string\">&quot;95%&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.quantile(<span class=\"hljs-number\">0.95</span>)),\r\n                (<span class=\"hljs-string\">&quot;max&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.<span class=\"hljs-built_in\">max</span>()),\r\n                (<span class=\"hljs-string\">&quot;count&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.count()),\r\n                (<span class=\"hljs-string\">&quot;stdev&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.std()),\r\n                (<span class=\"hljs-string\">&quot;mode&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.mode()[<span class=\"hljs-number\">0</span>]),\r\n                (<span class=\"hljs-string\">&quot;median&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.median()),\r\n                (<span class=\"hljs-string\">&quot;# &gt; 0&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: (x &gt; <span class=\"hljs-number\">0</span>).<span class=\"hljs-built_in\">sum</span>()),\r\n            ]\r\n        )\r\n        .T.reset_index()\r\n        .rename(index=<span class=\"hljs-built_in\">str</span>, columns={<span class=\"hljs-string\">&quot;level_0&quot;</span>: <span class=\"hljs-string\">&quot;Features&quot;</span>, <span class=\"hljs-string\">&quot;level_1&quot;</span>: <span class=\"hljs-string\">&quot;Type&quot;</span>})\r\n    )  <span class=\"hljs-comment\"># rename columns</span>\r\n    <span class=\"hljs-comment\"># calculate the size of cluster(count of clientID&#x27;s)</span>\r\n    clustersize = report[\r\n        (report[<span class=\"hljs-string\">&quot;Features&quot;</span>] == <span class=\"hljs-string\">&quot;dummy&quot;</span>) &amp; (report[<span class=\"hljs-string\">&quot;Type&quot;</span>] == <span class=\"hljs-string\">&quot;count&quot;</span>)\r\n    ].copy()  <span class=\"hljs-comment\"># avoid SettingWithCopyWarning</span>\r\n    clustersize.<span class=\"hljs-type\">Type</span> = (\r\n        <span class=\"hljs-string\">&quot;ClusterSize&quot;</span>  <span class=\"hljs-comment\"># rename created cluster df to match report column names</span>\r\n    )\r\n    clustersize.Features = <span class=\"hljs-string\">&quot;# of Customers&quot;</span>\r\n    clusterproportion = pd.DataFrame(\r\n        clustersize.iloc[:, <span class=\"hljs-number\">2</span>:].values\r\n        / clustersize.iloc[:, <span class=\"hljs-number\">2</span>:].values.<span class=\"hljs-built_in\">sum</span>()  <span class=\"hljs-comment\"># calculating the proportion of cluster</span>\r\n    )\r\n    clusterproportion[\r\n        <span class=\"hljs-string\">&quot;Type&quot;</span>\r\n    ] = <span class=\"hljs-string\">&quot;% of Customers&quot;</span>  <span class=\"hljs-comment\"># rename created cluster df to match report column names</span>\r\n    clusterproportion[<span class=\"hljs-string\">&quot;Features&quot;</span>] = <span class=\"hljs-string\">&quot;ClusterProportion&quot;</span>\r\n    cols = clusterproportion.columns.tolist()\r\n    cols = cols[-<span class=\"hljs-number\">2</span>:] + cols[:-<span class=\"hljs-number\">2</span>]\r\n    clusterproportion = clusterproportion[cols]  <span class=\"hljs-comment\"># rearrange columns to match report</span>\r\n    clusterproportion.columns = report.columns\r\n    a = pd.DataFrame(\r\n        <span class=\"hljs-built_in\">abs</span>(\r\n            report[report[<span class=\"hljs-string\">&quot;Type&quot;</span>] == <span class=\"hljs-string\">&quot;count&quot;</span>].iloc[:, <span class=\"hljs-number\">2</span>:].values\r\n            - clustersize.iloc[:, <span class=\"hljs-number\">2</span>:].values\r\n        )\r\n    )  <span class=\"hljs-comment\"># generating df with count of nan values</span>\r\n    a[<span class=\"hljs-string\">&quot;Features&quot;</span>] = <span class=\"hljs-number\">0</span>\r\n    a[<span class=\"hljs-string\">&quot;Type&quot;</span>] = <span class=\"hljs-string\">&quot;# of nan&quot;</span>\r\n    a.Features = report[\r\n        report[<span class=\"hljs-string\">&quot;Type&quot;</span>] == <span class=\"hljs-string\">&quot;count&quot;</span>\r\n    ].Features.tolist()  <span class=\"hljs-comment\"># filling values in order to match report</span>\r\n    cols = a.columns.tolist()\r\n    cols = cols[-<span class=\"hljs-number\">2</span>:] + cols[:-<span class=\"hljs-number\">2</span>]\r\n    a = a[cols]  <span class=\"hljs-comment\"># rearrange columns to match report</span>\r\n    a.columns = report.columns  <span class=\"hljs-comment\"># rename columns to match report</span>\r\n    report = report.drop(\r\n        report[report.<span class=\"hljs-type\">Type</span> == <span class=\"hljs-string\">&quot;count&quot;</span>].index\r\n    )  <span class=\"hljs-comment\"># drop count values except cluster size</span>\r\n    report = pd.concat(\r\n        [report, a, clustersize, clusterproportion], axis=<span class=\"hljs-number\">0</span>\r\n    )  <span class=\"hljs-comment\"># concat report with clustert size and nan values</span>\r\n    report[<span class=\"hljs-string\">&quot;Mark&quot;</span>] = report[<span class=\"hljs-string\">&quot;Features&quot;</span>].isin(ClusteringVariables)\r\n    cols = report.columns.tolist()\r\n    cols = cols[<span class=\"hljs-number\">0</span>:<span class=\"hljs-number\">2</span>] + cols[-<span class=\"hljs-number\">1</span>:] + cols[<span class=\"hljs-number\">2</span>:-<span class=\"hljs-number\">1</span>]\r\n    report = report[cols]\r\n    sorter1 = {\r\n        <span class=\"hljs-string\">&quot;ClusterSize&quot;</span>: <span class=\"hljs-number\">9</span>,\r\n        <span class=\"hljs-string\">&quot;ClusterProportion&quot;</span>: <span class=\"hljs-number\">8</span>,\r\n        <span class=\"hljs-string\">&quot;mean_with_zeros&quot;</span>: <span class=\"hljs-number\">7</span>,\r\n        <span class=\"hljs-string\">&quot;mean_with_na&quot;</span>: <span class=\"hljs-number\">6</span>,\r\n        <span class=\"hljs-string\">&quot;max&quot;</span>: <span class=\"hljs-number\">5</span>,\r\n        <span class=\"hljs-string\">&quot;50%&quot;</span>: <span class=\"hljs-number\">4</span>,\r\n        <span class=\"hljs-string\">&quot;min&quot;</span>: <span class=\"hljs-number\">3</span>,\r\n        <span class=\"hljs-string\">&quot;25%&quot;</span>: <span class=\"hljs-number\">2</span>,\r\n        <span class=\"hljs-string\">&quot;75%&quot;</span>: <span class=\"hljs-number\">1</span>,\r\n        <span class=\"hljs-string\">&quot;# of nan&quot;</span>: <span class=\"hljs-number\">0</span>,\r\n        <span class=\"hljs-string\">&quot;# &gt; 0&quot;</span>: -<span class=\"hljs-number\">1</span>,\r\n        <span class=\"hljs-string\">&quot;sum_with_na&quot;</span>: -<span class=\"hljs-number\">2</span>,\r\n    }\r\n    report = (\r\n        report.assign(\r\n            Sorter1=<span class=\"hljs-keyword\">lambda</span> x: x.<span class=\"hljs-type\">Type</span>.<span class=\"hljs-built_in\">map</span>(sorter1),\r\n            Sorter2=<span class=\"hljs-keyword\">lambda</span> x: <span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">reversed</span>(<span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(x)))),\r\n        )\r\n        .sort_values([<span class=\"hljs-string\">&quot;Sorter1&quot;</span>, <span class=\"hljs-string\">&quot;Mark&quot;</span>, <span class=\"hljs-string\">&quot;Sorter2&quot;</span>], ascending=<span class=\"hljs-literal\">False</span>)\r\n        .drop([<span class=\"hljs-string\">&quot;Sorter1&quot;</span>, <span class=\"hljs-string\">&quot;Sorter2&quot;</span>], axis=<span class=\"hljs-number\">1</span>)\r\n    )\r\n    report.columns.name = <span class=\"hljs-string\">&quot;&quot;</span>\r\n    report = report.reset_index()\r\n    report.drop(columns=[<span class=\"hljs-string\">&quot;index&quot;</span>], inplace=<span class=\"hljs-literal\">True</span>)\r\n    <span class=\"hljs-keyword\">return</span> report\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    <span class=\"hljs-keyword\">import</span> doctest\r\n\r\n    doctest.testmod()\r\n"
    }
  },
  "contributors": [
    {
      "name": "algobytewise",
      "email": "algobytewise@gmail.com",
      "commits": 1
    },
    {
      "name": "shellhub",
      "email": "shellhub.me@gmail.com",
      "commits": 1
    },
    {
      "name": "BAKEZQ",
      "email": "zhongquan789@gmail.com",
      "commits": 1
    },
    {
      "name": "beqakd",
      "email": "39763019+beqakd@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "cclauss",
      "email": "cclauss@bluewin.ch",
      "commits": 1
    },
    {
      "name": "Anurag Kumar",
      "email": "anuragkumarak95@gmail.com",
      "commits": 1
    },
    {
      "name": "97arushisharma",
      "email": "97arushisharma@gmail.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 7
    }
  ],
  "explanationUrl": {}
}