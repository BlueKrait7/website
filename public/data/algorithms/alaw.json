{
  "slug": "alaw",
  "name": "Alaw",
  "categories": [
    "audio"
  ],
  "body": {},
  "implementations": {
    "c": {
      "dir": "audio\\alaw.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/audio\\alaw.c",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @author [sunzhenliang](https://github.com/HiSunzhenliang)\r\n * @brief A-law algorithm for encoding and decoding (16bit pcm &lt;=&gt; a-law).\r\n * This is the implementation of [G.711](https://en.wikipedia.org/wiki/G.711)\r\n * in C.\r\n **/</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Linear input code | Compressed code | Linear output code\r\n * ------------------+-----------------+-------------------\r\n * s0000000abcdx     | s000abcd        | s0000000abcd1\r\n * s0000001abcdx     | s001abcd        | s0000001abcd1\r\n * s000001abcdxx     | s010abcd        | s000001abcd10\r\n * s00001abcdxxx     | s011abcd        | s00001abcd100\r\n * s0001abcdxxxx     | s100abcd        | s0001abcd1000\r\n * s001abcdxxxxx     | s101abcd        | s001abcd10000\r\n * s01abcdxxxxxx     | s110abcd        | s01abcd100000\r\n * s1abcdxxxxxxx     | s111abcd        | s1abcd1000000\r\n *\r\n * Compressed code: (s | eee | abcd)\r\n **/</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span>    <span class=\"hljs-comment\">/// for assert</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;inttypes.h&gt;</span>  <span class=\"hljs-comment\">/// for appropriate size int types</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span>     <span class=\"hljs-comment\">/// for IO operations</span></span>\r\n\r\n<span class=\"hljs-comment\">/* length of test inputs */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> LEN ((size_t)8)</span>\r\n\r\n<span class=\"hljs-comment\">/* input pcm for test */</span>\r\n<span class=\"hljs-type\">int16_t</span> pcm[LEN] = {<span class=\"hljs-number\">1000</span>, <span class=\"hljs-number\">-1000</span>, <span class=\"hljs-number\">1234</span>, <span class=\"hljs-number\">3200</span>, <span class=\"hljs-number\">-1314</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">32767</span>, <span class=\"hljs-number\">-32768</span>};\r\n\r\n<span class=\"hljs-comment\">/* result coded alaw for test */</span>\r\n<span class=\"hljs-type\">uint8_t</span> r_coded[LEN] = {<span class=\"hljs-number\">250</span>, <span class=\"hljs-number\">122</span>, <span class=\"hljs-number\">230</span>, <span class=\"hljs-number\">156</span>, <span class=\"hljs-number\">97</span>, <span class=\"hljs-number\">213</span>, <span class=\"hljs-number\">170</span>, <span class=\"hljs-number\">42</span>};\r\n\r\n<span class=\"hljs-comment\">/* result decoded for test */</span>\r\n<span class=\"hljs-type\">int16_t</span> r_decoded[LEN] = {<span class=\"hljs-number\">1008</span>, <span class=\"hljs-number\">-1008</span>, <span class=\"hljs-number\">1248</span>, <span class=\"hljs-number\">3264</span>, <span class=\"hljs-number\">-1312</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">32256</span>, <span class=\"hljs-number\">-32256</span>};\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief 16bit pcm to 8bit alaw\r\n * @param out unsigned 8bit alaw array\r\n * @param in  signed 16bit pcm array\r\n * @param len length of pcm array\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">encode</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> *out, <span class=\"hljs-type\">int16_t</span> *in, <span class=\"hljs-type\">size_t</span> len)</span>\r\n{\r\n    <span class=\"hljs-type\">uint8_t</span> alaw = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">int16_t</span> pcm = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">int32_t</span> sign = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">int32_t</span> abcd = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">int32_t</span> eee = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">int32_t</span> mask = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)\r\n    {\r\n        pcm = *in++;\r\n        <span class=\"hljs-comment\">/* 0-7 kinds of quantization level from the table above */</span>\r\n        eee = <span class=\"hljs-number\">7</span>;\r\n        mask = <span class=\"hljs-number\">0x4000</span>; <span class=\"hljs-comment\">/* 0x4000: &#x27;0b0100 0000 0000 0000&#x27; */</span>\r\n\r\n        <span class=\"hljs-comment\">/* Get sign bit */</span>\r\n        sign = (pcm &amp; <span class=\"hljs-number\">0x8000</span>) &gt;&gt; <span class=\"hljs-number\">8</span>;\r\n\r\n        <span class=\"hljs-comment\">/* Turn negative pcm to positive */</span>\r\n        <span class=\"hljs-comment\">/* The absolute value of a negative number may be larger than the size\r\n         * of the corresponding positive number, so here needs `-pcm -1` after\r\n         * taking the opposite number. */</span>\r\n        pcm = sign ? (-pcm - <span class=\"hljs-number\">1</span>) : pcm;\r\n\r\n        <span class=\"hljs-comment\">/* Get eee and abcd bit */</span>\r\n        <span class=\"hljs-comment\">/* Use mask to locate the first `1` bit and quantization level at the\r\n         * same time */</span>\r\n        <span class=\"hljs-keyword\">while</span> ((pcm &amp; mask) == <span class=\"hljs-number\">0</span> &amp;&amp; eee &gt; <span class=\"hljs-number\">0</span>)\r\n        {\r\n            eee--;\r\n            mask &gt;&gt;= <span class=\"hljs-number\">1</span>;\r\n        }\r\n\r\n        <span class=\"hljs-comment\">/* The location of abcd bits is related with quantization level. Check\r\n         * the table above to determine how many bits to `&gt;&gt;` to get abcd */</span>\r\n        abcd = (pcm &gt;&gt; (eee ? (eee + <span class=\"hljs-number\">3</span>) : <span class=\"hljs-number\">4</span>)) &amp; <span class=\"hljs-number\">0x0f</span>;\r\n\r\n        <span class=\"hljs-comment\">/* Put the quantization level number at right bit location to get eee\r\n         * bits */</span>\r\n        eee &lt;&lt;= <span class=\"hljs-number\">4</span>;\r\n\r\n        <span class=\"hljs-comment\">/* Splice results */</span>\r\n        alaw = (sign | eee | abcd);\r\n\r\n        <span class=\"hljs-comment\">/* The standard specifies that all resulting even bits (LSB\r\n         * is even) are inverted before the octet is transmitted. This is to\r\n         * provide plenty of 0/1 transitions to facilitate the clock recovery\r\n         * process in the PCM receivers. Thus, a silent A-law encoded PCM\r\n         * channel has the 8 bit samples coded 0xD5 instead of 0x80 in the\r\n         * octets. (Reference from wiki above) */</span>\r\n        *out++ = alaw ^ <span class=\"hljs-number\">0xD5</span>;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief 8bit alaw to 16bit pcm\r\n * @param out signed 16bit pcm array\r\n * @param in  unsigned 8bit alaw array\r\n * @param len length of alaw array\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">decode</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int16_t</span> *out, <span class=\"hljs-type\">uint8_t</span> *in, <span class=\"hljs-type\">size_t</span> len)</span>\r\n{\r\n    <span class=\"hljs-type\">uint8_t</span> alaw = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">int32_t</span> pcm = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">int32_t</span> sign = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">int32_t</span> eee = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)\r\n    {\r\n        alaw = *in++;\r\n\r\n        <span class=\"hljs-comment\">/* Re-toggle toggled bits */</span>\r\n        alaw ^= <span class=\"hljs-number\">0xD5</span>;\r\n\r\n        <span class=\"hljs-comment\">/* Get sign bit */</span>\r\n        sign = alaw &amp; <span class=\"hljs-number\">0x80</span>;\r\n\r\n        <span class=\"hljs-comment\">/* Get eee bits */</span>\r\n        eee = (alaw &amp; <span class=\"hljs-number\">0x70</span>) &gt;&gt; <span class=\"hljs-number\">4</span>;\r\n\r\n        <span class=\"hljs-comment\">/* Get abcd bits and add 1/2 quantization step */</span>\r\n        pcm = (alaw &amp; <span class=\"hljs-number\">0x0f</span>) &lt;&lt; <span class=\"hljs-number\">4</span> | <span class=\"hljs-number\">8</span>;\r\n\r\n        <span class=\"hljs-comment\">/* If quantization level &gt; 0, there need `1` bit before abcd bits */</span>\r\n        pcm += eee ? <span class=\"hljs-number\">0x100</span> : <span class=\"hljs-number\">0x0</span>;\r\n\r\n        <span class=\"hljs-comment\">/* Left shift according quantization level */</span>\r\n        pcm &lt;&lt;= eee &gt; <span class=\"hljs-number\">1</span> ? (eee - <span class=\"hljs-number\">1</span>) : <span class=\"hljs-number\">0</span>;\r\n\r\n        <span class=\"hljs-comment\">/* Use the right sign */</span>\r\n        *out++ = sign ? -pcm : pcm;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Self-test implementations\r\n * @param pcm signed 16bit pcm array\r\n * @param coded unsigned 8bit alaw array\r\n * @param decoded signed 16bit pcm array\r\n * @param len length of test array\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int16_t</span> *pcm, <span class=\"hljs-type\">uint8_t</span> *coded, <span class=\"hljs-type\">int16_t</span> *decoded, <span class=\"hljs-type\">size_t</span> len)</span>\r\n{\r\n    <span class=\"hljs-comment\">/* run encode */</span>\r\n    encode(coded, pcm, len);\r\n\r\n    <span class=\"hljs-comment\">/* check encode result */</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)\r\n    {\r\n        assert(coded[i] == r_coded[i]);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/* run decode */</span>\r\n    decode(decoded, coded, len);\r\n\r\n    <span class=\"hljs-comment\">/* check decode result */</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)\r\n    {\r\n        assert(decoded[i] == r_decoded[i]);\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @param argc commandline argument count (ignored)\r\n * @param argv commandline array of arguments (ignored)\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span>\r\n{\r\n    <span class=\"hljs-comment\">/* output alaw encoded by encode() */</span>\r\n    <span class=\"hljs-type\">uint8_t</span> coded[LEN];\r\n\r\n    <span class=\"hljs-comment\">/* output pcm decoded by decode() from coded[LEN] */</span>\r\n    <span class=\"hljs-type\">int16_t</span> decoded[LEN];\r\n\r\n    test(pcm, coded, decoded, LEN);  <span class=\"hljs-comment\">// run self-test implementations</span>\r\n\r\n    <span class=\"hljs-comment\">/* print test pcm inputs */</span>\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;inputs: &quot;</span>);\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; LEN; i++)\r\n    {\r\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>, pcm[i]);\r\n    }\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);\r\n\r\n    <span class=\"hljs-comment\">/* print encoded alaw */</span>\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;encode: &quot;</span>);\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; LEN; i++)\r\n    {\r\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%u &quot;</span>, coded[i]);\r\n    }\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);\r\n\r\n    <span class=\"hljs-comment\">/* print decoded pcm */</span>\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;decode: &quot;</span>);\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; LEN; i++)\r\n    {\r\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>, decoded[i]);\r\n    }\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);\r\n\r\n    <span class=\"hljs-comment\">/* It can be seen that the encoded alaw is smaller than the input PCM, so\r\n     * the purpose of compression is achieved. And the decoded PCM is almost the\r\n     * same as the original input PCM, which verifies the correctness of the\r\n     * decoding. The reason why it is not exactly the same is that there is\r\n     * precision loss during encode / decode.  */</span>\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Alliswell",
      "email": "hisunzhenliang@outlook.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}