{
  "slug": "approximate-pi",
  "name": "Approximate Pi",
  "categories": [
    "math"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "math\\approximate_pi.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/math\\approximate_pi.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @brief Implementation to calculate an estimate of the [number π (Pi)](https://en.wikipedia.org/wiki/File:Pi_30K.gif).\r\n *\r\n * @details\r\n * We take a random point P with coordinates (x, y) such that 0 ≤ x ≤ 1 and 0 ≤ y ≤ 1. If x² + y² ≤ 1, then the \r\n * point is inside the quarter disk of radius 1, otherwise the point is outside.\r\n * We know that the probability of the point being inside the quarter disk is equal to π/4\r\n * double approx(vector&lt;Point&gt; &amp;pts) which will use the points pts (drawn at random) to \r\n * return an estimate of the number π\r\n * \\note This implementation is better than naive recursive or iterative\r\n * approach.\r\n *\r\n * @author [Qannaf AL-SAHMI](https://github.com/Qannaf)\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">/// for IO operations</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>    <span class=\"hljs-comment\">/// for std::vector</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span>  <span class=\"hljs-comment\">/// for std::rand</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace math\r\n * @brief Mathematical algorithms\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> math {\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * structure of points containing two numbers, respectively x and y such that 0 ≤ x ≤ 1 and 0 ≤ y ≤ 1. \r\n    */</span>\r\n    <span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> {\r\n    <span class=\"hljs-type\">double</span> x;\r\n    <span class=\"hljs-type\">double</span> y;\r\n    } Point;\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">double</span>  <span class=\"hljs-title\">approximate_pi</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::vector&lt;Point&gt; &amp;pts)</span> </span>{\r\n    <span class=\"hljs-comment\">/**\r\n     * This function use the points pts (drawn at random) to return an estimate of the number π  using the given points\r\n     * @param pts Each item of pts contains a point. A point is represented by a structure containing exactly \r\n     * two numbers, respectively x and y such that 0 ≤ x ≤ 1 and 0 ≤ y ≤ 1. \r\n     * pts always contains at least one item\r\n     * @return  an estimate of the number π\r\n     */</span>\r\n        {\r\n            <span class=\"hljs-type\">int</span> count =<span class=\"hljs-number\">0</span>;    <span class=\"hljs-comment\">// Points in cercle</span>\r\n            <span class=\"hljs-keyword\">for</span>(Point p:pts)\r\n                <span class=\"hljs-keyword\">if</span>(p.x * p.x + p.y*p.y &lt;= <span class=\"hljs-number\">1</span>)\r\n                    ++count;\r\n            \r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">4.0</span>*count/pts.<span class=\"hljs-built_in\">size</span>();\r\n        }\r\n    }\r\n}  <span class=\"hljs-comment\">// namespace math</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Self-test implementations\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\r\n        std::vector&lt;math::Point&gt; rands;\r\n    <span class=\"hljs-keyword\">for</span> (std::<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100000</span>; i++) {\r\n        math::Point p;\r\n        p.x = <span class=\"hljs-built_in\">rand</span>() / (<span class=\"hljs-type\">double</span>)RAND_MAX; <span class=\"hljs-comment\">// 0 &lt;= x &lt;= 1</span>\r\n        p.y = <span class=\"hljs-built_in\">rand</span>() / (<span class=\"hljs-type\">double</span>)RAND_MAX; <span class=\"hljs-comment\">// 0 &lt;= y &lt;= 1</span>\r\n        rands.<span class=\"hljs-built_in\">push_back</span>(p);\r\n    }\r\n    std::cout &lt;&lt; math::<span class=\"hljs-built_in\">approximate_pi</span>(rands) &lt;&lt; std::endl;          <span class=\"hljs-comment\">// ~3.14</span>\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @param argc commandline argument count (ignored)\r\n * @param argv commandline array of arguments (ignored)\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span> </span>{\r\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// run self-test implementations</span>\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [],
  "explanationUrl": {}
}