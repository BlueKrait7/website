{
  "slug": "modular-inverse-fermat-little-theorem",
  "name": "Modular Inverse Fermat Little Theorem",
  "categories": [
    "math"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "math\\modular_inverse_fermat_little_theorem.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/math\\modular_inverse_fermat_little_theorem.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @brief C++ Program to find the modular inverse using [Fermat&#x27;s Little\r\n * Theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem)\r\n *\r\n * Fermat&#x27;s Little Theorem state that \\f[ϕ(m) = m-1\\f]\r\n * where \\f$m\\f$ is a prime number.\r\n * \\f{eqnarray*}{\r\n *  a \\cdot x &amp;≡&amp; 1 \\;\\text{mod}\\; m\\\\\r\n *  x &amp;≡&amp; a^{-1} \\;\\text{mod}\\; m\r\n * \\f}\r\n * Using Euler&#x27;s theorem we can modify the equation.\r\n *\\f[\r\n * a^{ϕ(m)} ≡ 1 \\;\\text{mod}\\; m\r\n * \\f]\r\n * (Where &#x27;^&#x27; denotes the exponent operator)\r\n *\r\n * Here &#x27;ϕ&#x27; is Euler&#x27;s Totient Function. For modular inverse existence &#x27;a&#x27; and\r\n * &#x27;m&#x27; must be relatively primes numbers. To apply Fermat&#x27;s Little Theorem is\r\n * necessary that &#x27;m&#x27; must be a prime number. Generally in many competitive\r\n * programming competitions &#x27;m&#x27; is either 1000000007 (1e9+7) or 998244353.\r\n *\r\n * We considered m as large prime (1e9+7).\r\n * \\f$a^{ϕ(m)} ≡ 1 \\;\\text{mod}\\; m\\f$ (Using Euler&#x27;s Theorem)\r\n * \\f$ϕ(m) = m-1\\f$ using Fermat&#x27;s Little Theorem.\r\n * \\f$a^{m-1} ≡ 1 \\;\\text{mod}\\; m\\f$\r\n * Now multiplying both side by \\f$a^{-1}\\f$.\r\n * \\f{eqnarray*}{\r\n * a^{m-1} \\cdot a^{-1} &amp;≡&amp; a^{-1} \\;\\text{mod}\\; m\\\\\r\n * a^{m-2} &amp;≡&amp;  a^{-1} \\;\\text{mod}\\; m\r\n * \\f}\r\n *\r\n * We will find the exponent using binary exponentiation. Such that the\r\n * algorithm works in \\f$O(\\log m)\\f$ time.\r\n *\r\n * Examples: -\r\n * * a = 3 and m = 7\r\n * * \\f$a^{-1} \\;\\text{mod}\\; m\\f$ is equivalent to\r\n * \\f$a^{m-2} \\;\\text{mod}\\; m\\f$\r\n * * \\f$3^5 \\;\\text{mod}\\; 7 = 243 \\;\\text{mod}\\; 7 = 5\\f$\r\n * &lt;br/&gt;Hence, \\f$3^{-1} \\;\\text{mod}\\; 7 = 5\\f$\r\n * or \\f$3 \\times 5  \\;\\text{mod}\\; 7 = 1 \\;\\text{mod}\\; 7\\f$\r\n * (as \\f$a\\times a^{-1} = 1\\f$)\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\r\n\r\n<span class=\"hljs-comment\">/** Recursive function to calculate exponent in \\f$O(\\log n)\\f$ using binary\r\n * exponent.\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">binExpo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> a, <span class=\"hljs-type\">int64_t</span> b, <span class=\"hljs-type\">int64_t</span> m)</span> </span>{\r\n    a %= m;\r\n    <span class=\"hljs-type\">int64_t</span> res = <span class=\"hljs-number\">1</span>;\r\n    <span class=\"hljs-keyword\">while</span> (b &gt; <span class=\"hljs-number\">0</span>) {\r\n        <span class=\"hljs-keyword\">if</span> (b % <span class=\"hljs-number\">2</span>) {\r\n            res = res * a % m;\r\n        }\r\n        a = a * a % m;\r\n        <span class=\"hljs-comment\">// Dividing b by 2 is similar to right shift.</span>\r\n        b &gt;&gt;= <span class=\"hljs-number\">1</span>;\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> res;\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Prime check in \\f$O(\\sqrt{m})\\f$ time.\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isPrime</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> m)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (m &lt;= <span class=\"hljs-number\">1</span>) {\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n    } <span class=\"hljs-keyword\">else</span> {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int64_t</span> i = <span class=\"hljs-number\">2</span>; i * i &lt;= m; i++) {\r\n            <span class=\"hljs-keyword\">if</span> (m % i == <span class=\"hljs-number\">0</span>) {\r\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n            }\r\n        }\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Main function\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-type\">int64_t</span> a, m;\r\n    <span class=\"hljs-comment\">// Take input of  a and m.</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Computing ((a^(-1))%(m)) using Fermat&#x27;s Little Theorem&quot;</span>;\r\n    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Give input &#x27;a&#x27; and &#x27;m&#x27; space separated : &quot;</span>;\r\n    std::cin &gt;&gt; a &gt;&gt; m;\r\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isPrime</span>(m)) {\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;The modular inverse of a with mod m is (a^(m-2)) : &quot;</span>;\r\n        std::cout &lt;&lt; <span class=\"hljs-built_in\">binExpo</span>(a, m - <span class=\"hljs-number\">2</span>, m) &lt;&lt; std::endl;\r\n    } <span class=\"hljs-keyword\">else</span> {\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;m must be a prime number.&quot;</span>;\r\n        std::cout &lt;&lt; std::endl;\r\n    }\r\n}\r\n"
    }
  },
  "contributors": [],
  "explanationUrl": {}
}