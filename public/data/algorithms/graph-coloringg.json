{
  "slug": "graph-coloringg",
  "name": "Graph Coloringg",
  "categories": [
    "backtracking"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "backtracking\\graph_coloringg.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/backtracking\\graph_coloringg.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @brief prints the assigned colors\r\n * using [Graph Coloring](https://en.wikipedia.org/wiki/Graph_coloring)\r\n * algorithm\r\n *\r\n * @details\r\n * In graph theory, graph coloring is a special case of graph labeling;\r\n * it is an assignment of labels traditionally called &quot;colors&quot; to elements of a\r\n * graph subject to certain constraints. In its simplest form, it is a way of\r\n * coloring the vertices of a graph such that no two adjacent vertices are of\r\n * the same color; this is called a vertex coloring. Similarly, an edge coloring\r\n * assigns a color to each edge so that no two adjacent edges are of the same\r\n * color, and a face coloring of a planar graph assigns a color to each face or\r\n * region so that no two faces that share a boundary have the same color.\r\n *\r\n * @author [Anup Kumar Panwar](https://github.com/AnupKumarPanwar)\r\n * @author [David Leal](https://github.com/Panquesito7)\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;array&gt;</span>     <span class=\"hljs-comment\">/// for std::array</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">/// for IO operations</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>    <span class=\"hljs-comment\">/// for std::vector</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace backtracking\r\n * @brief Backtracking algorithms\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> backtracking {\r\n<span class=\"hljs-comment\">/**\r\n * @namespace graph_coloring\r\n * @brief Functions for the [Graph\r\n * Coloring](https://en.wikipedia.org/wiki/Graph_coloring) algorithm,\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> graph_coloring {\r\n<span class=\"hljs-comment\">/**\r\n * @brief A utility function to print the solution\r\n * @tparam V number of vertices in the graph\r\n * @param color array of colors assigned to the nodes\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-type\">size_t</span> V&gt;\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printSolution</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::array&lt;<span class=\"hljs-type\">int</span>, V&gt;&amp; color)</span> </span>{\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Following are the assigned colors\\n&quot;</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span>&amp; col : color) {\r\n        std::cout &lt;&lt; col;\r\n    }\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Utility function to check if the current color assignment is safe for\r\n * vertex v\r\n * @tparam V number of vertices in the graph\r\n * @param v index of graph vertex to check\r\n * @param graph matrix of graph nonnectivity\r\n * @param color vector of colors assigned to the graph nodes/vertices\r\n * @param c color value to check for the node `v`\r\n * @returns `true` if the color is safe to be assigned to the node\r\n * @returns `false` if the color is not safe to be assigned to the node\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-type\">size_t</span> V&gt;\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isSafe</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> v, <span class=\"hljs-type\">const</span> std::array&lt;std::array&lt;<span class=\"hljs-type\">int</span>, V&gt;, V&gt;&amp; graph,\r\n            <span class=\"hljs-type\">const</span> std::array&lt;<span class=\"hljs-type\">int</span>, V&gt;&amp; color, <span class=\"hljs-type\">int</span> c)</span> </span>{\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) {\r\n        <span class=\"hljs-keyword\">if</span> (graph[v][i] &amp;&amp; c == color[i]) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n        }\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Recursive utility function to solve m coloring problem\r\n * @tparam V number of vertices in the graph\r\n * @param graph matrix of graph nonnectivity\r\n * @param m number of colors\r\n * @param [in,out] color description // used in,out to notify in documentation\r\n * that this parameter gets modified by the function\r\n * @param v index of graph vertex to check\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-type\">size_t</span> V&gt;\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">graphColoring</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::array&lt;std::array&lt;<span class=\"hljs-type\">int</span>, V&gt;, V&gt;&amp; graph, <span class=\"hljs-type\">int</span> m,\r\n                   std::array&lt;<span class=\"hljs-type\">int</span>, V&gt; color, <span class=\"hljs-type\">int</span> v)</span> </span>{\r\n    <span class=\"hljs-comment\">// base case:</span>\r\n    <span class=\"hljs-comment\">// If all vertices are assigned a color then return true</span>\r\n    <span class=\"hljs-keyword\">if</span> (v == V) {\r\n        <span class=\"hljs-built_in\">printSolution</span>&lt;V&gt;(color);\r\n        <span class=\"hljs-keyword\">return</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// Consider this vertex v and try different colors</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> c = <span class=\"hljs-number\">1</span>; c &lt;= m; c++) {\r\n        <span class=\"hljs-comment\">// Check if assignment of color c to v is fine</span>\r\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isSafe</span>&lt;V&gt;(v, graph, color, c)) {\r\n            color[v] = c;\r\n\r\n            <span class=\"hljs-comment\">// recur to assign colors to rest of the vertices</span>\r\n            <span class=\"hljs-built_in\">graphColoring</span>&lt;V&gt;(graph, m, color, v + <span class=\"hljs-number\">1</span>);\r\n\r\n            <span class=\"hljs-comment\">// If assigning color c doesn&#x27;t lead to a solution then remove it</span>\r\n            color[v] = <span class=\"hljs-number\">0</span>;\r\n        }\r\n    }\r\n}\r\n}  <span class=\"hljs-comment\">// namespace graph_coloring</span>\r\n}  <span class=\"hljs-comment\">// namespace backtracking</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-comment\">// Create following graph and test whether it is 3 colorable</span>\r\n    <span class=\"hljs-comment\">// (3)---(2)</span>\r\n    <span class=\"hljs-comment\">// |   / |</span>\r\n    <span class=\"hljs-comment\">// |  /  |</span>\r\n    <span class=\"hljs-comment\">// | /   |</span>\r\n    <span class=\"hljs-comment\">// (0)---(1)</span>\r\n\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> V = <span class=\"hljs-number\">4</span>;  <span class=\"hljs-comment\">// number of vertices in the graph</span>\r\n    std::array&lt;std::array&lt;<span class=\"hljs-type\">int</span>, V&gt;, V&gt; graph = {\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">int</span>, V&gt;({<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>}), std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">int</span>, V&gt;({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>}),\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">int</span>, V&gt;({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}), std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">int</span>, V&gt;({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>})};\r\n\r\n    <span class=\"hljs-type\">int</span> m = <span class=\"hljs-number\">3</span>;  <span class=\"hljs-comment\">// Number of colors</span>\r\n    std::array&lt;<span class=\"hljs-type\">int</span>, V&gt; color{};\r\n\r\n    backtracking::graph_coloring::<span class=\"hljs-built_in\">graphColoring</span>&lt;V&gt;(graph, m, color, <span class=\"hljs-number\">0</span>);\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [],
  "explanationUrl": {}
}