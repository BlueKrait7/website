{
  "slug": "deutsch-jozsa",
  "name": "Deutsch Jozsa",
  "categories": [
    "quantum"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "quantum\\deutsch_jozsa.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/quantum\\deutsch_jozsa.py",
      "code": "<span class=\"hljs-comment\">#!/usr/bin/env python3</span>\r\n<span class=\"hljs-string\">&quot;&quot;&quot;\r\nDeutsch-Josza Algorithm is one of the first examples of a quantum\r\nalgorithm that is exponentially faster than any possible deterministic\r\nclassical algorithm\r\n\r\nPremise:\r\nWe are given a hidden Boolean function f,\r\nwhich takes as input a string of bits, and returns either 0 or 1:\r\n\r\nf({x0,x1,x2,...}) -&gt; 0 or 1, where xn is 0 or 1\r\n\r\nThe property of the given Boolean function is that it is guaranteed to\r\neither be balanced or constant. A constant function returns all 0&#x27;s\r\nor all 1&#x27;s for any input, while a balanced function returns  0&#x27;s for\r\nexactly half of all inputs and 1&#x27;s for the other half. Our task is to\r\ndetermine whether the given function is balanced or constant.\r\n\r\nReferences:\r\n- https://en.wikipedia.org/wiki/Deutsch-Jozsa_algorithm\r\n- https://qiskit.org/textbook/ch-algorithms/deutsch-jozsa.html\r\n&quot;&quot;&quot;</span>\r\n\r\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\r\n<span class=\"hljs-keyword\">import</span> qiskit <span class=\"hljs-keyword\">as</span> q\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">dj_oracle</span>(<span class=\"hljs-params\">case: <span class=\"hljs-built_in\">str</span>, num_qubits: <span class=\"hljs-built_in\">int</span></span>) -&gt; q.QuantumCircuit:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Returns a Quantum Circuit for the Oracle function.\r\n    The circuit returned can represent balanced or constant function,\r\n    according to the arguments passed\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-comment\"># This circuit has num_qubits+1 qubits: the size of the input,</span>\r\n    <span class=\"hljs-comment\"># plus one output qubit</span>\r\n    oracle_qc = q.QuantumCircuit(num_qubits + <span class=\"hljs-number\">1</span>)\r\n\r\n    <span class=\"hljs-comment\"># First, let&#x27;s deal with the case in which oracle is balanced</span>\r\n    <span class=\"hljs-keyword\">if</span> case == <span class=\"hljs-string\">&quot;balanced&quot;</span>:\r\n        <span class=\"hljs-comment\"># First generate a random number that tells us which CNOTs to</span>\r\n        <span class=\"hljs-comment\"># wrap in X-gates:</span>\r\n        b = np.random.randint(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>**num_qubits)\r\n        <span class=\"hljs-comment\"># Next, format &#x27;b&#x27; as a binary string of length &#x27;n&#x27;, padded with zeros:</span>\r\n        b_str = <span class=\"hljs-built_in\">format</span>(b, <span class=\"hljs-string\">f&quot;0<span class=\"hljs-subst\">{num_qubits}</span>b&quot;</span>)\r\n        <span class=\"hljs-comment\"># Next, we place the first X-gates. Each digit in our binary string</span>\r\n        <span class=\"hljs-comment\"># correspopnds to a qubit, if the digit is 0, we do nothing, if it&#x27;s 1</span>\r\n        <span class=\"hljs-comment\"># we apply an X-gate to that qubit:</span>\r\n        <span class=\"hljs-keyword\">for</span> index, bit <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(b_str):\r\n            <span class=\"hljs-keyword\">if</span> bit == <span class=\"hljs-string\">&quot;1&quot;</span>:\r\n                oracle_qc.x(index)\r\n        <span class=\"hljs-comment\"># Do the controlled-NOT gates for each qubit, using the output qubit</span>\r\n        <span class=\"hljs-comment\"># as the target:</span>\r\n        <span class=\"hljs-keyword\">for</span> index <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(num_qubits):\r\n            oracle_qc.cx(index, num_qubits)\r\n        <span class=\"hljs-comment\"># Next, place the final X-gates</span>\r\n        <span class=\"hljs-keyword\">for</span> index, bit <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(b_str):\r\n            <span class=\"hljs-keyword\">if</span> bit == <span class=\"hljs-string\">&quot;1&quot;</span>:\r\n                oracle_qc.x(index)\r\n\r\n    <span class=\"hljs-comment\"># Case in which oracle is constant</span>\r\n    <span class=\"hljs-keyword\">if</span> case == <span class=\"hljs-string\">&quot;constant&quot;</span>:\r\n        <span class=\"hljs-comment\"># First decide what the fixed output of the oracle will be</span>\r\n        <span class=\"hljs-comment\"># (either always 0 or always 1)</span>\r\n        output = np.random.randint(<span class=\"hljs-number\">2</span>)\r\n        <span class=\"hljs-keyword\">if</span> output == <span class=\"hljs-number\">1</span>:\r\n            oracle_qc.x(num_qubits)\r\n\r\n    oracle_gate = oracle_qc.to_gate()\r\n    oracle_gate.name = <span class=\"hljs-string\">&quot;Oracle&quot;</span>  <span class=\"hljs-comment\"># To show when we display the circuit</span>\r\n    <span class=\"hljs-keyword\">return</span> oracle_gate\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">dj_algorithm</span>(<span class=\"hljs-params\">oracle: q.QuantumCircuit, num_qubits: <span class=\"hljs-built_in\">int</span></span>) -&gt; q.QuantumCircuit:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Returns the complete Deustch-Jozsa Quantum Circuit,\r\n    adding Input &amp; Output registers and Hadamard &amp; Measurement Gates,\r\n    to the Oracle Circuit passed in arguments\r\n    &quot;&quot;&quot;</span>\r\n    dj_circuit = q.QuantumCircuit(num_qubits + <span class=\"hljs-number\">1</span>, num_qubits)\r\n    <span class=\"hljs-comment\"># Set up the output qubit:</span>\r\n    dj_circuit.x(num_qubits)\r\n    dj_circuit.h(num_qubits)\r\n    <span class=\"hljs-comment\"># And set up the input register:</span>\r\n    <span class=\"hljs-keyword\">for</span> qubit <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(num_qubits):\r\n        dj_circuit.h(qubit)\r\n    <span class=\"hljs-comment\"># Let&#x27;s append the oracle gate to our circuit:</span>\r\n    dj_circuit.append(oracle, <span class=\"hljs-built_in\">range</span>(num_qubits + <span class=\"hljs-number\">1</span>))\r\n    <span class=\"hljs-comment\"># Finally, perform the H-gates again and measure:</span>\r\n    <span class=\"hljs-keyword\">for</span> qubit <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(num_qubits):\r\n        dj_circuit.h(qubit)\r\n\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(num_qubits):\r\n        dj_circuit.measure(i, i)\r\n\r\n    <span class=\"hljs-keyword\">return</span> dj_circuit\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">deutsch_jozsa</span>(<span class=\"hljs-params\">case: <span class=\"hljs-built_in\">str</span>, num_qubits: <span class=\"hljs-built_in\">int</span></span>) -&gt; q.result.counts.Counts:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Main function that builds the circuit using other helper functions,\r\n    runs the experiment 1000 times &amp; returns the resultant qubit counts\r\n    &gt;&gt;&gt; deutsch_jozsa(&quot;constant&quot;, 3)\r\n    {&#x27;000&#x27;: 1000}\r\n    &gt;&gt;&gt; deutsch_jozsa(&quot;balanced&quot;, 3)\r\n    {&#x27;111&#x27;: 1000}\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-comment\"># Use Aer&#x27;s qasm_simulator</span>\r\n    simulator = q.Aer.get_backend(<span class=\"hljs-string\">&quot;qasm_simulator&quot;</span>)\r\n\r\n    oracle_gate = dj_oracle(case, num_qubits)\r\n    dj_circuit = dj_algorithm(oracle_gate, num_qubits)\r\n\r\n    <span class=\"hljs-comment\"># Execute the circuit on the qasm simulator</span>\r\n    job = q.execute(dj_circuit, simulator, shots=<span class=\"hljs-number\">1000</span>)\r\n\r\n    <span class=\"hljs-comment\"># Return the histogram data of the results of the experiment.</span>\r\n    <span class=\"hljs-keyword\">return</span> job.result().get_counts(dj_circuit)\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;Deutsch Jozsa - Constant Oracle: <span class=\"hljs-subst\">{deutsch_jozsa(<span class=\"hljs-string\">&#x27;constant&#x27;</span>, <span class=\"hljs-number\">3</span>)}</span>&quot;</span>)\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;Deutsch Jozsa - Balanced Oracle: <span class=\"hljs-subst\">{deutsch_jozsa(<span class=\"hljs-string\">&#x27;balanced&#x27;</span>, <span class=\"hljs-number\">3</span>)}</span>&quot;</span>)\r\n"
    }
  },
  "contributors": [
    {
      "name": "Abhishek Jaisingh",
      "email": "abhi2254015@gmail.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}