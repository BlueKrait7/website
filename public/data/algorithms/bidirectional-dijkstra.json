{
  "slug": "bidirectional-dijkstra",
  "name": "Bidirectional Dijkstra",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "graph\\bidirectional_dijkstra.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph\\bidirectional_dijkstra.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @brief [Bidirectional Dijkstra Shortest Path Algorithm]\r\n * (https://www.coursera.org/learn/algorithms-on-graphs/lecture/7ml18/bidirectional-dijkstra)\r\n *\r\n * @author [Marinovksy](http://github.com/Marinovsky)\r\n *\r\n * @details\r\n * This is basically the same Dijkstra Algorithm but faster because it goes from\r\n * the source to the target and from target to the source and stops when\r\n * finding a vertex visited already by the direct search or the reverse one.\r\n * Here some simulations of it:\r\n * https://www.youtube.com/watch?v=DINCL5cd_w0&amp;t=24s\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>   <span class=\"hljs-comment\">/// for assert</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">/// for io operations</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;limits&gt;</span>    <span class=\"hljs-comment\">/// for variable INF</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span>     <span class=\"hljs-comment\">/// for the priority_queue of distances</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;utility&gt;</span>   <span class=\"hljs-comment\">/// for make_pair function</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>    <span class=\"hljs-comment\">/// for store the graph, the distances, and the path</span></span>\r\n\r\n<span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int64_t</span> INF = std::numeric_limits&lt;<span class=\"hljs-type\">int64_t</span>&gt;::<span class=\"hljs-built_in\">max</span>();\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace graph\r\n * @brief Graph Algorithms\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> graph {\r\n<span class=\"hljs-comment\">/**\r\n * @namespace bidirectional_dijkstra\r\n * @brief Functions for [Bidirectional Dijkstra Shortest Path]\r\n * (https://www.coursera.org/learn/algorithms-on-graphs/lecture/7ml18/bidirectional-dijkstra)\r\n * algorithm\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> bidirectional_dijkstra {\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function that add edge between two nodes or vertices of graph\r\n *\r\n * @param adj1 adjacency list for the direct search\r\n * @param adj2 adjacency list for the reverse search\r\n * @param u any node or vertex of graph\r\n * @param v any node or vertex of graph\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addEdge</span><span class=\"hljs-params\">(std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; *adj1,\r\n             std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; *adj2,\r\n             <span class=\"hljs-type\">uint64_t</span> u, <span class=\"hljs-type\">uint64_t</span> v, <span class=\"hljs-type\">uint64_t</span> w)</span> </span>{\r\n    (*adj1)[u - <span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">push_back</span>(std::<span class=\"hljs-built_in\">make_pair</span>(v - <span class=\"hljs-number\">1</span>, w));\r\n    (*adj2)[v - <span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">push_back</span>(std::<span class=\"hljs-built_in\">make_pair</span>(u - <span class=\"hljs-number\">1</span>, w));\r\n    <span class=\"hljs-comment\">// (*adj)[v - 1].push_back(std::make_pair(u - 1, w));</span>\r\n}\r\n<span class=\"hljs-comment\">/**\r\n * @brief This function returns the shortest distance from the source\r\n * to the target if there is path between vertices &#x27;s&#x27; and &#x27;t&#x27;.\r\n *\r\n * @param workset_ vertices visited in the search\r\n * @param distance_ vector of distances from the source to the target and\r\n * from the target to the source\r\n *\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">uint64_t</span> <span class=\"hljs-title\">Shortest_Path_Distance</span><span class=\"hljs-params\">(\r\n    <span class=\"hljs-type\">const</span> std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; &amp;workset_,\r\n    <span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt;&gt; &amp;distance_)</span> </span>{\r\n    <span class=\"hljs-type\">int64_t</span> distance = INF;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint64_t</span> i : workset_) {\r\n        <span class=\"hljs-keyword\">if</span> (distance_[<span class=\"hljs-number\">0</span>][i] + distance_[<span class=\"hljs-number\">1</span>][i] &lt; distance) {\r\n            distance = distance_[<span class=\"hljs-number\">0</span>][i] + distance_[<span class=\"hljs-number\">1</span>][i];\r\n        }\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> distance;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function runs the dijkstra algorithm for some source vertex and\r\n * target vertex in the graph and returns the shortest distance of target\r\n * from the source.\r\n *\r\n * @param adj1 input graph\r\n * @param adj2 input graph reversed\r\n * @param s source vertex\r\n * @param t target vertex\r\n *\r\n * @return shortest distance if target is reachable from source else -1 in\r\n * case if target is not reachable from source.\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Bidijkstra</span><span class=\"hljs-params\">(std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; *adj1,\r\n               std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; *adj2,\r\n               <span class=\"hljs-type\">uint64_t</span> s, <span class=\"hljs-type\">uint64_t</span> t)</span> </span>{\r\n    <span class=\"hljs-comment\">/// n denotes the number of vertices in graph</span>\r\n    <span class=\"hljs-type\">uint64_t</span> n = adj1-&gt;<span class=\"hljs-built_in\">size</span>();\r\n\r\n    <span class=\"hljs-comment\">/// setting all the distances initially to INF</span>\r\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt;&gt; <span class=\"hljs-built_in\">dist</span>(<span class=\"hljs-number\">2</span>, std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">uint64_t</span>&gt;(n, INF));\r\n\r\n    <span class=\"hljs-comment\">/// creating a a vector of min heap using priority queue</span>\r\n    <span class=\"hljs-comment\">/// pq[0] contains the min heap for the direct search</span>\r\n    <span class=\"hljs-comment\">/// pq[1] contains the min heap for the reverse search</span>\r\n\r\n    <span class=\"hljs-comment\">/// first element of pair contains the distance</span>\r\n    <span class=\"hljs-comment\">/// second element of pair contains the vertex</span>\r\n    std::vector&lt;\r\n        std::priority_queue&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;,\r\n                            std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;,\r\n                            std::greater&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt;&gt;\r\n        <span class=\"hljs-built_in\">pq</span>(<span class=\"hljs-number\">2</span>);\r\n    <span class=\"hljs-comment\">/// vector for store the nodes or vertices in the shortest path</span>\r\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; <span class=\"hljs-title\">workset</span><span class=\"hljs-params\">(n)</span></span>;\r\n    <span class=\"hljs-comment\">/// vector for store the nodes or vertices visited</span>\r\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-title\">visited</span><span class=\"hljs-params\">(n)</span></span>;\r\n\r\n    <span class=\"hljs-comment\">/// pushing the source vertex &#x27;s&#x27; with 0 distance in pq[0] min heap</span>\r\n    pq[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">push</span>(std::<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">0</span>, s));\r\n\r\n    <span class=\"hljs-comment\">/// marking the distance of source as 0</span>\r\n    dist[<span class=\"hljs-number\">0</span>][s] = <span class=\"hljs-number\">0</span>;\r\n\r\n    <span class=\"hljs-comment\">/// pushing the target vertex &#x27;t&#x27; with 0 distance in pq[1] min heap</span>\r\n    pq[<span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">push</span>(std::<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">0</span>, t));\r\n\r\n    <span class=\"hljs-comment\">/// marking the distance of target as 0</span>\r\n    dist[<span class=\"hljs-number\">1</span>][t] = <span class=\"hljs-number\">0</span>;\r\n\r\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\r\n        <span class=\"hljs-comment\">/// direct search</span>\r\n\r\n        <span class=\"hljs-comment\">// If pq[0].size() is equal to zero then the node/ vertex is not</span>\r\n        <span class=\"hljs-comment\">// reachable from s</span>\r\n        <span class=\"hljs-keyword\">if</span> (pq[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>) {\r\n            <span class=\"hljs-keyword\">break</span>;\r\n        }\r\n        <span class=\"hljs-comment\">/// second element of pair denotes the node / vertex</span>\r\n        <span class=\"hljs-type\">uint64_t</span> currentNode = pq[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">top</span>().second;\r\n\r\n        <span class=\"hljs-comment\">/// first element of pair denotes the distance</span>\r\n        <span class=\"hljs-type\">uint64_t</span> currentDist = pq[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">top</span>().first;\r\n\r\n        pq[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">pop</span>();\r\n\r\n        <span class=\"hljs-comment\">/// for all the reachable vertex from the currently exploring vertex</span>\r\n        <span class=\"hljs-comment\">/// we will try to minimize the distance</span>\r\n        <span class=\"hljs-keyword\">for</span> (std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; edge : (*adj1)[currentNode]) {\r\n            <span class=\"hljs-comment\">/// minimizing distances</span>\r\n            <span class=\"hljs-keyword\">if</span> (currentDist + edge.second &lt; dist[<span class=\"hljs-number\">0</span>][edge.first]) {\r\n                dist[<span class=\"hljs-number\">0</span>][edge.first] = currentDist + edge.second;\r\n                pq[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">push</span>(std::<span class=\"hljs-built_in\">make_pair</span>(dist[<span class=\"hljs-number\">0</span>][edge.first], edge.first));\r\n            }\r\n        }\r\n        <span class=\"hljs-comment\">// store the processed node/ vertex</span>\r\n        workset.<span class=\"hljs-built_in\">push_back</span>(currentNode);\r\n\r\n        <span class=\"hljs-comment\">/// check if currentNode has already been visited</span>\r\n        <span class=\"hljs-keyword\">if</span> (visited[currentNode] == <span class=\"hljs-number\">1</span>) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Shortest_Path_Distance</span>(workset, dist);\r\n        }\r\n        visited[currentNode] = <span class=\"hljs-literal\">true</span>;\r\n        <span class=\"hljs-comment\">/// reversed search</span>\r\n\r\n        <span class=\"hljs-comment\">// If pq[1].size() is equal to zero then the node/ vertex is not</span>\r\n        <span class=\"hljs-comment\">// reachable from t</span>\r\n        <span class=\"hljs-keyword\">if</span> (pq[<span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>) {\r\n            <span class=\"hljs-keyword\">break</span>;\r\n        }\r\n        <span class=\"hljs-comment\">/// second element of pair denotes the node / vertex</span>\r\n        currentNode = pq[<span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">top</span>().second;\r\n\r\n        <span class=\"hljs-comment\">/// first element of pair denotes the distance</span>\r\n        currentDist = pq[<span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">top</span>().first;\r\n\r\n        pq[<span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">pop</span>();\r\n\r\n        <span class=\"hljs-comment\">/// for all the reachable vertex from the currently exploring vertex</span>\r\n        <span class=\"hljs-comment\">/// we will try to minimize the distance</span>\r\n        <span class=\"hljs-keyword\">for</span> (std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; edge : (*adj2)[currentNode]) {\r\n            <span class=\"hljs-comment\">/// minimizing distances</span>\r\n            <span class=\"hljs-keyword\">if</span> (currentDist + edge.second &lt; dist[<span class=\"hljs-number\">1</span>][edge.first]) {\r\n                dist[<span class=\"hljs-number\">1</span>][edge.first] = currentDist + edge.second;\r\n                pq[<span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">push</span>(std::<span class=\"hljs-built_in\">make_pair</span>(dist[<span class=\"hljs-number\">1</span>][edge.first], edge.first));\r\n            }\r\n        }\r\n        <span class=\"hljs-comment\">// store the processed node/ vertex</span>\r\n        workset.<span class=\"hljs-built_in\">push_back</span>(currentNode);\r\n\r\n        <span class=\"hljs-comment\">/// check if currentNode has already been visited</span>\r\n        <span class=\"hljs-keyword\">if</span> (visited[currentNode] == <span class=\"hljs-number\">1</span>) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Shortest_Path_Distance</span>(workset, dist);\r\n        }\r\n        visited[currentNode] = <span class=\"hljs-literal\">true</span>;\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\r\n}\r\n}  <span class=\"hljs-comment\">// namespace bidirectional_dijkstra</span>\r\n}  <span class=\"hljs-comment\">// namespace graph</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function to test the\r\n * provided algorithm above\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">tests</span><span class=\"hljs-params\">()</span> </span>{\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Initiatinig Predefined Tests...&quot;</span> &lt;&lt; std::endl;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Initiating Test 1...&quot;</span> &lt;&lt; std::endl;\r\n    std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">adj1_1</span>(\r\n        <span class=\"hljs-number\">4</span>, std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;());\r\n    std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">adj1_2</span>(\r\n        <span class=\"hljs-number\">4</span>, std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;());\r\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj1_1, &amp;adj1_2, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>);\r\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj1_1, &amp;adj1_2, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\r\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj1_1, &amp;adj1_2, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>);\r\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj1_1, &amp;adj1_2, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>);\r\n\r\n    <span class=\"hljs-type\">uint64_t</span> s = <span class=\"hljs-number\">1</span>, t = <span class=\"hljs-number\">3</span>;\r\n    <span class=\"hljs-built_in\">assert</span>(graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">Bidijkstra</span>(&amp;adj1_1, &amp;adj1_2, s - <span class=\"hljs-number\">1</span>,\r\n                                                     t - <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">3</span>);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1 Passed...&quot;</span> &lt;&lt; std::endl;\r\n\r\n    s = <span class=\"hljs-number\">4</span>, t = <span class=\"hljs-number\">3</span>;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Initiating Test 2...&quot;</span> &lt;&lt; std::endl;\r\n    <span class=\"hljs-built_in\">assert</span>(graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">Bidijkstra</span>(&amp;adj1_1, &amp;adj1_2, s - <span class=\"hljs-number\">1</span>,\r\n                                                     t - <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">5</span>);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2 Passed...&quot;</span> &lt;&lt; std::endl;\r\n\r\n    std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">adj2_1</span>(\r\n        <span class=\"hljs-number\">5</span>, std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;());\r\n    std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">adj2_2</span>(\r\n        <span class=\"hljs-number\">5</span>, std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;());\r\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>);\r\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>);\r\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>);\r\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>);\r\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>);\r\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>);\r\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>);\r\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>);\r\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>);\r\n\r\n    s = <span class=\"hljs-number\">1</span>, t = <span class=\"hljs-number\">5</span>;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Initiating Test 3...&quot;</span> &lt;&lt; std::endl;\r\n    <span class=\"hljs-built_in\">assert</span>(graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">Bidijkstra</span>(&amp;adj2_1, &amp;adj2_2, s - <span class=\"hljs-number\">1</span>,\r\n                                                     t - <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">6</span>);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 3 Passed...&quot;</span> &lt;&lt; std::endl;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;All Test Passed...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::endl;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-built_in\">tests</span>();  <span class=\"hljs-comment\">// running predefined tests</span>\r\n    <span class=\"hljs-type\">uint64_t</span> vertices = <span class=\"hljs-built_in\">uint64_t</span>();\r\n    <span class=\"hljs-type\">uint64_t</span> edges = <span class=\"hljs-built_in\">uint64_t</span>();\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the number of vertices : &quot;</span>;\r\n    std::cin &gt;&gt; vertices;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the number of edges : &quot;</span>;\r\n    std::cin &gt;&gt; edges;\r\n\r\n    std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">adj1</span>(\r\n        vertices, std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;());\r\n    std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">adj2</span>(\r\n        vertices, std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;());\r\n\r\n    <span class=\"hljs-type\">uint64_t</span> u = <span class=\"hljs-built_in\">uint64_t</span>(), v = <span class=\"hljs-built_in\">uint64_t</span>(), w = <span class=\"hljs-built_in\">uint64_t</span>();\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the edges by three integers in this form: u v w &quot;</span>\r\n              &lt;&lt; std::endl;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Example: if there is and edge between node 1 and node 4 with &quot;</span>\r\n                 <span class=\"hljs-string\">&quot;weight 7 enter: 1 4 7, and then press enter&quot;</span>\r\n              &lt;&lt; std::endl;\r\n    <span class=\"hljs-keyword\">while</span> (edges--) {\r\n        std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\r\n        graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj1, &amp;adj2, u, v, w);\r\n        <span class=\"hljs-keyword\">if</span> (edges != <span class=\"hljs-number\">0</span>) {\r\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the next edge&quot;</span> &lt;&lt; std::endl;\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-type\">uint64_t</span> s = <span class=\"hljs-built_in\">uint64_t</span>(), t = <span class=\"hljs-built_in\">uint64_t</span>();\r\n    std::cout\r\n        &lt;&lt; <span class=\"hljs-string\">&quot;Enter the source node and the target node separated by a space&quot;</span>\r\n        &lt;&lt; std::endl;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Example: If the source node is 5 and the target node is 6 &quot;</span>\r\n                 <span class=\"hljs-string\">&quot;enter: 5 6 and press enter&quot;</span>\r\n              &lt;&lt; std::endl;\r\n    std::cin &gt;&gt; s &gt;&gt; t;\r\n    <span class=\"hljs-type\">int</span> dist =\r\n        graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">Bidijkstra</span>(&amp;adj1, &amp;adj2, s - <span class=\"hljs-number\">1</span>, t - <span class=\"hljs-number\">1</span>);\r\n    <span class=\"hljs-keyword\">if</span> (dist == <span class=\"hljs-number\">-1</span>) {\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Target not reachable from source&quot;</span> &lt;&lt; std::endl;\r\n    } <span class=\"hljs-keyword\">else</span> {\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Shortest Path Distance : &quot;</span> &lt;&lt; dist &lt;&lt; std::endl;\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Ricardo Andrés Marino Rojas",
      "email": "47573394+Marinovsky@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}