{
  "slug": "modular-division",
  "name": "Modular Division",
  "categories": [
    "blockchain"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "blockchain\\modular_division.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/blockchain\\modular_division.py",
      "code": "<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">modular_division</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">int</span>, b: <span class=\"hljs-built_in\">int</span>, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Modular Division :\r\n    An efficient algorithm for dividing b by a modulo n.\r\n\r\n    GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\r\n\r\n    Given three integers a, b, and n, such that gcd(a,n)=1 and n&gt;1, the algorithm should\r\n    return an integer x such that 0≤x≤n−1, and  b/a=x(modn) (that is, b=ax(modn)).\r\n\r\n    Theorem:\r\n    a has a multiplicative inverse modulo n iff gcd(a,n) = 1\r\n\r\n\r\n    This find x = b*a^(-1) mod n\r\n    Uses ExtendedEuclid to find the inverse of a\r\n\r\n    &gt;&gt;&gt; modular_division(4,8,5)\r\n    2\r\n\r\n    &gt;&gt;&gt; modular_division(3,8,5)\r\n    1\r\n\r\n    &gt;&gt;&gt; modular_division(4, 11, 5)\r\n    4\r\n\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-keyword\">assert</span> n &gt; <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">and</span> a &gt; <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> greatest_common_divisor(a, n) == <span class=\"hljs-number\">1</span>\r\n    (d, t, s) = extended_gcd(n, a)  <span class=\"hljs-comment\"># Implemented below</span>\r\n    x = (b * s) % n\r\n    <span class=\"hljs-keyword\">return</span> x\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">invert_modulo</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">int</span>, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    This function find the inverses of a i.e., a^(-1)\r\n\r\n    &gt;&gt;&gt; invert_modulo(2, 5)\r\n    3\r\n\r\n    &gt;&gt;&gt; invert_modulo(8,7)\r\n    1\r\n\r\n    &quot;&quot;&quot;</span>\r\n    (b, x) = extended_euclid(a, n)  <span class=\"hljs-comment\"># Implemented below</span>\r\n    <span class=\"hljs-keyword\">if</span> b &lt; <span class=\"hljs-number\">0</span>:\r\n        b = (b % n + n) % n\r\n    <span class=\"hljs-keyword\">return</span> b\r\n\r\n\r\n<span class=\"hljs-comment\"># ------------------ Finding Modular division using invert_modulo -------------------</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">modular_division2</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">int</span>, b: <span class=\"hljs-built_in\">int</span>, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    This function used the above inversion of a to find x = (b*a^(-1))mod n\r\n\r\n    &gt;&gt;&gt; modular_division2(4,8,5)\r\n    2\r\n\r\n    &gt;&gt;&gt; modular_division2(3,8,5)\r\n    1\r\n\r\n    &gt;&gt;&gt; modular_division2(4, 11, 5)\r\n    4\r\n\r\n    &quot;&quot;&quot;</span>\r\n    s = invert_modulo(a, n)\r\n    x = (b * s) % n\r\n    <span class=\"hljs-keyword\">return</span> x\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">extended_gcd</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">int</span>, b: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>]:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Extended Euclid&#x27;s Algorithm : If d divides a and b and d = a*x + b*y for integers x\r\n    and y, then d = gcd(a,b)\r\n    &gt;&gt;&gt; extended_gcd(10, 6)\r\n    (2, -1, 2)\r\n\r\n    &gt;&gt;&gt; extended_gcd(7, 5)\r\n    (1, -2, 3)\r\n\r\n    ** extended_gcd function is used when d = gcd(a,b) is required in output\r\n\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-keyword\">assert</span> a &gt;= <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> b &gt;= <span class=\"hljs-number\">0</span>\r\n\r\n    <span class=\"hljs-keyword\">if</span> b == <span class=\"hljs-number\">0</span>:\r\n        d, x, y = a, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>\r\n    <span class=\"hljs-keyword\">else</span>:\r\n        (d, p, q) = extended_gcd(b, a % b)\r\n        x = q\r\n        y = p - q * (a // b)\r\n\r\n    <span class=\"hljs-keyword\">assert</span> a % d == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> b % d == <span class=\"hljs-number\">0</span>\r\n    <span class=\"hljs-keyword\">assert</span> d == a * x + b * y\r\n\r\n    <span class=\"hljs-keyword\">return</span> (d, x, y)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">extended_euclid</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">int</span>, b: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>]:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Extended Euclid\r\n    &gt;&gt;&gt; extended_euclid(10, 6)\r\n    (-1, 2)\r\n\r\n    &gt;&gt;&gt; extended_euclid(7, 5)\r\n    (-2, 3)\r\n\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-keyword\">if</span> b == <span class=\"hljs-number\">0</span>:\r\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>)\r\n    (x, y) = extended_euclid(b, a % b)\r\n    k = a // b\r\n    <span class=\"hljs-keyword\">return</span> (y, x - k * y)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">greatest_common_divisor</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">int</span>, b: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Euclid&#x27;s Lemma :  d divides a and b, if and only if d divides a-b and b\r\n    Euclid&#x27;s Algorithm\r\n\r\n    &gt;&gt;&gt; greatest_common_divisor(7,5)\r\n    1\r\n\r\n    Note : In number theory, two integers a and b are said to be relatively prime,\r\n        mutually prime, or co-prime if the only positive integer (factor) that divides\r\n        both of them is 1  i.e., gcd(a,b) = 1.\r\n\r\n    &gt;&gt;&gt; greatest_common_divisor(121, 11)\r\n    11\r\n\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-keyword\">if</span> a &lt; b:\r\n        a, b = b, a\r\n\r\n    <span class=\"hljs-keyword\">while</span> a % b != <span class=\"hljs-number\">0</span>:\r\n        a, b = b, a % b\r\n\r\n    <span class=\"hljs-keyword\">return</span> b\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    <span class=\"hljs-keyword\">from</span> doctest <span class=\"hljs-keyword\">import</span> testmod\r\n\r\n    testmod(name=<span class=\"hljs-string\">&quot;modular_division&quot;</span>, verbose=<span class=\"hljs-literal\">True</span>)\r\n    testmod(name=<span class=\"hljs-string\">&quot;modular_division2&quot;</span>, verbose=<span class=\"hljs-literal\">True</span>)\r\n    testmod(name=<span class=\"hljs-string\">&quot;invert_modulo&quot;</span>, verbose=<span class=\"hljs-literal\">True</span>)\r\n    testmod(name=<span class=\"hljs-string\">&quot;extended_gcd&quot;</span>, verbose=<span class=\"hljs-literal\">True</span>)\r\n    testmod(name=<span class=\"hljs-string\">&quot;extended_euclid&quot;</span>, verbose=<span class=\"hljs-literal\">True</span>)\r\n    testmod(name=<span class=\"hljs-string\">&quot;greatest_common_divisor&quot;</span>, verbose=<span class=\"hljs-literal\">True</span>)\r\n"
    },
    "c-plus-plus": {
      "dir": "math\\modular_division.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/math\\modular_division.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @brief An algorithm to divide two numbers under modulo p [Modular\r\n * Division](https://www.geeksforgeeks.org/modular-division)\r\n * @details To calculate division of two numbers under modulo p\r\n * Modulo operator is not distributive under division, therefore\r\n * we first have to calculate the inverse of divisor using\r\n * [Fermat&#x27;s little\r\n theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem)\r\n * Now, we can multiply the dividend with the inverse of divisor\r\n * and modulo is distributive over multiplication operation.\r\n * Let,\r\n * We have 3 numbers a, b, p\r\n * To compute (a/b)%p\r\n * (a/b)%p ≡ (a*(inverse(b)))%p ≡ ((a%p)*inverse(b)%p)%p\r\n * <span class=\"hljs-doctag\">NOTE:</span> For the existence of inverse of &#x27;b&#x27;, &#x27;b&#x27; and &#x27;p&#x27; must be coprime\r\n * For simplicity we take p as prime\r\n * Time Complexity: O(log(b))\r\n * Example: ( 24 / 3 ) % 5 =&gt; 8 % 5 = 3 --- (i)\r\n            Now the inverse of 3 is 2\r\n            (24 * 2) % 5 = (24 % 5) * (2 % 5) = (4 * 2) % 5 = 3 --- (ii)\r\n            (i) and (ii) are equal hence the answer is correct.\r\n * @see modular_inverse_fermat_little_theorem.cpp, modular_exponentiation.cpp\r\n * @author [Shubham Yadav](https://github.com/shubhamamsa)\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>   <span class=\"hljs-comment\">/// for assert</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">/// for IO operations</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace math\r\n * @brief Mathematical algorithms\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> math {\r\n<span class=\"hljs-comment\">/**\r\n * @namespace modular_division\r\n * @brief Functions for [Modular\r\n * Division](https://www.geeksforgeeks.org/modular-division) implementation\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> modular_division {\r\n<span class=\"hljs-comment\">/**\r\n * @brief This function calculates a raised to exponent b under modulo c using\r\n * modular exponentiation.\r\n * @param a integer base\r\n * @param b unsigned integer exponent\r\n * @param c integer modulo\r\n * @return a raised to power b modulo c\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">uint64_t</span> <span class=\"hljs-title\">power</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint64_t</span> a, <span class=\"hljs-type\">uint64_t</span> b, <span class=\"hljs-type\">uint64_t</span> c)</span> </span>{\r\n    <span class=\"hljs-type\">uint64_t</span> ans = <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">/// Initialize the answer to be returned</span>\r\n    a = a % c;         <span class=\"hljs-comment\">/// Update a if it is more than or equal to c</span>\r\n    <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-number\">0</span>) {\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">/// In case a is divisible by c;</span>\r\n    }\r\n    <span class=\"hljs-keyword\">while</span> (b &gt; <span class=\"hljs-number\">0</span>) {\r\n        <span class=\"hljs-comment\">/// If b is odd, multiply a with answer</span>\r\n        <span class=\"hljs-keyword\">if</span> (b &amp; <span class=\"hljs-number\">1</span>) {\r\n            ans = ((ans % c) * (a % c)) % c;\r\n        }\r\n        <span class=\"hljs-comment\">/// b must be even now</span>\r\n        b = b &gt;&gt; <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">/// b = b/2</span>\r\n        a = ((a % c) * (a % c)) % c;\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> ans;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief This function calculates modular division\r\n * @param a integer dividend\r\n * @param b integer divisor\r\n * @param p integer modulo\r\n * @return a/b modulo c\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">uint64_t</span> <span class=\"hljs-title\">mod_division</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint64_t</span> a, <span class=\"hljs-type\">uint64_t</span> b, <span class=\"hljs-type\">uint64_t</span> p)</span> </span>{\r\n    <span class=\"hljs-type\">uint64_t</span> inverse = <span class=\"hljs-built_in\">power</span>(b, p - <span class=\"hljs-number\">2</span>, p) % p;  <span class=\"hljs-comment\">/// Calculate the inverse of b</span>\r\n    <span class=\"hljs-type\">uint64_t</span> result =\r\n        ((a % p) * (inverse % p)) % p;  <span class=\"hljs-comment\">/// Calculate the final result</span>\r\n    <span class=\"hljs-keyword\">return</span> result;\r\n}\r\n}  <span class=\"hljs-comment\">// namespace modular_division</span>\r\n}  <span class=\"hljs-comment\">// namespace math</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Function for testing power function.\r\n * test cases and assert statement.\r\n * @returns `void`\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-type\">uint64_t</span> test_case_1 = math::modular_division::<span class=\"hljs-built_in\">mod_division</span>(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(test_case_1 == <span class=\"hljs-number\">0</span>);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1 Passed!&quot;</span> &lt;&lt; std::endl;\r\n    <span class=\"hljs-type\">uint64_t</span> test_case_2 = math::modular_division::<span class=\"hljs-built_in\">mod_division</span>(<span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(test_case_2 == <span class=\"hljs-number\">5</span>);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2 Passed!&quot;</span> &lt;&lt; std::endl;\r\n    <span class=\"hljs-type\">uint64_t</span> test_case_3 = math::modular_division::<span class=\"hljs-built_in\">mod_division</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(test_case_3 == <span class=\"hljs-number\">0</span>);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 3 Passed!&quot;</span> &lt;&lt; std::endl;\r\n    <span class=\"hljs-type\">uint64_t</span> test_case_4 = math::modular_division::<span class=\"hljs-built_in\">mod_division</span>(<span class=\"hljs-number\">81</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(test_case_4 == <span class=\"hljs-number\">2</span>);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 4 Passed!&quot;</span> &lt;&lt; std::endl;\r\n    <span class=\"hljs-type\">uint64_t</span> test_case_5 = math::modular_division::<span class=\"hljs-built_in\">mod_division</span>(<span class=\"hljs-number\">12848</span>, <span class=\"hljs-number\">73</span>, <span class=\"hljs-number\">29</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(test_case_5 == <span class=\"hljs-number\">2</span>);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 5 Passed!&quot;</span> &lt;&lt; std::endl;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @param argc commandline argument count (ignored)\r\n * @param argv commandline array of arguments (ignored)\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span> </span>{\r\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// execute the tests</span>\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "shellhub",
      "email": "shellhub.me@gmail.com",
      "commits": 1
    },
    {
      "name": "John Law",
      "email": "johnlaw.po@gmail.com",
      "commits": 1
    },
    {
      "name": "Jenia Dysin",
      "email": "jenia90@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Jie Han",
      "email": "jay.cn@outlook.com",
      "commits": 1
    },
    {
      "name": "Phyllipe Bezerra",
      "email": "32442929+pmba@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Sushil Singh",
      "email": "36241112+OddExtension5@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}