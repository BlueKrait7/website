{
  "slug": "is-graph-bipartite",
  "name": "Is Graph Bipartite",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "graph\\is_graph_bipartite.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph\\is_graph_bipartite.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n *\r\n * @brief Algorithm to check whether a graph is\r\n * [bipartite](https://en.wikipedia.org/wiki/Bipartite_graph)\r\n *\r\n * @details\r\n * A graph is a collection of nodes also called vertices and these vertices\r\n * are connected by edges. A graph is bipartite if its vertices can be\r\n * divided into two disjoint and independent sets U and V such that every edge\r\n * connects a vertex in U to one in V.\r\n *\r\n * The algorithm implemented in this file determines whether the given graph\r\n * is bipartite or not.\r\n *\r\n * &lt;pre&gt;\r\n *  Example - Here is a graph g1 with 5 vertices and is bipartite\r\n *\r\n *     1   4\r\n *    / \\ / \\\r\n *   2   3   5\r\n *\r\n * Example - Here is a graph G2 with 3 vertices and is not bipartite\r\n *\r\n *   1 --- 2\r\n *    \\   /\r\n *      3\r\n *\r\n * &lt;/pre&gt;\r\n *\r\n * @author [Akshat Vaya](https://github.com/AkVaya)\r\n *\r\n */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace graph\r\n * @brief Graph algorithms\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> graph {\r\n<span class=\"hljs-comment\">/**\r\n * @namespace is_graph_bipartite\r\n * @brief Functions for checking whether a graph is bipartite or not\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> is_graph_bipartite {\r\n<span class=\"hljs-comment\">/**\r\n * @brief Class for representing graph as an adjacency list.\r\n */</span>\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span> {\r\n <span class=\"hljs-keyword\">private</span>:\r\n    <span class=\"hljs-type\">int</span> n;  <span class=\"hljs-comment\">///&lt; size of the graph</span>\r\n\r\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt;\r\n        adj;  <span class=\"hljs-comment\">///&lt; adj stores the graph as an adjacency list</span>\r\n\r\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; side;  <span class=\"hljs-comment\">///&lt; stores the side of the vertex</span>\r\n\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Constructor that initializes the graph on creation\r\n     * @param size number of vertices of the graph\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Graph</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> size)</span> </span>{\r\n        n = size;\r\n        adj.<span class=\"hljs-built_in\">resize</span>(n);\r\n        side.<span class=\"hljs-built_in\">resize</span>(n, <span class=\"hljs-number\">-1</span>);\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> v)</span></span>;  <span class=\"hljs-comment\">/// function to add edges to our graph</span>\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span>\r\n    <span class=\"hljs-title\">is_bipartite</span><span class=\"hljs-params\">()</span></span>;  <span class=\"hljs-comment\">/// function to check whether the graph is bipartite or not</span>\r\n};\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function that add an edge between two nodes or vertices of graph\r\n *\r\n * @param u is a node or vertex of graph\r\n * @param v is a node or vertex of graph\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Graph::addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> v)</span> </span>{\r\n    adj[u - <span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">push_back</span>(v - <span class=\"hljs-number\">1</span>);\r\n    adj[v - <span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">push_back</span>(u - <span class=\"hljs-number\">1</span>);\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief function that checks whether the graph is bipartite or not\r\n * the function returns true if the graph is a bipartite graph\r\n * the function returns false if the graph is not a bipartite graph\r\n *\r\n * @details\r\n * Here, side refers to the two disjoint subsets of the bipartite graph.\r\n * Initially, the values of side are set to -1 which is an unassigned state. A\r\n * for loop is run for every vertex of the graph. If the current edge has no\r\n * side assigned to it, then a Breadth First Search operation is performed. If\r\n * two neighbours have the same side then the graph will not be bipartite and\r\n * the value of check becomes false. If and only if each pair of neighbours have\r\n * different sides, the value of check will be true and hence the graph\r\n * bipartite.\r\n *\r\n * @returns `true` if th graph is bipartite\r\n * @returns `false` otherwise\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Graph::is_bipartite</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-type\">bool</span> check = <span class=\"hljs-literal\">true</span>;\r\n    std::queue&lt;<span class=\"hljs-type\">int</span>&gt; q;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> current_edge = <span class=\"hljs-number\">0</span>; current_edge &lt; n; ++current_edge) {\r\n        <span class=\"hljs-keyword\">if</span> (side[current_edge] == <span class=\"hljs-number\">-1</span>) {\r\n            q.<span class=\"hljs-built_in\">push</span>(current_edge);\r\n            side[current_edge] = <span class=\"hljs-number\">0</span>;\r\n            <span class=\"hljs-keyword\">while</span> (q.<span class=\"hljs-built_in\">size</span>()) {\r\n                <span class=\"hljs-type\">int</span> current = q.<span class=\"hljs-built_in\">front</span>();\r\n                q.<span class=\"hljs-built_in\">pop</span>();\r\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> neighbour : adj[current]) {\r\n                    <span class=\"hljs-keyword\">if</span> (side[neighbour] == <span class=\"hljs-number\">-1</span>) {\r\n                        side[neighbour] = (<span class=\"hljs-number\">1</span> ^ side[current]);\r\n                        q.<span class=\"hljs-built_in\">push</span>(neighbour);\r\n                    } <span class=\"hljs-keyword\">else</span> {\r\n                        check &amp;= (side[neighbour] != side[current]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> check;\r\n}\r\n}  <span class=\"hljs-comment\">// namespace is_graph_bipartite</span>\r\n}  <span class=\"hljs-comment\">// namespace graph</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Function to test the above algorithm\r\n * @returns none\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\r\n    graph::<span class=\"hljs-function\">is_graph_bipartite::Graph <span class=\"hljs-title\">G1</span><span class=\"hljs-params\">(\r\n        <span class=\"hljs-number\">5</span>)</span></span>;  <span class=\"hljs-comment\">/// creating graph G1 with 5 vertices</span>\r\n    <span class=\"hljs-comment\">/// adding edges to the graphs as per the illustrated example</span>\r\n    G1.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\r\n    G1.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);\r\n    G1.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>);\r\n    G1.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>);\r\n\r\n    graph::<span class=\"hljs-function\">is_graph_bipartite::Graph <span class=\"hljs-title\">G2</span><span class=\"hljs-params\">(\r\n        <span class=\"hljs-number\">3</span>)</span></span>;  <span class=\"hljs-comment\">/// creating graph G2 with 3 vertices</span>\r\n    <span class=\"hljs-comment\">/// adding edges to the graphs as per the illustrated example</span>\r\n    G2.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\r\n    G2.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);\r\n    G2.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\r\n\r\n    <span class=\"hljs-comment\">/// checking whether the graphs are bipartite or not</span>\r\n    <span class=\"hljs-keyword\">if</span> (G1.<span class=\"hljs-built_in\">is_bipartite</span>()) {\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;The given graph G1 is a bipartite graph\\n&quot;</span>;\r\n    } <span class=\"hljs-keyword\">else</span> {\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;The given graph G1 is not a bipartite graph\\n&quot;</span>;\r\n    }\r\n    <span class=\"hljs-keyword\">if</span> (G2.<span class=\"hljs-built_in\">is_bipartite</span>()) {\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;The given graph G2 is a bipartite graph\\n&quot;</span>;\r\n    } <span class=\"hljs-keyword\">else</span> {\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;The given graph G2 is not a bipartite graph\\n&quot;</span>;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Main function\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">/// Testing</span>\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 1
    },
    {
      "name": "AkVaya",
      "email": "akshat.18je0072@am.iitism.ac.in",
      "commits": 7
    }
  ],
  "explanationUrl": {}
}