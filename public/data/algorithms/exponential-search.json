{
  "slug": "exponential-search",
  "name": "Exponential Search",
  "categories": [
    "searches"
  ],
  "body": {
    "es": "<h4>Requisitos previos</h4>\n<ul>\n<li><a href=\"https://github.com/faridevnz/Algorithms-Explicaci%C3%B3n/blob/master/en/Search%20Algorithms/Binary%20Search.md\">Algoritmo de búsqueda binaria</a></li>\n</ul>\n<h4>Declaración de problema</h4>\n<p>Dada una matriz ordenada de <em><code>n</code></em> elementos, escriba una función para buscar el índice de un elemento determinado (destino)</p>\n<h4>Enfoque</h4>\n<ul>\n<li>Búsqueda del <strong>rango</strong> dentro del cual se incluye el objetivo aumentando <em>index</em> por poderes de 2</li>\n<li>Si este rango existe en la matriz aplicar el algoritmo de búsqueda binaria sobre él</li>\n<li>Más retorno -1</li>\n</ul>\n<h4>Ejemplo</h4>\n<pre><code class=\"hljs language-markdown\">arr = [1, 2, 3, 4, 5, 6, 7, ... 998, 999, 1<span class=\"hljs-emphasis\">_000]\r\n\r\nobjetivo = 998\r\níndice = 0\r\n1. BÚSQUEDA DEL RANGO\r\níndice = 1, 2, 4, 8, 16, 32, 64, ..., 512, ..., 1_</span>024\r\ndespués de 10 iteración tenemos el índice en 1<span class=\"hljs-emphasis\">_024 y fuera de la matriz \r\n2. BÚSQUEDA BINARIA\r\nAhora podemos aplicar la búsqueda binaria en el subarray de 512 y 1_</span>000.\n</code></pre>\n<p><strong>Nota</strong>: aplicamos la búsqueda binaria de 512 a 1_000 porque en <code>i = 2^10 = 1_024</code> la matriz está finisced y el número de destino es menor que el índice más reciente de la matriz ( 1_000 ).</p>\n<h4>Complejidad temporal</h4>\n<p><strong>Peor caso:</strong> <code>O(log *i*)</code> donde <code>*i* = índice</code> (posición) del objetivo</p>\n<p><strong>Mejor caso:</strong> <code>O(*1*)</code></p>\n<h4>Explicación de complejidad</h4>\n<ul>\n<li>La complejidad de la primera parte del algoritmo es <strong><code>O( log *i* )</code></strong> porque si <em>i</em> es la posición del destino en la matriz, después de duplicar la búsqueda <em>index</em> <code>⌈log(i)⌉</code> veces, el algoritmo estará en un índice de búsqueda que es mayor o igual que <em>i</em>. Podemos escribir <code>2^⌈log(i)⌉ >= i</code></li>\n<li>La complejidad de la segunda parte del algoritmo también es <strong><code>O ( log *i* )</code></strong> porque se trata de una simple búsqueda binaria. La complejidad de búsqueda binaria ( como se explica <a href=\"https://github.com/faridevnz/Algorithms-Explicaci%C3%B3n/blob/master/en/Search%20Algorithms/Binary%20Search.md\">aquí</a> ) es <code>O(*n*)</code> donde <em>n</em> es la longitud de la matriz. En la búsqueda exponencial, la longitud de la matriz en la que se aplica el algoritmo es <code>2^i - 2^(i-1)</code>, en palabras significa <code>(la longitud de la matriz de principio a *i* ) - (la parte de matriz omitida hasta la iteración anterior)</code>. Es simple verificar que <code>2^i - 2^(i-1) = 2^(i-1)</code>.</li>\n</ul>\n<p>Después de esta explicación detallada, podemos decir que la complejidad de la búsqueda exponencial es:</p>\n<pre><code class=\"hljs language-mathematica\"><span class=\"hljs-built_in\">O</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">log</span> <span class=\"hljs-variable\">i</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-operator\">+</span> <span class=\"hljs-built_in\">O</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">log</span> <span class=\"hljs-variable\">i</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span><span class=\"hljs-built_in\">O</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">log</span> <span class=\"hljs-variable\">i</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">O</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">log</span> <span class=\"hljs-variable\">i</span><span class=\"hljs-punctuation\">)</span>\n</code></pre>\n<h4>Búsqueda binaria vs Búsqueda exponencial</h4>\n<p>Echemos un vistazo a esta comparación con un ejemplo menos teórico. Imagine que tenemos una matriz con elementos <code>1_000_000</code> y queremos buscar un elemento que esté en la posición <code>4th</code>. Es fácil ver que:</p>\n<ul>\n<li>La búsqueda binaria comienza desde el centro de la matriz y llega a la 4ª posición después de muchas iteraciones</li>\n<li>La búsqueda exponencial llega al 4º índice después de sólo 2 iteraciones</li>\n</ul>\n<h4>Enlaces de implementación de código</h4>\n<ul>\n<li><a href=\"https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/search/exponential_search.cpp\">C++</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/Javascript/blob/master/Search/ExponentialSearch.js\">JavaScript</a></li>\n</ul>",
    "en": "<h4>Prerequisites</h4>\n<ul>\n<li><a href=\"https://github.com/faridevnz/Algorithms-Explanation/blob/master/en/Search%20Algorithms/Binary%20Search.md\">Binary Search algorithm</a></li>\n</ul>\n<h4>Problem Statement</h4>\n<p>Given a sorted array of <em>n</em> elements, write a function to search for the index of a given element (target)</p>\n<h4>Approach</h4>\n<ul>\n<li>Search for the <strong>range</strong> within which the target is included increasing <em>index</em> by powers of 2</li>\n<li>If this range exists in array apply the Binary Search algorithm over it</li>\n<li>Else return -1</li>\n</ul>\n<h4>Example</h4>\n<pre><code class=\"hljs language-markdown\">arr = [1, 2, 3, 4, 5, 6, 7, ... 998, 999, 1<span class=\"hljs-emphasis\">_000]\r\n\r\ntarget = 998\r\nindex = 0\r\n1. SEARCHING FOR THE RANGE\r\nindex = 1, 2, 4, 8, 16, 32, 64, ..., 512, ..., 1_</span>024\r\nafter 10 iteration we have the index at 1<span class=\"hljs-emphasis\">_024 and outside of the array \r\n2. BINARY SEARCH\r\nNow we can apply the binary search on the subarray from 512 and 1_</span>000.\n</code></pre>\n<p><em><strong>Note</strong></em>: we apply the Binary Search from 512 to 1_000 because at <code>i = 2^10 = 1_024</code> the array is finisced and the target number is less than the latest index of the array ( 1_000 ).</p>\n<h4>Time Complexity</h4>\n<p><strong>worst case:</strong> <code>O(log *i*)</code> where <code>*i* = index</code> (position) of the target</p>\n<p><strong>best case:</strong> <code>O(*1*)</code></p>\n<h4>Complexity Explanation</h4>\n<ul>\n<li>The complexity of the first part of the algorithm is <strong>O( log <em>i</em> )</strong> because if <em>i</em> is the position of the target in the array, after doubling the search <em>index</em> <code>⌈log(i)⌉</code> times, the algorithm will be at a search index that is greater than or equal to <em>i</em>. We can write <code>2^⌈log(i)⌉ >= i</code></li>\n<li>The complexity of the second part of the algorithm also is <strong>O ( log <em>i</em> )</strong> because that is a simple Binary Search. The Binary Search complexity ( as explained <a href=\"https://github.com/faridevnz/Algorithms-Explanation/blob/master/en/Search%20Algorithms/Binary%20Search.md\">here</a> ) is O( <em>n</em> ) where <em>n</em> is the length of the array. In the Exponential Search, the length of the array on which the algorithm is applied is <code>2^i - 2^(i-1)</code>, put into words it means '( the length of the array from start to <em>i</em> ) - ( the part of array skipped until the previous iteration )'. Is simple verify that <code>2^i - 2^(i-1) = 2^(i-1) </code></li>\n</ul>\n<p>After this detailed explanation we can say that the the complexity of the Exponential Search is:</p>\n<pre><code class=\"hljs language-mathematica\"><span class=\"hljs-built_in\">O</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">log</span> <span class=\"hljs-variable\">i</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-operator\">+</span> <span class=\"hljs-built_in\">O</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">log</span> <span class=\"hljs-variable\">i</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span><span class=\"hljs-built_in\">O</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">log</span> <span class=\"hljs-variable\">i</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">O</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">log</span> <span class=\"hljs-variable\">i</span><span class=\"hljs-punctuation\">)</span>\n</code></pre>\n<h4>Binary Search vs Exponential Search</h4>\n<p>Let's take a look at this comparison with a less theoretical example. Imagine we have an array with<code>1_000_000</code> elements and we want to search an element that is in the <code>4th</code> position. It's easy to see that:</p>\n<ul>\n<li>The Binary Search start from the middle of the array and arrive to the 4th position after many iterations</li>\n<li>The Exponential Search arrive at the 4th index after only 2 iterations</li>\n</ul>\n<h4>Code Implementation Links</h4>\n<ul>\n<li><a href=\"https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/search/exponential_search.cpp\">C++</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/Javascript/blob/master/Search/ExponentialSearch.js\">JavaScript</a></li>\n</ul>"
  },
  "implementations": {
    "javascript": {
      "dir": "Search\\ExponentialSearch.js",
      "url": "https://github.com/TheAlgorithms/javascript/tree/master/Search\\ExponentialSearch.js",
      "code": "<span class=\"hljs-comment\">/**\r\n * Exponential Search\r\n *\r\n * The algorithm consists of two stages. The first stage determines a\r\n * range in which the search key would reside if it were in the list.\r\n * In the second stage, a binary search is performed on this range.\r\n *\r\n *\r\n *\r\n */</span>\r\n\r\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">binarySearch</span> (arr, value, floor, ceiling) {\r\n  <span class=\"hljs-comment\">// Middle index</span>\r\n  <span class=\"hljs-keyword\">const</span> mid = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>((floor + ceiling) / <span class=\"hljs-number\">2</span>)\r\n\r\n  <span class=\"hljs-comment\">// If value is at the mid position return this position</span>\r\n  <span class=\"hljs-keyword\">if</span> (arr[mid] === value) {\r\n    <span class=\"hljs-keyword\">return</span> mid\r\n  }\r\n\r\n  <span class=\"hljs-keyword\">if</span> (floor &gt; ceiling) <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>\r\n\r\n  <span class=\"hljs-comment\">// If the middle element is great than the value</span>\r\n  <span class=\"hljs-comment\">// search the left part of the array</span>\r\n  <span class=\"hljs-keyword\">if</span> (arr[mid] &gt; value) {\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">binarySearch</span>(arr, value, floor, mid - <span class=\"hljs-number\">1</span>)\r\n    <span class=\"hljs-comment\">// If the middle element is lower than the value</span>\r\n    <span class=\"hljs-comment\">// search the right part of the array</span>\r\n  } <span class=\"hljs-keyword\">else</span> {\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">binarySearch</span>(arr, value, mid + <span class=\"hljs-number\">1</span>, ceiling)\r\n  }\r\n}\r\n\r\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">exponentialSearch</span> (arr, length, value) {\r\n  <span class=\"hljs-comment\">// If value is the first element of the array return this position</span>\r\n  <span class=\"hljs-keyword\">if</span> (arr[<span class=\"hljs-number\">0</span>] === value) {\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\r\n  }\r\n\r\n  <span class=\"hljs-comment\">// Find range for binary search</span>\r\n  <span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">1</span>\r\n  <span class=\"hljs-keyword\">while</span> (i &lt; length &amp;&amp; arr[i] &lt;= value) {\r\n    i = i * <span class=\"hljs-number\">2</span>\r\n  }\r\n\r\n  <span class=\"hljs-comment\">// Call binary search for the range found above</span>\r\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">binarySearch</span>(arr, value, i / <span class=\"hljs-number\">2</span>, <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(i, length))\r\n}\r\n\r\n<span class=\"hljs-keyword\">export</span> { binarySearch, exponentialSearch }\r\n\r\n<span class=\"hljs-comment\">// const arr = [2, 3, 4, 10, 40, 65, 78, 100]</span>\r\n<span class=\"hljs-comment\">// const value = 78</span>\r\n<span class=\"hljs-comment\">// const result = exponentialSearch(arr, arr.length, value)</span>\r\n"
    },
    "c-plus-plus": {
      "dir": "search\\exponential_search.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/search\\exponential_search.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * \\file\r\n * \\brief [Exponential search\r\n * algorithm](https://en.wikipedia.org/wiki/Exponential_search)\r\n * \\copyright 2020 Divide-et-impera-11\r\n *\r\n * The algorithm try to search the range where the key should be.\r\n * If it has been found we do a binary search there.\r\n * The range of the search grows by exponential every time.\r\n * If the key is larger than the last element of array, the start of\r\n * block(block_front) will be equal to the end of block(block_size) and the\r\n * algorithm return null ponter, every other cases the algoritm return fom the\r\n * loop.\r\n */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _MSC_VER</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span>  <span class=\"hljs-comment\">// use for MS Visual C++</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span>  <span class=\"hljs-comment\">// for all other compilers</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n\r\n<span class=\"hljs-comment\">/** Binary Search Algorithm (used by ::struzik_search)\\n\r\n * * Time Complexity O(log n) where &#x27;n&#x27; is the number of elements\r\n * * Worst Time Complexity O(log n)\r\n * * Best Time Complexity Ω(1)\r\n * * Space Complexity O(1)\r\n * * Auxiliary Space Complexity O(1)\r\n * \\returns pointer to value in the array\r\n * \\returns `nullptr` if value not found\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Type</span>&gt;\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> Type* <span class=\"hljs-title\">binary_s</span><span class=\"hljs-params\">(Type* array, <span class=\"hljs-type\">size_t</span> size, Type key)</span> </span>{\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int32_t</span> <span class=\"hljs-title\">lower_index</span><span class=\"hljs-params\">(<span class=\"hljs-number\">0</span>)</span>, <span class=\"hljs-title\">upper_index</span><span class=\"hljs-params\">(size - <span class=\"hljs-number\">1</span>)</span>, middle_index</span>;\r\n\r\n    <span class=\"hljs-keyword\">while</span> (lower_index &lt;= upper_index) {\r\n        middle_index = std::<span class=\"hljs-built_in\">floor</span>((lower_index + upper_index) / <span class=\"hljs-number\">2</span>);\r\n\r\n        <span class=\"hljs-keyword\">if</span> (*(array + middle_index) &lt; key)\r\n            lower_index = (middle_index + <span class=\"hljs-number\">1</span>);\r\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (*(array + middle_index) &gt; key)\r\n            upper_index = (middle_index - <span class=\"hljs-number\">1</span>);\r\n        <span class=\"hljs-keyword\">else</span>\r\n            <span class=\"hljs-built_in\">return</span> (array + middle_index);\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Struzik Search Algorithm(Exponential)\r\n * * Time Complexity O(log i) where i is the position of search key in the list\r\n * * Worst Time Complexity O(log i)\r\n * * Best Time Complexity Ω(1)\r\n * * Space Complexity O(1)\r\n * * Auxiliary Space Complexity O(1)\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Type</span>&gt;\r\n<span class=\"hljs-function\">Type* <span class=\"hljs-title\">struzik_search</span><span class=\"hljs-params\">(Type* array, <span class=\"hljs-type\">size_t</span> size, Type key)</span> </span>{\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">block_front</span><span class=\"hljs-params\">(<span class=\"hljs-number\">0</span>)</span>, block_size </span>= size == <span class=\"hljs-number\">0</span> ? <span class=\"hljs-number\">0</span> : <span class=\"hljs-number\">1</span>;\r\n    <span class=\"hljs-keyword\">while</span> (block_front != block_size) {\r\n        <span class=\"hljs-keyword\">if</span> (*(array + block_size - <span class=\"hljs-number\">1</span>) &lt; key) {\r\n            block_front = block_size;\r\n            (block_size * <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">1</span> &lt; size) ? (block_size *= <span class=\"hljs-number\">2</span>) : block_size = size;\r\n            <span class=\"hljs-keyword\">continue</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">binary_s</span>&lt;Type&gt;(array + block_front, (block_size - block_front),\r\n                              key);\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Main function */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-comment\">// TEST CASES</span>\r\n    <span class=\"hljs-type\">int</span>* sorted_array = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[<span class=\"hljs-number\">7</span>]{<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">23</span>, <span class=\"hljs-number\">70</span>, <span class=\"hljs-number\">105</span>, <span class=\"hljs-number\">203</span>};\r\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-built_in\">struzik_search</span>&lt;<span class=\"hljs-type\">int</span>&gt;(sorted_array, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">0</span>) == <span class=\"hljs-literal\">nullptr</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-built_in\">struzik_search</span>&lt;<span class=\"hljs-type\">int</span>&gt;(sorted_array, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">1000</span>) == <span class=\"hljs-literal\">nullptr</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-built_in\">struzik_search</span>&lt;<span class=\"hljs-type\">int</span>&gt;(sorted_array, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">50</span>) == <span class=\"hljs-literal\">nullptr</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-built_in\">struzik_search</span>&lt;<span class=\"hljs-type\">int</span>&gt;(sorted_array, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">7</span>) == sorted_array);\r\n    <span class=\"hljs-comment\">// TEST CASES</span>\r\n    <span class=\"hljs-keyword\">delete</span>[] sorted_array;\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    },
    "c": {
      "dir": "searching\\exponential_search.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/searching\\exponential_search.c",
      "code": "<span class=\"hljs-comment\">/**\r\n *  \\file\r\n *  \\brief [Exponential Search](https://github.com/TheAlgorithms/Algorithms-Explanation/blob/master/en/Search%20Algorithms/Exponential%20Search.md)\r\n *  \\author [Alessio Farinelli](https://github.com/faridevnz)\r\n */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span>  <span class=\"hljs-comment\">/// for assert</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;inttypes.h&gt;</span>  <span class=\"hljs-comment\">/// for int64_t, uint16_t</span></span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ELEMENT -10</span>\r\n\r\n<span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title function_\">binary_search</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int64_t</span>* arr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint16_t</span> l_index, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint16_t</span> r_index, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int64_t</span> n)</span>; <span class=\"hljs-comment\">///&lt; used to perform the binary search over the given array</span>\r\n<span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title function_\">exponential_search</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int64_t</span>* arr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint16_t</span> length, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int64_t</span> n)</span>; <span class=\"hljs-comment\">///&lt; used to perform the exponential search over the given array</span>\r\n<span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">///&lt; used to run the self-test implementations</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Function: exponential_search\r\n * \\brief algorithm that search the index of the given item\r\n * \\details recursive function that take an array and quickly find the range \r\n * where to apply the binary search algorithm to find the given element\r\n * ----------------------------\r\n * \\param arr array where search the element\r\n * \\param length the total length of the given array (arr)\r\n * \\param n element to find in the array (arr)\r\n * \r\n * \\returns the index of the element (n) in the array (arr)\r\n * \\returns -1 if the element wasn&#x27;t found\r\n */</span>\r\n<span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title function_\">exponential_search</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int64_t</span>* arr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint16_t</span> length, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int64_t</span> n)</span> \r\n{\r\n    <span class=\"hljs-keyword\">if</span> ( length == <span class=\"hljs-number\">0</span> ) { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>; }\r\n    <span class=\"hljs-comment\">// find the upperbound</span>\r\n    <span class=\"hljs-type\">uint32_t</span> upper_bound = <span class=\"hljs-number\">1</span>;\r\n    <span class=\"hljs-keyword\">while</span> ( upper_bound &lt;= length &amp;&amp; arr[upper_bound] &lt; n ) { upper_bound = upper_bound * <span class=\"hljs-number\">2</span>; }\r\n    <span class=\"hljs-comment\">// calculate the range ( between lower_boud and upper_bound )</span>\r\n    <span class=\"hljs-type\">uint16_t</span> lower_bound = upper_bound/<span class=\"hljs-number\">2</span>;\r\n    <span class=\"hljs-keyword\">if</span> ( upper_bound &gt; length ) { upper_bound = length; }\r\n    <span class=\"hljs-comment\">// apply the binary search in the range</span>\r\n    <span class=\"hljs-keyword\">return</span> binary_search(arr, lower_bound, upper_bound, n);\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Function: binary_search\r\n * \\brief algorithm that search the index of the given item\r\n * \\details recursive function that search the given element in\r\n * the array using the [Binary Search](https://github.com/TheAlgorithms/Algorithms-Explanation/blob/master/en/Search%20Algorithms/Binary%20Search.md)\r\n * ----------------------------\r\n * \\param arr array where search the element\r\n * \\param l_index start index of the array (arr) to apply the algorithm\r\n * \\param r_index end index of the array (arr) to apply the algorithm\r\n * \\param n element to find in the array (arr)\r\n *\r\n * \\returns the index of the element (n) in the array (arr)\r\n * \\returns -1 if the n element wasn&#x27;t found\r\n */</span>\r\n<span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title function_\">binary_search</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int64_t</span>* arr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint16_t</span> l_index, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint16_t</span> r_index, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int64_t</span> n)</span> \r\n{\r\n    <span class=\"hljs-comment\">// calculate the middle index of the array</span>\r\n    <span class=\"hljs-type\">uint16_t</span> middle_index = l_index + ( r_index - l_index ) / <span class=\"hljs-number\">2</span>;\r\n    <span class=\"hljs-comment\">// base cases</span>\r\n    <span class=\"hljs-keyword\">if</span> ( l_index &gt; r_index ) { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>; }\r\n    <span class=\"hljs-keyword\">if</span> ( arr[middle_index] == n ) { <span class=\"hljs-keyword\">return</span> middle_index; }\r\n    <span class=\"hljs-comment\">// recursion</span>\r\n    <span class=\"hljs-keyword\">if</span> ( arr[middle_index] &gt; n ) { <span class=\"hljs-keyword\">return</span> binary_search(arr, l_index, middle_index<span class=\"hljs-number\">-1</span>, n); } <span class=\"hljs-comment\">// left</span>\r\n    <span class=\"hljs-keyword\">return</span> binary_search(arr, middle_index+<span class=\"hljs-number\">1</span>, r_index, n); <span class=\"hljs-comment\">// right</span>\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> \r\n{\r\n    test();  <span class=\"hljs-comment\">// run self-test implementations</span>\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Self-test implementations\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">()</span>\r\n{\r\n    <span class=\"hljs-comment\">// empty array</span>\r\n    <span class=\"hljs-type\">int64_t</span> arr_empty[] = {};\r\n    assert(exponential_search(arr_empty, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>) == <span class=\"hljs-number\">-1</span>);\r\n    <span class=\"hljs-comment\">// elent not found</span>\r\n    <span class=\"hljs-type\">int64_t</span> arr_found[] = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>};\r\n    assert(exponential_search(arr_found, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">10</span>) == <span class=\"hljs-number\">-1</span>);\r\n    <span class=\"hljs-comment\">// element found in an array of length 1</span>\r\n    <span class=\"hljs-type\">int64_t</span> arr_one[] = {<span class=\"hljs-number\">1</span>};\r\n    assert(exponential_search(arr_found, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">0</span>);\r\n    <span class=\"hljs-comment\">// find the first element in an array of length 2</span>\r\n    <span class=\"hljs-type\">int64_t</span> arr_first_2[] = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>};\r\n    assert(exponential_search(arr_first_2, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">0</span>);\r\n    <span class=\"hljs-comment\">// find the last element in an array of length 2</span>\r\n    <span class=\"hljs-type\">int64_t</span> arr_last_2[] = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>};\r\n    assert(exponential_search(arr_last_2, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>) == <span class=\"hljs-number\">1</span>);\r\n    <span class=\"hljs-comment\">// find the first element in an array of length n</span>\r\n    <span class=\"hljs-type\">int64_t</span> arr_first_n[] = {<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>};\r\n    assert(exponential_search(arr_first_n, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">-1</span>) == <span class=\"hljs-number\">0</span>);\r\n    <span class=\"hljs-comment\">// find the last element in an array of length n</span>\r\n    <span class=\"hljs-type\">int64_t</span> arr_last_n[] = {<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>};\r\n    assert(exponential_search(arr_last_n, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>) == <span class=\"hljs-number\">4</span>);\r\n    <span class=\"hljs-comment\">// find an element in an array of length n</span>\r\n    <span class=\"hljs-type\">int64_t</span> arr_middle[] = {<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>};\r\n    assert(exponential_search(arr_middle, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>) == <span class=\"hljs-number\">3</span>);\r\n}\r\n"
    },
    "julia": {
      "dir": "src\\searches\\exponential_search.jl",
      "url": "https://github.com/TheAlgorithms/julia/tree/master/src\\searches\\exponential_search.jl",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;\r\n\t exponential_search(arr::AbstractArray{T,1}, x::T) where {T &lt;: Real}\r\n\r\nExponential Search in 1-D array\r\nTime Complexity:  O(Log n)\r\n# Exponential Search\r\nIt works in O(Log n) time\r\nExponential search involves two steps:\r\n- Find range where element is present\r\n- Do Binary Search in above found range.\r\n### Time Complexity :\r\nO(Log n)\r\nApplications of Exponential Search:\r\nExponential Binary Search is particularly useful for unbounded searches, where size of array is infinite. Please refer Unbounded Binary Search for an example.\r\nIt works better than Binary Search for bounded arrays, and also when the element to be searched is closer to the first element.\r\n\r\nContributed By:- [Ash](https://github.com/ashwani-rathee)\r\n&quot;&quot;&quot;</span>\r\n<span class=\"hljs-keyword\">function</span> exponential_search(arr::<span class=\"hljs-built_in\">AbstractArray</span>{T,<span class=\"hljs-number\">1</span>}, x::T) <span class=\"hljs-keyword\">where</span> {T&lt;:<span class=\"hljs-built_in\">Real</span>}\r\n    n = size(arr)[<span class=\"hljs-number\">1</span>]\r\n    <span class=\"hljs-keyword\">if</span> (arr[<span class=\"hljs-number\">1</span>] == x)\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Element present at index 1&quot;</span>\r\n    <span class=\"hljs-keyword\">end</span>\r\n\r\n    i = <span class=\"hljs-number\">1</span>\r\n    <span class=\"hljs-keyword\">while</span> (i &lt; n &amp;&amp; arr[i] &lt;= x)\r\n        i = i * <span class=\"hljs-number\">2</span>\r\n    <span class=\"hljs-keyword\">end</span>\r\n    <span class=\"hljs-keyword\">return</span> binary_search(arr, <span class=\"hljs-built_in\">Int</span>(ceil(i / <span class=\"hljs-number\">2</span>)), min(i, n), x)\r\n<span class=\"hljs-keyword\">end</span>\r\n"
    }
  },
  "contributors": [
    {
      "name": "Alessio Farinelli",
      "email": "alessio.farinelli.developer@gmail.com",
      "commits": 1
    },
    {
      "name": "Azzaare",
      "email": "jf@baffier.fr",
      "commits": 1
    },
    {
      "name": "Ashwani Rathee",
      "email": "ab669522@gmail.com",
      "commits": 1
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Riot",
      "email": "misike1111@gmail.com",
      "commits": 1
    },
    {
      "name": "LefterisD",
      "email": "elefthed@csd.auth.gr",
      "commits": 2
    },
    {
      "name": "Soc Virnyl S. Estela",
      "email": "66054069+uncomfyhalomacro@users.noreply.github.com",
      "commits": 3
    },
    {
      "name": "Eric Lavault",
      "email": "39483232+lvlte@users.noreply.github.com",
      "commits": 3
    },
    {
      "name": "Divide-et-impera-11",
      "email": "54957167+Divide-et-impera-11@users.noreply.github.com",
      "commits": 13
    }
  ],
  "explanationUrl": {
    "es": "https://github.com/TheAlgorithms/Algorithms-Explanation/tree/master/es\\Algoritmos de búsqueda\\Búsqueda exponencial.md",
    "en": "https://github.com/TheAlgorithms/Algorithms-Explanation/tree/master/en\\Search Algorithms\\Exponential Search.md"
  }
}