{
  "slug": "binary-search-tree-2",
  "name": "Binary Search Tree 2",
  "categories": [
    "datastructures"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "data_structures\\binary_search_tree2.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/data_structures\\binary_search_tree2.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @brief A generic [binary search tree](https://en.wikipedia.org/wiki/Binary_search_tree) implementation.\r\n * @see binary_search_tree.cpp\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;functional&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;memory&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief The Binary Search Tree class.\r\n *\r\n * @tparam T The type of the binary search tree key.\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">binary_search_tree</span> {\r\n <span class=\"hljs-keyword\">private</span>:\r\n    <span class=\"hljs-comment\">/**\r\n    * @brief A struct to represent a node in the Binary Search Tree.\r\n    */</span>\r\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">bst_node</span> {\r\n        T value; <span class=\"hljs-comment\">/**&lt; The value/key of the node. */</span>\r\n        std::unique_ptr&lt;bst_node&gt; left; <span class=\"hljs-comment\">/**&lt; Pointer to left subtree. */</span>\r\n        std::unique_ptr&lt;bst_node&gt; right; <span class=\"hljs-comment\">/**&lt; Pointer to right subtree. */</span>\r\n\r\n        <span class=\"hljs-comment\">/**\r\n        * Constructor for bst_node, used to simplify node construction and\r\n        * smart pointer construction.\r\n        * @param _value The value of the constructed node.\r\n        */</span>\r\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">bst_node</span><span class=\"hljs-params\">(T _value)</span> </span>{\r\n            value = _value;\r\n            left = <span class=\"hljs-literal\">nullptr</span>;\r\n            right = <span class=\"hljs-literal\">nullptr</span>;\r\n        }\r\n    };\r\n\r\n    std::unique_ptr&lt;bst_node&gt; root_; <span class=\"hljs-comment\">/**&lt; Pointer to the root of the BST. */</span>\r\n    std::<span class=\"hljs-type\">size_t</span> size_ = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">/**&lt; Number of elements/nodes in the BST. */</span>\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Recursive function to find the maximum value in the BST.\r\n     *\r\n     * @param node The node to search from.\r\n     * @param ret_value Variable to hold the maximum value.\r\n     * @return true If the maximum value was successfully found.\r\n     * @return false Otherwise.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">find_max</span><span class=\"hljs-params\">(std::unique_ptr&lt;bst_node&gt;&amp; node, T&amp; ret_value)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (!node) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!node-&gt;right) {\r\n            ret_value = node-&gt;value;\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">find_max</span>(node-&gt;right, ret_value);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Recursive function to find the minimum value in the BST.\r\n     *\r\n     * @param node The node to search from.\r\n     * @param ret_value Variable to hold the minimum value.\r\n     * @return true If the minimum value was successfully found.\r\n     * @return false Otherwise.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">find_min</span><span class=\"hljs-params\">(std::unique_ptr&lt;bst_node&gt;&amp; node, T&amp; ret_value)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (!node) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!node-&gt;left) {\r\n            ret_value = node-&gt;value;\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">find_min</span>(node-&gt;left, ret_value);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Recursive function to insert a value into the BST.\r\n     *\r\n     * @param node The node to search from.\r\n     * @param new_value The value to insert.\r\n     * @return true If the insert operation was successful.\r\n     * @return false Otherwise.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(std::unique_ptr&lt;bst_node&gt;&amp; node, T new_value)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (root_ == node &amp;&amp; !root_) {\r\n            root_ = std::<span class=\"hljs-built_in\">unique_ptr</span>&lt;bst_node&gt;(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">bst_node</span>(new_value));\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">if</span> (new_value &lt; node-&gt;value) {\r\n            <span class=\"hljs-keyword\">if</span> (!node-&gt;left) {\r\n                node-&gt;left = std::<span class=\"hljs-built_in\">unique_ptr</span>&lt;bst_node&gt;(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">bst_node</span>(new_value));\r\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n            } <span class=\"hljs-keyword\">else</span> {\r\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">insert</span>(node-&gt;left, new_value);\r\n            }\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (new_value &gt; node-&gt;value) {\r\n            <span class=\"hljs-keyword\">if</span> (!node-&gt;right) {\r\n                node-&gt;right =\r\n                    std::<span class=\"hljs-built_in\">unique_ptr</span>&lt;bst_node&gt;(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">bst_node</span>(new_value));\r\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n            } <span class=\"hljs-keyword\">else</span> {\r\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">insert</span>(node-&gt;right, new_value);\r\n            }\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Recursive function to remove a value from the BST.\r\n     *\r\n     * @param parent The parent node of node.\r\n     * @param node The node to search from.\r\n     * @param rm_value The value to remove.\r\n     * @return true If the removal operation was successful.\r\n     * @return false Otherwise.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(std::unique_ptr&lt;bst_node&gt;&amp; parent,\r\n                std::unique_ptr&lt;bst_node&gt;&amp; node, T rm_value)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (!node) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">if</span> (node-&gt;value == rm_value) {\r\n            <span class=\"hljs-keyword\">if</span> (node-&gt;left &amp;&amp; node-&gt;right) {\r\n                T successor_node_value{};\r\n                <span class=\"hljs-built_in\">find_max</span>(node-&gt;left, successor_node_value);\r\n                <span class=\"hljs-built_in\">remove</span>(root_, root_, successor_node_value);\r\n                node-&gt;value = successor_node_value;\r\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node-&gt;left || node-&gt;right) {\r\n                std::unique_ptr&lt;bst_node&gt;&amp; non_null =\r\n                    (node-&gt;left ? node-&gt;left : node-&gt;right);\r\n\r\n                <span class=\"hljs-keyword\">if</span> (node == root_) {\r\n                    root_ = std::<span class=\"hljs-built_in\">move</span>(non_null);\r\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (rm_value &lt; parent-&gt;value) {\r\n                    parent-&gt;left = std::<span class=\"hljs-built_in\">move</span>(non_null);\r\n                } <span class=\"hljs-keyword\">else</span> {\r\n                    parent-&gt;right = std::<span class=\"hljs-built_in\">move</span>(non_null);\r\n                }\r\n\r\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n            } <span class=\"hljs-keyword\">else</span> {\r\n                <span class=\"hljs-keyword\">if</span> (node == root_) {\r\n                    root_.<span class=\"hljs-built_in\">reset</span>(<span class=\"hljs-literal\">nullptr</span>);\r\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (rm_value &lt; parent-&gt;value) {\r\n                    parent-&gt;left.<span class=\"hljs-built_in\">reset</span>(<span class=\"hljs-literal\">nullptr</span>);\r\n                } <span class=\"hljs-keyword\">else</span> {\r\n                    parent-&gt;right.<span class=\"hljs-built_in\">reset</span>(<span class=\"hljs-literal\">nullptr</span>);\r\n                }\r\n\r\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n            }\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (rm_value &lt; node-&gt;value) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">remove</span>(node, node-&gt;left, rm_value);\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">remove</span>(node, node-&gt;right, rm_value);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Recursive function to check if a value is in the BST.\r\n     *\r\n     * @param node The node to search from.\r\n     * @param value The value to find.\r\n     * @return true If the value was found in the BST.\r\n     * @return false Otherwise.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">contains</span><span class=\"hljs-params\">(std::unique_ptr&lt;bst_node&gt;&amp; node, T value)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (!node) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">if</span> (value &lt; node-&gt;value) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">contains</span>(node-&gt;left, value);\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (value &gt; node-&gt;value) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">contains</span>(node-&gt;right, value);\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Recursive function to traverse the tree in in-order order.\r\n     *\r\n     * @param callback Function that is called when a value needs to processed.\r\n     * @param node The node to traverse from.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">traverse_inorder</span><span class=\"hljs-params\">(std::function&lt;<span class=\"hljs-type\">void</span>(T)&gt; callback,\r\n                          std::unique_ptr&lt;bst_node&gt;&amp; node)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (!node) {\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n\r\n        <span class=\"hljs-built_in\">traverse_inorder</span>(callback, node-&gt;left);\r\n        <span class=\"hljs-built_in\">callback</span>(node-&gt;value);\r\n        <span class=\"hljs-built_in\">traverse_inorder</span>(callback, node-&gt;right);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Recursive function to traverse the tree in pre-order order.\r\n     *\r\n     * @param callback Function that is called when a value needs to processed.\r\n     * @param node The node to traverse from.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">traverse_preorder</span><span class=\"hljs-params\">(std::function&lt;<span class=\"hljs-type\">void</span>(T)&gt; callback,\r\n                           std::unique_ptr&lt;bst_node&gt;&amp; node)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (!node) {\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n\r\n        <span class=\"hljs-built_in\">callback</span>(node-&gt;value);\r\n        <span class=\"hljs-built_in\">traverse_preorder</span>(callback, node-&gt;left);\r\n        <span class=\"hljs-built_in\">traverse_preorder</span>(callback, node-&gt;right);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Recursive function to traverse the tree in post-order order.\r\n     *\r\n     * @param callback Function that is called when a value needs to processed.\r\n     * @param node The node to traverse from.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">traverse_postorder</span><span class=\"hljs-params\">(std::function&lt;<span class=\"hljs-type\">void</span>(T)&gt; callback,\r\n                            std::unique_ptr&lt;bst_node&gt;&amp; node)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (!node) {\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n\r\n        <span class=\"hljs-built_in\">traverse_postorder</span>(callback, node-&gt;left);\r\n        <span class=\"hljs-built_in\">traverse_postorder</span>(callback, node-&gt;right);\r\n        <span class=\"hljs-built_in\">callback</span>(node-&gt;value);\r\n    }\r\n\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Construct a new Binary Search Tree object.\r\n     *\r\n     */</span>\r\n    <span class=\"hljs-built_in\">binary_search_tree</span>() {\r\n        root_ = <span class=\"hljs-literal\">nullptr</span>;\r\n        size_ = <span class=\"hljs-number\">0</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Insert a new value into the BST.\r\n     *\r\n     * @param new_value The value to insert into the BST.\r\n     * @return true If the insertion was successful.\r\n     * @return false Otherwise.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(T new_value)</span> </span>{\r\n        <span class=\"hljs-type\">bool</span> result = <span class=\"hljs-built_in\">insert</span>(root_, new_value);\r\n        <span class=\"hljs-keyword\">if</span> (result) {\r\n            size_++;\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> result;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Remove a specified value from the BST.\r\n     *\r\n     * @param rm_value The value to remove.\r\n     * @return true If the removal was successful.\r\n     * @return false Otherwise.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(T rm_value)</span> </span>{\r\n        <span class=\"hljs-type\">bool</span> result = <span class=\"hljs-built_in\">remove</span>(root_, root_, rm_value);\r\n        <span class=\"hljs-keyword\">if</span> (result) {\r\n            size_--;\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> result;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Check if a value is in the BST.\r\n     *\r\n     * @param value The value to find.\r\n     * @return true If value is in the BST.\r\n     * @return false Otherwise.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">contains</span><span class=\"hljs-params\">(T value)</span> </span>{ <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">contains</span>(root_, value); }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Find the smallest value in the BST.\r\n     *\r\n     * @param ret_value Variable to hold the minimum value.\r\n     * @return true If minimum value was successfully found.\r\n     * @return false Otherwise.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">find_min</span><span class=\"hljs-params\">(T&amp; ret_value)</span> </span>{ <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">find_min</span>(root_, ret_value); }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Find the largest value in the BST.\r\n     *\r\n     * @param ret_value Variable to hold the maximum value.\r\n     * @return true If maximum value was successfully found.\r\n     * @return false Otherwise.\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">find_max</span><span class=\"hljs-params\">(T&amp; ret_value)</span> </span>{ <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">find_max</span>(root_, ret_value); }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Get the number of values in the BST.\r\n     *\r\n     * @return std::size_t Number of values in the BST.\r\n     */</span>\r\n    <span class=\"hljs-function\">std::<span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> size_; }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Get all values of the BST in in-order order.\r\n     *\r\n     * @return std::vector&lt;T&gt; List of values, sorted in in-order order.\r\n     */</span>\r\n    <span class=\"hljs-function\">std::vector&lt;T&gt; <span class=\"hljs-title\">get_elements_inorder</span><span class=\"hljs-params\">()</span> </span>{\r\n        std::vector&lt;T&gt; result;\r\n        <span class=\"hljs-built_in\">traverse_inorder</span>([&amp;](T node_value) { result.<span class=\"hljs-built_in\">push_back</span>(node_value); },\r\n                         root_);\r\n        <span class=\"hljs-keyword\">return</span> result;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Get all values of the BST in pre-order order.\r\n     *\r\n     * @return std::vector&lt;T&gt; List of values, sorted in pre-order order.\r\n     */</span>\r\n    <span class=\"hljs-function\">std::vector&lt;T&gt; <span class=\"hljs-title\">get_elements_preorder</span><span class=\"hljs-params\">()</span> </span>{\r\n        std::vector&lt;T&gt; result;\r\n        <span class=\"hljs-built_in\">traverse_preorder</span>([&amp;](T node_value) { result.<span class=\"hljs-built_in\">push_back</span>(node_value); },\r\n                          root_);\r\n        <span class=\"hljs-keyword\">return</span> result;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Get all values of the BST in post-order order.\r\n     *\r\n     * @return std::vector&lt;T&gt; List of values, sorted in post-order order.\r\n     */</span>\r\n    <span class=\"hljs-function\">std::vector&lt;T&gt; <span class=\"hljs-title\">get_elements_postorder</span><span class=\"hljs-params\">()</span> </span>{\r\n        std::vector&lt;T&gt; result;\r\n        <span class=\"hljs-built_in\">traverse_postorder</span>([&amp;](T node_value) { result.<span class=\"hljs-built_in\">push_back</span>(node_value); },\r\n                           root_);\r\n        <span class=\"hljs-keyword\">return</span> result;\r\n    }\r\n};\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function for testing insert().\r\n * \r\n * @returns `void`\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_insert</span><span class=\"hljs-params\">()</span> </span>{\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testing BST insert...&quot;</span>;\r\n\r\n    binary_search_tree&lt;<span class=\"hljs-type\">int</span>&gt; tree;\r\n    <span class=\"hljs-type\">bool</span> res = tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>);\r\n    <span class=\"hljs-type\">int</span> min = <span class=\"hljs-number\">-1</span>, max = <span class=\"hljs-number\">-1</span>;\r\n    <span class=\"hljs-built_in\">assert</span>(res);\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">find_max</span>(max));\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">find_min</span>(min));\r\n    <span class=\"hljs-built_in\">assert</span>(max == <span class=\"hljs-number\">5</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(min == <span class=\"hljs-number\">5</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">1</span>);\r\n\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">6</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">find_max</span>(max));\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">find_min</span>(min));\r\n    <span class=\"hljs-built_in\">assert</span>(max == <span class=\"hljs-number\">6</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(min == <span class=\"hljs-number\">3</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">4</span>);\r\n\r\n    <span class=\"hljs-type\">bool</span> fail_res = tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(!fail_res);\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">4</span>);\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; std::endl;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function for testing remove().\r\n * \r\n * @returns `void`\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_remove</span><span class=\"hljs-params\">()</span> </span>{\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testing BST remove...&quot;</span>;\r\n\r\n    binary_search_tree&lt;<span class=\"hljs-type\">int</span>&gt; tree;\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">6</span>);\r\n\r\n    <span class=\"hljs-type\">bool</span> res = tree.<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-number\">5</span>);\r\n    <span class=\"hljs-type\">int</span> min = <span class=\"hljs-number\">-1</span>, max = <span class=\"hljs-number\">-1</span>;\r\n    <span class=\"hljs-built_in\">assert</span>(res);\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">find_max</span>(max));\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">find_min</span>(min));\r\n    <span class=\"hljs-built_in\">assert</span>(max == <span class=\"hljs-number\">6</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(min == <span class=\"hljs-number\">3</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">3</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">contains</span>(<span class=\"hljs-number\">5</span>) == <span class=\"hljs-literal\">false</span>);\r\n\r\n    tree.<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-number\">4</span>);\r\n    tree.<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-number\">3</span>);\r\n    tree.<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-number\">6</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">contains</span>(<span class=\"hljs-number\">6</span>) == <span class=\"hljs-literal\">false</span>);\r\n\r\n    <span class=\"hljs-type\">bool</span> fail_res = tree.<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-number\">5</span>);\r\n    <span class=\"hljs-built_in\">assert</span>(!fail_res);\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>);\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; std::endl;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function for testing contains().\r\n * \r\n * @returns `void`\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_contains</span><span class=\"hljs-params\">()</span> </span>{\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testing BST contains...&quot;</span>;\r\n\r\n    binary_search_tree&lt;<span class=\"hljs-type\">int</span>&gt; tree;\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">6</span>);\r\n\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">contains</span>(<span class=\"hljs-number\">5</span>));\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">contains</span>(<span class=\"hljs-number\">4</span>));\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">contains</span>(<span class=\"hljs-number\">3</span>));\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">contains</span>(<span class=\"hljs-number\">6</span>));\r\n    <span class=\"hljs-built_in\">assert</span>(!tree.<span class=\"hljs-built_in\">contains</span>(<span class=\"hljs-number\">999</span>));\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; std::endl;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function for testing find_min().\r\n * \r\n * @returns `void`\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_find_min</span><span class=\"hljs-params\">()</span> </span>{\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testing BST find_min...&quot;</span>;\r\n\r\n    <span class=\"hljs-type\">int</span> min = <span class=\"hljs-number\">0</span>;\r\n    binary_search_tree&lt;<span class=\"hljs-type\">int</span>&gt; tree;\r\n    <span class=\"hljs-built_in\">assert</span>(!tree.<span class=\"hljs-built_in\">find_min</span>(min));\r\n\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">6</span>);\r\n\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">find_min</span>(min));\r\n    <span class=\"hljs-built_in\">assert</span>(min == <span class=\"hljs-number\">3</span>);\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; std::endl;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function for testing find_max().\r\n * \r\n * @returns `void`\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_find_max</span><span class=\"hljs-params\">()</span> </span>{\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testing BST find_max...&quot;</span>;\r\n\r\n    <span class=\"hljs-type\">int</span> max = <span class=\"hljs-number\">0</span>;\r\n    binary_search_tree&lt;<span class=\"hljs-type\">int</span>&gt; tree;\r\n    <span class=\"hljs-built_in\">assert</span>(!tree.<span class=\"hljs-built_in\">find_max</span>(max));\r\n\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">6</span>);\r\n\r\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">find_max</span>(max));\r\n    <span class=\"hljs-built_in\">assert</span>(max == <span class=\"hljs-number\">6</span>);\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; std::endl;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function for testing get_elements_inorder().\r\n * \r\n * @returns `void`\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_get_elements_inorder</span><span class=\"hljs-params\">()</span> </span>{\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testing BST get_elements_inorder...&quot;</span>;\r\n\r\n    binary_search_tree&lt;<span class=\"hljs-type\">int</span>&gt; tree;\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">6</span>);\r\n\r\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; expected = {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>};\r\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; actual = tree.<span class=\"hljs-built_in\">get_elements_inorder</span>();\r\n    <span class=\"hljs-built_in\">assert</span>(actual == expected);\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; std::endl;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function for testing get_elements_preorder().\r\n * \r\n * @returns `void`\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_get_elements_preorder</span><span class=\"hljs-params\">()</span> </span>{\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testing BST get_elements_preorder...&quot;</span>;\r\n\r\n    binary_search_tree&lt;<span class=\"hljs-type\">int</span>&gt; tree;\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">6</span>);\r\n\r\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; expected = {<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>};\r\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; actual = tree.<span class=\"hljs-built_in\">get_elements_preorder</span>();\r\n    <span class=\"hljs-built_in\">assert</span>(actual == expected);\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; std::endl;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function for testing get_elements_postorder().\r\n * \r\n * @returns `void`\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_get_elements_postorder</span><span class=\"hljs-params\">()</span> </span>{\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testing BST get_elements_postorder...&quot;</span>;\r\n\r\n    binary_search_tree&lt;<span class=\"hljs-type\">int</span>&gt; tree;\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>);\r\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">6</span>);\r\n\r\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; expected = {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">5</span>};\r\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; actual = tree.<span class=\"hljs-built_in\">get_elements_postorder</span>();\r\n    <span class=\"hljs-built_in\">assert</span>(actual == expected);\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; std::endl;\r\n}\r\n\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-built_in\">test_insert</span>();\r\n    <span class=\"hljs-built_in\">test_remove</span>();\r\n    <span class=\"hljs-built_in\">test_contains</span>();\r\n    <span class=\"hljs-built_in\">test_find_max</span>();\r\n    <span class=\"hljs-built_in\">test_find_min</span>();\r\n    <span class=\"hljs-built_in\">test_get_elements_inorder</span>();\r\n    <span class=\"hljs-built_in\">test_get_elements_preorder</span>();\r\n    <span class=\"hljs-built_in\">test_get_elements_postorder</span>();\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Walt",
      "email": "32001362+Walt280@users.noreply.github.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}