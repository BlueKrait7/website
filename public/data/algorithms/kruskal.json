{
  "slug": "kruskal",
  "name": "Kruskal",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "graph\\kruskal.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph\\kruskal.cpp",
      "code": "<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;array&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\r\n<span class=\"hljs-comment\">//#include &lt;boost/multiprecision/cpp_int.hpp&gt;</span>\r\n<span class=\"hljs-comment\">// using namespace boost::multiprecision;</span>\r\n<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> mx = <span class=\"hljs-number\">1e6</span> + <span class=\"hljs-number\">5</span>;\r\n<span class=\"hljs-keyword\">using</span> ll = <span class=\"hljs-type\">int64_t</span>;\r\n\r\nstd::array&lt;ll, mx&gt; parent;\r\nll node, edge;\r\nstd::vector&lt;std::pair&lt;ll, std::pair&lt;ll, ll&gt;&gt;&gt; edges;\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">initial</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; node + edge; ++i) {\r\n        parent[i] = i;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">root</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> </span>{\r\n    <span class=\"hljs-keyword\">while</span> (parent[i] != i) {\r\n        parent[i] = parent[parent[i]];\r\n        i = parent[i];\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> i;\r\n}\r\n\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">join</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y)</span> </span>{\r\n    <span class=\"hljs-type\">int</span> root_x = <span class=\"hljs-built_in\">root</span>(x);  <span class=\"hljs-comment\">// Disjoint set union by rank</span>\r\n    <span class=\"hljs-type\">int</span> root_y = <span class=\"hljs-built_in\">root</span>(y);\r\n    parent[root_x] = root_y;\r\n}\r\n\r\n<span class=\"hljs-function\">ll <span class=\"hljs-title\">kruskal</span><span class=\"hljs-params\">()</span> </span>{\r\n    ll mincost = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; edge; ++i) {\r\n        ll x = edges[i].second.first;\r\n        ll y = edges[i].second.second;\r\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">root</span>(x) != <span class=\"hljs-built_in\">root</span>(y)) {\r\n            mincost += edges[i].first;\r\n            <span class=\"hljs-built_in\">join</span>(x, y);\r\n        }\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> mincost;\r\n}\r\n\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\r\n        <span class=\"hljs-type\">int</span> from = <span class=\"hljs-number\">0</span>, to = <span class=\"hljs-number\">0</span>, cost = <span class=\"hljs-number\">0</span>, totalcost = <span class=\"hljs-number\">0</span>;\r\n        std::cin &gt;&gt; node &gt;&gt; edge;  <span class=\"hljs-comment\">// Enter the nodes and edges</span>\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-number\">0</span> &amp;&amp; edge == <span class=\"hljs-number\">0</span>) {\r\n            <span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">// Enter 0 0 to break out</span>\r\n        }\r\n        <span class=\"hljs-built_in\">initial</span>();  <span class=\"hljs-comment\">// Initialise the parent array</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; edge; ++i) {\r\n            std::cin &gt;&gt; from &gt;&gt; to &gt;&gt; cost;\r\n            edges.<span class=\"hljs-built_in\">emplace_back</span>(<span class=\"hljs-built_in\">make_pair</span>(cost, std::<span class=\"hljs-built_in\">make_pair</span>(from, to)));\r\n            totalcost += cost;\r\n        }\r\n        <span class=\"hljs-built_in\">sort</span>(edges.<span class=\"hljs-built_in\">begin</span>(), edges.<span class=\"hljs-built_in\">end</span>());\r\n        std::cout &lt;&lt; <span class=\"hljs-built_in\">kruskal</span>() &lt;&lt; std::endl;\r\n        edges.<span class=\"hljs-built_in\">clear</span>();\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    },
    "java": {
      "dir": "src\\main\\java\\com\\thealgorithms\\datastructures\\graphs\\Kruskal.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src\\main\\java\\com\\thealgorithms\\datastructures\\graphs\\Kruskal.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.datastructures.graphs;\r\n\r\n<span class=\"hljs-comment\">// Problem -&gt; Connect all the edges with the minimum cost.</span>\r\n<span class=\"hljs-comment\">// Possible Solution -&gt; Kruskal Algorithm (KA), KA finds the minimum-spanning-tree, which means, the</span>\r\n<span class=\"hljs-comment\">// group of edges with the minimum sum of their weights that connect the whole graph.</span>\r\n<span class=\"hljs-comment\">// The graph needs to be connected, because if there are nodes impossible to reach, there are no</span>\r\n<span class=\"hljs-comment\">// edges that could connect every node in the graph.</span>\r\n<span class=\"hljs-comment\">// KA is a Greedy Algorithm, because edges are analysed based on their weights, that is why a</span>\r\n<span class=\"hljs-comment\">// Priority Queue is used, to take first those less weighted.</span>\r\n<span class=\"hljs-comment\">// This implementations below has some changes compared to conventional ones, but they are explained</span>\r\n<span class=\"hljs-comment\">// all along the code.</span>\r\n<span class=\"hljs-keyword\">import</span> java.util.Comparator;\r\n<span class=\"hljs-keyword\">import</span> java.util.HashSet;\r\n<span class=\"hljs-keyword\">import</span> java.util.PriorityQueue;\r\n\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Kruskal</span> {\r\n\r\n    <span class=\"hljs-comment\">// Complexity: O(E log V) time, where E is the number of edges in the graph and V is the number of</span>\r\n    <span class=\"hljs-comment\">// vertices</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Edge</span> {\r\n\r\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> from;\r\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> to;\r\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> weight;\r\n\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Edge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> from, <span class=\"hljs-type\">int</span> to, <span class=\"hljs-type\">int</span> weight)</span> {\r\n            <span class=\"hljs-built_in\">this</span>.from = from;\r\n            <span class=\"hljs-built_in\">this</span>.to = to;\r\n            <span class=\"hljs-built_in\">this</span>.weight = weight;\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">addEdge</span><span class=\"hljs-params\">(HashSet&lt;Edge&gt;[] graph, <span class=\"hljs-type\">int</span> from, <span class=\"hljs-type\">int</span> to, <span class=\"hljs-type\">int</span> weight)</span> {\r\n        graph[from].add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Edge</span>(from, to, weight));\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\r\n        HashSet&lt;Edge&gt;[] graph = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>[<span class=\"hljs-number\">7</span>];\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; graph.length; i++) {\r\n            graph[i] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>&lt;&gt;();\r\n        }\r\n        addEdge(graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\r\n        addEdge(graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\r\n        addEdge(graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>);\r\n        addEdge(graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>);\r\n        addEdge(graph, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>);\r\n        addEdge(graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>);\r\n        addEdge(graph, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>);\r\n        addEdge(graph, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>);\r\n        addEdge(graph, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>);\r\n        addEdge(graph, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">9</span>);\r\n\r\n        System.out.println(<span class=\"hljs-string\">&quot;Initial Graph: &quot;</span>);\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; graph.length; i++) {\r\n            <span class=\"hljs-keyword\">for</span> (Edge edge : graph[i]) {\r\n                System.out.println(i + <span class=\"hljs-string\">&quot; &lt;-- weight &quot;</span> + edge.weight + <span class=\"hljs-string\">&quot; --&gt; &quot;</span> + edge.to);\r\n            }\r\n        }\r\n\r\n        <span class=\"hljs-type\">Kruskal</span> <span class=\"hljs-variable\">k</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Kruskal</span>();\r\n        HashSet&lt;Edge&gt;[] solGraph = k.kruskal(graph);\r\n\r\n        System.out.println(<span class=\"hljs-string\">&quot;\\nMinimal Graph: &quot;</span>);\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; solGraph.length; i++) {\r\n            <span class=\"hljs-keyword\">for</span> (Edge edge : solGraph[i]) {\r\n                System.out.println(i + <span class=\"hljs-string\">&quot; &lt;-- weight &quot;</span> + edge.weight + <span class=\"hljs-string\">&quot; --&gt; &quot;</span> + edge.to);\r\n            }\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">public</span> HashSet&lt;Edge&gt;[] kruskal(HashSet&lt;Edge&gt;[] graph) {\r\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">nodes</span> <span class=\"hljs-operator\">=</span> graph.length;\r\n        <span class=\"hljs-type\">int</span>[] captain = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[nodes];\r\n        <span class=\"hljs-comment\">// captain of i, stores the set with all the connected nodes to i</span>\r\n        HashSet&lt;Integer&gt;[] connectedGroups = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>[nodes];\r\n        HashSet&lt;Edge&gt;[] minGraph = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>[nodes];\r\n        PriorityQueue&lt;Edge&gt; edges = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PriorityQueue</span>&lt;&gt;((Comparator.comparingInt(edge -&gt; edge.weight)));\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; nodes; i++) {\r\n            minGraph[i] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>&lt;&gt;();\r\n            connectedGroups[i] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>&lt;&gt;();\r\n            connectedGroups[i].add(i);\r\n            captain[i] = i;\r\n            edges.addAll(graph[i]);\r\n        }\r\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">connectedElements</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\r\n        <span class=\"hljs-comment\">// as soon as two sets merge all the elements, the algorithm must stop</span>\r\n        <span class=\"hljs-keyword\">while</span> (connectedElements != nodes &amp;&amp; !edges.isEmpty()) {\r\n            <span class=\"hljs-type\">Edge</span> <span class=\"hljs-variable\">edge</span> <span class=\"hljs-operator\">=</span> edges.poll();\r\n            <span class=\"hljs-comment\">// This if avoids cycles</span>\r\n            <span class=\"hljs-keyword\">if</span> (!connectedGroups[captain[edge.from]].contains(edge.to)\r\n                    &amp;&amp; !connectedGroups[captain[edge.to]].contains(edge.from)) {\r\n                <span class=\"hljs-comment\">// merge sets of the captains of each point connected by the edge</span>\r\n                connectedGroups[captain[edge.from]].addAll(connectedGroups[captain[edge.to]]);\r\n                <span class=\"hljs-comment\">// update captains of the elements merged</span>\r\n                connectedGroups[captain[edge.from]].forEach(i -&gt; captain[i] = captain[edge.from]);\r\n                <span class=\"hljs-comment\">// add Edge to minimal graph</span>\r\n                addEdge(minGraph, edge.from, edge.to, edge.weight);\r\n                <span class=\"hljs-comment\">// count how many elements have been merged</span>\r\n                connectedElements = connectedGroups[captain[edge.from]].size();\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> minGraph;\r\n    }\r\n}\r\n"
    },
    "c": {
      "dir": "data_structures\\graphs\\kruskal.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/data_structures\\graphs\\kruskal.c",
      "code": "<span class=\"hljs-comment\">// C program for Kruskal&#x27;s algorithm to find Minimum Spanning Tree</span>\r\n<span class=\"hljs-comment\">// of a given connected, undirected and weighted graph</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span></span>\r\n\r\n<span class=\"hljs-comment\">// a structure to represent a weighted edge in graph</span>\r\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span>\r\n{</span>\r\n    <span class=\"hljs-type\">int</span> src, dest, weight;\r\n};\r\n\r\n<span class=\"hljs-comment\">// a structure to represent a connected, undirected</span>\r\n<span class=\"hljs-comment\">// and weighted graph</span>\r\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Graph</span>\r\n{</span>\r\n    <span class=\"hljs-comment\">// V-&gt; Number of vertices, E-&gt; Number of edges</span>\r\n    <span class=\"hljs-type\">int</span> V, E;\r\n\r\n    <span class=\"hljs-comment\">// graph is represented as an array of edges.</span>\r\n    <span class=\"hljs-comment\">// Since the graph is undirected, the edge</span>\r\n    <span class=\"hljs-comment\">// from src to dest is also edge from dest</span>\r\n    <span class=\"hljs-comment\">// to src. Both are counted as 1 edge here.</span>\r\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span> *<span class=\"hljs-title\">edge</span>;</span>\r\n};\r\n\r\n<span class=\"hljs-comment\">// Creates a graph with V vertices and E edges</span>\r\n<span class=\"hljs-keyword\">struct</span> Graph *<span class=\"hljs-title function_\">createGraph</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> V, <span class=\"hljs-type\">int</span> E)</span>\r\n{\r\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Graph</span> *<span class=\"hljs-title\">graph</span> =</span> new Graph();\r\n    graph-&gt;V = V;\r\n    graph-&gt;E = E;\r\n\r\n    graph-&gt;edge = new Edge[E];\r\n\r\n    <span class=\"hljs-keyword\">return</span> graph;\r\n}\r\n\r\n<span class=\"hljs-comment\">// A structure to represent a subset for union-find</span>\r\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">subset</span>\r\n{</span>\r\n    <span class=\"hljs-type\">int</span> parent;\r\n    <span class=\"hljs-type\">int</span> rank;\r\n};\r\n\r\n<span class=\"hljs-comment\">// A utility function to find set of an element i</span>\r\n<span class=\"hljs-comment\">// (uses path compression technique)</span>\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">find</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> subset subsets[], <span class=\"hljs-type\">int</span> i)</span>\r\n{\r\n    <span class=\"hljs-comment\">// find root and make root as parent of i</span>\r\n    <span class=\"hljs-comment\">// (path compression)</span>\r\n    <span class=\"hljs-keyword\">if</span> (subsets[i].parent != i)\r\n        subsets[i].parent = find(subsets, subsets[i].parent);\r\n\r\n    <span class=\"hljs-keyword\">return</span> subsets[i].parent;\r\n}\r\n\r\n<span class=\"hljs-comment\">// A function that does union of two sets of x and y</span>\r\n<span class=\"hljs-comment\">// (uses union by rank)</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">Union</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> subset subsets[], <span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y)</span>\r\n{\r\n    <span class=\"hljs-type\">int</span> xroot = find(subsets, x);\r\n    <span class=\"hljs-type\">int</span> yroot = find(subsets, y);\r\n\r\n    <span class=\"hljs-comment\">// Attach smaller rank tree under root of high</span>\r\n    <span class=\"hljs-comment\">// rank tree (Union by Rank)</span>\r\n    <span class=\"hljs-keyword\">if</span> (subsets[xroot].rank &lt; subsets[yroot].rank)\r\n        subsets[xroot].parent = yroot;\r\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (subsets[xroot].rank &gt; subsets[yroot].rank)\r\n        subsets[yroot].parent = xroot;\r\n\r\n    <span class=\"hljs-comment\">// If ranks are same, then make one as root and</span>\r\n    <span class=\"hljs-comment\">// increment its rank by one</span>\r\n    <span class=\"hljs-keyword\">else</span>\r\n    {\r\n        subsets[yroot].parent = xroot;\r\n        subsets[xroot].rank++;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">// Compare two edges according to their weights.</span>\r\n<span class=\"hljs-comment\">// Used in qsort() for sorting an array of edges</span>\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">myComp</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span> *a, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span> *b)</span>\r\n{\r\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span> *<span class=\"hljs-title\">a1</span> =</span> (<span class=\"hljs-keyword\">struct</span> Edge *)a;\r\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span> *<span class=\"hljs-title\">b1</span> =</span> (<span class=\"hljs-keyword\">struct</span> Edge *)b;\r\n    <span class=\"hljs-keyword\">return</span> a1-&gt;weight &gt; b1-&gt;weight;\r\n}\r\n\r\n<span class=\"hljs-comment\">// The main function to construct MST using Kruskal&#x27;s algorithm</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">KruskalMST</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Graph *graph)</span>\r\n{\r\n    <span class=\"hljs-type\">int</span> V = graph-&gt;V;\r\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span> <span class=\"hljs-title\">result</span>[<span class=\"hljs-title\">V</span>];</span>  <span class=\"hljs-comment\">// Tnis will store the resultant MST</span>\r\n    <span class=\"hljs-type\">int</span> e = <span class=\"hljs-number\">0</span>;              <span class=\"hljs-comment\">// An index variable, used for result[]</span>\r\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;              <span class=\"hljs-comment\">// An index variable, used for sorted edges</span>\r\n\r\n    <span class=\"hljs-comment\">// Step 1: Sort all the edges in non-decreasing</span>\r\n    <span class=\"hljs-comment\">// order of their weight. If we are not allowed to</span>\r\n    <span class=\"hljs-comment\">// change the given graph, we can create a copy of</span>\r\n    <span class=\"hljs-comment\">// array of edges</span>\r\n    qsort(graph-&gt;edge, graph-&gt;E, <span class=\"hljs-keyword\">sizeof</span>(graph-&gt;edge[<span class=\"hljs-number\">0</span>]), myComp);\r\n\r\n    <span class=\"hljs-comment\">// Allocate memory for creating V ssubsets</span>\r\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">subset</span> *<span class=\"hljs-title\">subsets</span> =</span> (<span class=\"hljs-keyword\">struct</span> subset *)<span class=\"hljs-built_in\">malloc</span>(V * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> subset));\r\n\r\n    <span class=\"hljs-comment\">// Create V subsets with single elements</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v = <span class=\"hljs-number\">0</span>; v &lt; V; ++v)\r\n    {\r\n        subsets[v].parent = v;\r\n        subsets[v].rank = <span class=\"hljs-number\">0</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// Number of edges to be taken is equal to V-1</span>\r\n    <span class=\"hljs-keyword\">while</span> (e &lt; V - <span class=\"hljs-number\">1</span> &amp;&amp; i &lt; graph-&gt;E)\r\n    {\r\n        <span class=\"hljs-comment\">// Step 2: Pick the smallest edge. And increment</span>\r\n        <span class=\"hljs-comment\">// the index for next iteration</span>\r\n        <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span> <span class=\"hljs-title\">next_edge</span> =</span> graph-&gt;edge[i++];\r\n\r\n        <span class=\"hljs-type\">int</span> x = find(subsets, next_edge.src);\r\n        <span class=\"hljs-type\">int</span> y = find(subsets, next_edge.dest);\r\n\r\n        <span class=\"hljs-comment\">// If including this edge does&#x27;t cause cycle,</span>\r\n        <span class=\"hljs-comment\">// include it in result and increment the index</span>\r\n        <span class=\"hljs-comment\">// of result for next edge</span>\r\n        <span class=\"hljs-keyword\">if</span> (x != y)\r\n        {\r\n            result[e++] = next_edge;\r\n            Union(subsets, x, y);\r\n        }\r\n        <span class=\"hljs-comment\">// Else discard the next_edge</span>\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// print the contents of result[] to display the</span>\r\n    <span class=\"hljs-comment\">// built MST</span>\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Following are the edges in the constructed MST\\n&quot;</span>);\r\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; e; ++i)\r\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d -- %d == %d\\n&quot;</span>, result[i].src, result[i].dest,\r\n               result[i].weight);\r\n    <span class=\"hljs-keyword\">return</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">// Driver program to test above functions</span>\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>\r\n{\r\n    <span class=\"hljs-comment\">/* Let us create following weighted graph\r\n            10\r\n        0--------1\r\n        | \\\t |\r\n    6| 5\\ |15\r\n        |\t \\ |\r\n        2--------3\r\n            4\t */</span>\r\n    <span class=\"hljs-type\">int</span> V = <span class=\"hljs-number\">4</span>;  <span class=\"hljs-comment\">// Number of vertices in graph</span>\r\n    <span class=\"hljs-type\">int</span> E = <span class=\"hljs-number\">5</span>;  <span class=\"hljs-comment\">// Number of edges in graph</span>\r\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Graph</span> *<span class=\"hljs-title\">graph</span> =</span> createGraph(V, E);\r\n\r\n    <span class=\"hljs-comment\">// add edge 0-1</span>\r\n    graph-&gt;edge[<span class=\"hljs-number\">0</span>].src = <span class=\"hljs-number\">0</span>;\r\n    graph-&gt;edge[<span class=\"hljs-number\">0</span>].dest = <span class=\"hljs-number\">1</span>;\r\n    graph-&gt;edge[<span class=\"hljs-number\">0</span>].weight = <span class=\"hljs-number\">10</span>;\r\n\r\n    <span class=\"hljs-comment\">// add edge 0-2</span>\r\n    graph-&gt;edge[<span class=\"hljs-number\">1</span>].src = <span class=\"hljs-number\">0</span>;\r\n    graph-&gt;edge[<span class=\"hljs-number\">1</span>].dest = <span class=\"hljs-number\">2</span>;\r\n    graph-&gt;edge[<span class=\"hljs-number\">1</span>].weight = <span class=\"hljs-number\">6</span>;\r\n\r\n    <span class=\"hljs-comment\">// add edge 0-3</span>\r\n    graph-&gt;edge[<span class=\"hljs-number\">2</span>].src = <span class=\"hljs-number\">0</span>;\r\n    graph-&gt;edge[<span class=\"hljs-number\">2</span>].dest = <span class=\"hljs-number\">3</span>;\r\n    graph-&gt;edge[<span class=\"hljs-number\">2</span>].weight = <span class=\"hljs-number\">5</span>;\r\n\r\n    <span class=\"hljs-comment\">// add edge 1-3</span>\r\n    graph-&gt;edge[<span class=\"hljs-number\">3</span>].src = <span class=\"hljs-number\">1</span>;\r\n    graph-&gt;edge[<span class=\"hljs-number\">3</span>].dest = <span class=\"hljs-number\">3</span>;\r\n    graph-&gt;edge[<span class=\"hljs-number\">3</span>].weight = <span class=\"hljs-number\">15</span>;\r\n\r\n    <span class=\"hljs-comment\">// add edge 2-3</span>\r\n    graph-&gt;edge[<span class=\"hljs-number\">4</span>].src = <span class=\"hljs-number\">2</span>;\r\n    graph-&gt;edge[<span class=\"hljs-number\">4</span>].dest = <span class=\"hljs-number\">3</span>;\r\n    graph-&gt;edge[<span class=\"hljs-number\">4</span>].weight = <span class=\"hljs-number\">4</span>;\r\n\r\n    KruskalMST(graph);\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    },
    "go": {
      "dir": "graph\\kruskal.go",
      "url": "https://github.com/TheAlgorithms/go/tree/master/graph\\kruskal.go",
      "code": "<span class=\"hljs-comment\">// KRUSKAL&#x27;S ALGORITHM</span>\r\n<span class=\"hljs-comment\">// https://cp-algorithms.com/data_structures/disjoint_set_union.html</span>\r\n<span class=\"hljs-comment\">// https://cp-algorithms.com/graph/mst_kruskal_with_dsu.html</span>\r\n\r\n<span class=\"hljs-keyword\">package</span> graph\r\n\r\n<span class=\"hljs-keyword\">import</span> (\r\n\t<span class=\"hljs-string\">&quot;sort&quot;</span>\r\n)\r\n\r\n<span class=\"hljs-keyword\">type</span> Vertex <span class=\"hljs-type\">int</span>\r\n\r\n<span class=\"hljs-comment\">// Edge describes the edge of a weighted graph</span>\r\n<span class=\"hljs-keyword\">type</span> Edge <span class=\"hljs-keyword\">struct</span> {\r\n\tStart  Vertex\r\n\tEnd    Vertex\r\n\tWeight <span class=\"hljs-type\">int</span>\r\n}\r\n\r\n<span class=\"hljs-comment\">// DisjointSetUnionElement describes what an element of DSU looks like</span>\r\n<span class=\"hljs-keyword\">type</span> DisjointSetUnionElement <span class=\"hljs-keyword\">struct</span> {\r\n\tParent Vertex\r\n\tRank   <span class=\"hljs-type\">int</span>\r\n}\r\n\r\n<span class=\"hljs-comment\">// DisjointSetUnion is a data structure that treats its elements as separate sets</span>\r\n<span class=\"hljs-comment\">// and provides fast operations for set creation, merging sets, and finding the parent</span>\r\n<span class=\"hljs-comment\">// of the given element of a set.</span>\r\n<span class=\"hljs-keyword\">type</span> DisjointSetUnion []DisjointSetUnionElement\r\n\r\n<span class=\"hljs-comment\">// NewDSU will return an initialised DSU using the value of n</span>\r\n<span class=\"hljs-comment\">// which will be treated as the number of elements out of which</span>\r\n<span class=\"hljs-comment\">// the DSU is being made</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewDSU</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>)</span></span> *DisjointSetUnion {\r\n\r\n\tdsu := DisjointSetUnion(<span class=\"hljs-built_in\">make</span>([]DisjointSetUnionElement, n))\r\n\t<span class=\"hljs-keyword\">return</span> &amp;dsu\r\n}\r\n\r\n<span class=\"hljs-comment\">// MakeSet will create a set in the DSU for the given node</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(dsu DisjointSetUnion)</span></span> MakeSet(node Vertex) {\r\n\r\n\tdsu[node].Parent = node\r\n\tdsu[node].Rank = <span class=\"hljs-number\">0</span>\r\n}\r\n\r\n<span class=\"hljs-comment\">// FindSetRepresentative will return the parent element of the set the given node</span>\r\n<span class=\"hljs-comment\">// belongs to. Since every single element in the path from node to parent</span>\r\n<span class=\"hljs-comment\">// has the same parent, we store the parent value for each element in the</span>\r\n<span class=\"hljs-comment\">// path. This reduces consequent function calls and helps in going from O(n)</span>\r\n<span class=\"hljs-comment\">// to O(log n). This is known as path compression technique.</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(dsu DisjointSetUnion)</span></span> FindSetRepresentative(node Vertex) Vertex {\r\n\r\n\t<span class=\"hljs-keyword\">if</span> node == dsu[node].Parent {\r\n\t\t<span class=\"hljs-keyword\">return</span> node\r\n\t}\r\n\r\n\tdsu[node].Parent = dsu.FindSetRepresentative(dsu[node].Parent)\r\n\t<span class=\"hljs-keyword\">return</span> dsu[node].Parent\r\n}\r\n\r\n<span class=\"hljs-comment\">// unionSets will merge two given sets. The naive implementation of this</span>\r\n<span class=\"hljs-comment\">// always combines the secondNode&#x27;s tree with the firstNode&#x27;s tree. This can lead</span>\r\n<span class=\"hljs-comment\">// to creation of trees of length O(n) so we optimize by attaching the node with</span>\r\n<span class=\"hljs-comment\">// smaller rank to the node with bigger rank. Rank represents the upper bound depth of the tree.</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(dsu DisjointSetUnion)</span></span> UnionSets(firstNode Vertex, secondNode Vertex) {\r\n\r\n\tfirstNode = dsu.FindSetRepresentative(firstNode)\r\n\tsecondNode = dsu.FindSetRepresentative(secondNode)\r\n\r\n\t<span class=\"hljs-keyword\">if</span> firstNode != secondNode {\r\n\r\n\t\t<span class=\"hljs-keyword\">if</span> dsu[firstNode].Rank &lt; dsu[secondNode].Rank {\r\n\t\t\tfirstNode, secondNode = secondNode, firstNode\r\n\t\t}\r\n\t\tdsu[secondNode].Parent = firstNode\r\n\r\n\t\t<span class=\"hljs-keyword\">if</span> dsu[firstNode].Rank == dsu[secondNode].Rank {\r\n\t\t\tdsu[firstNode].Rank++\r\n\t\t}\r\n\t}\r\n}\r\n\r\n<span class=\"hljs-comment\">// KruskalMST will return a minimum spanning tree along with its total cost</span>\r\n<span class=\"hljs-comment\">// to using Kruskal&#x27;s algorithm. Time complexity is O(m * log (n)) where m is</span>\r\n<span class=\"hljs-comment\">// the number of edges in the graph and n is number of nodes in it.</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">KruskalMST</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>, edges []Edge)</span></span> ([]Edge, <span class=\"hljs-type\">int</span>) {\r\n\r\n\t<span class=\"hljs-keyword\">var</span> mst []Edge <span class=\"hljs-comment\">// The resultant minimum spanning tree</span>\r\n\t<span class=\"hljs-keyword\">var</span> cost <span class=\"hljs-type\">int</span> = <span class=\"hljs-number\">0</span>\r\n\r\n\tdsu := NewDSU(n)\r\n\r\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ {\r\n\t\tdsu.MakeSet(Vertex(i))\r\n\t}\r\n\r\n\tsort.SliceStable(edges, <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(i, j <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span> {\r\n\t\t<span class=\"hljs-keyword\">return</span> edges[i].Weight &lt; edges[j].Weight\r\n\t})\r\n\r\n\t<span class=\"hljs-keyword\">for</span> _, edge := <span class=\"hljs-keyword\">range</span> edges {\r\n\r\n\t\t<span class=\"hljs-keyword\">if</span> dsu.FindSetRepresentative(edge.Start) != dsu.FindSetRepresentative(edge.End) {\r\n\r\n\t\t\tmst = <span class=\"hljs-built_in\">append</span>(mst, edge)\r\n\t\t\tcost += edge.Weight\r\n\t\t\tdsu.UnionSets(edge.Start, edge.End)\r\n\t\t}\r\n\t}\r\n\r\n\t<span class=\"hljs-keyword\">return</span> mst, cost\r\n}\r\n"
    },
    "swift": {
      "dir": "graph\\spanning_tree\\kruskal.swift",
      "url": "https://github.com/TheAlgorithms/swift/tree/master/graph\\spanning_tree\\kruskal.swift",
      "code": "<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Kruskal</span> {\r\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Vertex</span> {\r\n        <span class=\"hljs-keyword\">let</span> name: <span class=\"hljs-type\">String</span>\r\n        <span class=\"hljs-keyword\">let</span> node <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">UnionFindNode</span>()\r\n\r\n        <span class=\"hljs-keyword\">init</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">name</span>: <span class=\"hljs-type\">String</span>) {\r\n            <span class=\"hljs-keyword\">self</span>.name <span class=\"hljs-operator\">=</span> name\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Edge</span> {\r\n        <span class=\"hljs-keyword\">let</span> from: <span class=\"hljs-type\">Vertex</span>\r\n        <span class=\"hljs-keyword\">let</span> to: <span class=\"hljs-type\">Vertex</span>\r\n        <span class=\"hljs-keyword\">let</span> weight: <span class=\"hljs-type\">Int</span>\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">typealias</span> <span class=\"hljs-type\">Graph</span> <span class=\"hljs-operator\">=</span> [<span class=\"hljs-type\">Edge</span>]\r\n\r\n\r\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">kruskal</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">graph</span>: <span class=\"hljs-type\">Graph</span>) -&gt; <span class=\"hljs-type\">Graph</span> {\r\n        <span class=\"hljs-keyword\">var</span> edges <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Heap</span>(graph) { <span class=\"hljs-variable\">$0</span>.weight <span class=\"hljs-operator\">&lt;</span> <span class=\"hljs-variable\">$1</span>.weight }\r\n\r\n        <span class=\"hljs-keyword\">var</span> result: <span class=\"hljs-type\">Graph</span> <span class=\"hljs-operator\">=</span> []\r\n        result.reserveCapacity(edges.count)\r\n\r\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">let</span> edge <span class=\"hljs-operator\">=</span> edges.extractMin() {\r\n            <span class=\"hljs-keyword\">guard</span> <span class=\"hljs-operator\">!</span><span class=\"hljs-type\">UnionFindNode</span>.inSameSet(edge.from.node, edge.to.node) <span class=\"hljs-keyword\">else</span> {\r\n                <span class=\"hljs-keyword\">continue</span>\r\n            }\r\n            <span class=\"hljs-type\">UnionFindNode</span>.union(edge.from.node, edge.to.node)\r\n            result.append(edge)\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">return</span> result\r\n    }\r\n}\r\n\r\n<span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">Kruskal</span>.<span class=\"hljs-title class_\">Vertex</span>: <span class=\"hljs-title class_\">CustomStringConvertible</span> {\r\n    <span class=\"hljs-keyword\">var</span> description: <span class=\"hljs-type\">String</span> { name }\r\n}\r\n\r\n<span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">Kruskal</span>.<span class=\"hljs-title class_\">Edge</span>: <span class=\"hljs-title class_\">CustomStringConvertible</span> {\r\n    <span class=\"hljs-keyword\">var</span> description: <span class=\"hljs-type\">String</span> { <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">\\(from)</span> --(<span class=\"hljs-subst\">\\(weight)</span>)-- <span class=\"hljs-subst\">\\(to)</span>&quot;</span> }\r\n}\r\n\r\n<span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">testKruskal</span>() {\r\n    <span class=\"hljs-keyword\">typealias</span> <span class=\"hljs-type\">Vertex</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Kruskal</span>.<span class=\"hljs-type\">Vertex</span>\r\n    <span class=\"hljs-keyword\">typealias</span> <span class=\"hljs-type\">Edge</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Kruskal</span>.<span class=\"hljs-type\">Edge</span>\r\n\r\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-type\">A</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Vertex</span>(<span class=\"hljs-string\">&quot;A&quot;</span>)\r\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-type\">B</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Vertex</span>(<span class=\"hljs-string\">&quot;B&quot;</span>)\r\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-type\">C</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Vertex</span>(<span class=\"hljs-string\">&quot;C&quot;</span>)\r\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-type\">D</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Vertex</span>(<span class=\"hljs-string\">&quot;D&quot;</span>)\r\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-type\">E</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Vertex</span>(<span class=\"hljs-string\">&quot;E&quot;</span>)\r\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-type\">F</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Vertex</span>(<span class=\"hljs-string\">&quot;F&quot;</span>)\r\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-type\">G</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Vertex</span>(<span class=\"hljs-string\">&quot;G&quot;</span>)\r\n\r\n    <span class=\"hljs-keyword\">let</span> graph <span class=\"hljs-operator\">=</span> [\r\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">A</span>, to: <span class=\"hljs-type\">B</span>, weight: <span class=\"hljs-number\">7</span>),\r\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">A</span>, to: <span class=\"hljs-type\">D</span>, weight: <span class=\"hljs-number\">5</span>),\r\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">B</span>, to: <span class=\"hljs-type\">C</span>, weight: <span class=\"hljs-number\">8</span>),\r\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">B</span>, to: <span class=\"hljs-type\">D</span>, weight: <span class=\"hljs-number\">9</span>),\r\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">B</span>, to: <span class=\"hljs-type\">E</span>, weight: <span class=\"hljs-number\">7</span>),\r\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">C</span>, to: <span class=\"hljs-type\">E</span>, weight: <span class=\"hljs-number\">5</span>),\r\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">D</span>, to: <span class=\"hljs-type\">E</span>, weight: <span class=\"hljs-number\">15</span>),\r\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">D</span>, to: <span class=\"hljs-type\">F</span>, weight: <span class=\"hljs-number\">6</span>),\r\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">E</span>, to: <span class=\"hljs-type\">F</span>, weight: <span class=\"hljs-number\">8</span>),\r\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">E</span>, to: <span class=\"hljs-type\">G</span>, weight: <span class=\"hljs-number\">9</span>),\r\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">F</span>, to: <span class=\"hljs-type\">G</span>, weight: <span class=\"hljs-number\">11</span>),\r\n    ]\r\n\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-type\">Kruskal</span>.kruskal(graph).map { <span class=\"hljs-type\">String</span>(describing: <span class=\"hljs-variable\">$0</span>) }.joined(separator: <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">\\n</span>&quot;</span>) )\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Sven Weidauer",
      "email": "sven@5sw.de",
      "commits": 1
    },
    {
      "name": "flamespirit919",
      "email": "mikelsworld@comcast.net",
      "commits": 1
    },
    {
      "name": "stepfencurryxiao",
      "email": "stepfencurryxiao@gmail.com",
      "commits": 1
    },
    {
      "name": "Vivek Nathani",
      "email": "52988856+viveknathani@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "ttuanho",
      "email": "hhoanhtuann@gmail.com",
      "commits": 1
    },
    {
      "name": "SangeetaNB",
      "email": "43605580+SangeetaNB@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Libin Yang",
      "email": "szuyanglb@outlook.com",
      "commits": 1
    },
    {
      "name": "Ayaan Khan",
      "email": "ayaankhan98@gmail.com",
      "commits": 1
    },
    {
      "name": "Madhav",
      "email": "madhavgaba2@gmail.com",
      "commits": 1
    },
    {
      "name": "Aitor Fidalgo SÃ¡nchez",
      "email": "64830228+aitorfi@users.noreply.github.com",
      "commits": 2
    },
    {
      "name": "MarcosVillacanas",
      "email": "marcosvillacanas@icloud.com",
      "commits": 3
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 5
    }
  ],
  "explanationUrl": {}
}