{
  "slug": "hopcroft-karp",
  "name": "Hopcroft Karp",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "graph\\hopcroft_karp.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph\\hopcroft_karp.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file \r\n * @brief  Implementation of [Hopcroft–Karp](https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm) algorithm.\r\n * @details \r\n * The Hopcroft–Karp algorithm is an algorithm that takes as input a bipartite graph \r\n * and produces as output a maximum cardinality matching, it runs in O(E√V) time in worst case.\r\n * \r\n * ### Bipartite graph\r\n * A bipartite graph (or bigraph) is a graph whose vertices can be divided into two disjoint \r\n * and independent sets U and V such that every edge connects a vertex in U to one in V. \r\n * Vertex sets U and V are usually called the parts of the graph. \r\n * Equivalently, a bipartite graph is a graph that does not contain any odd-length cycles.\r\n * \r\n * ### Matching and Not-Matching edges\r\n * Given a matching M, edges that are part of matching are called Matching edges and edges that are not part \r\n * of M (or connect free nodes) are called Not-Matching edges.\r\n * \r\n * ### Maximum cardinality matching\r\n * Given a bipartite graphs G = ( V = ( X , Y ) , E ) whose partition has the parts X and Y, \r\n * with E denoting the edges of the graph, the goal is to find a matching with as many edges as possible. \r\n * Equivalently, a matching that covers as many vertices as possible.\r\n * \r\n * ### Augmenting paths\r\n * Given a matching M, an augmenting path is an alternating path that starts from and ends on free vertices. \r\n * All single edge paths that start and end with free vertices are augmenting paths.\r\n * \r\n * \r\n * ### Concept\r\n * A matching M is not maximum if there exists an augmenting path. It is also true other way,\r\n * i.e, a matching is maximum if no augmenting path exists.\r\n * \r\n * \r\n * ### Algorithm\r\n * 1) Initialize the Maximal Matching M as empty.\r\n * 2) While there exists an Augmenting Path P\r\n *   Remove matching edges of P from M and add not-matching edges of P to M\r\n *   (This increases size of M by 1 as P starts and ends with a free vertex\r\n *   i.e. a node that is not part of matching.)\r\n * 3) Return M. \r\n * \r\n * \r\n *\r\n * @author [Krishna Pal Deora](https://github.com/Krishnapal4050)\r\n * \r\n */</span>\r\n\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span> </span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;climits&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;memory&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace graph \r\n * @brief Graph algorithms\r\n */</span>\r\n <span class=\"hljs-keyword\">namespace</span> graph { \r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Represents Bipartite graph for\r\n * Hopcroft Karp implementation\r\n */</span>\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HKGraph</span>\r\n{\r\n    <span class=\"hljs-type\">int</span> m{};  <span class=\"hljs-comment\">///&lt; m is the number of vertices on left side of Bipartite Graph</span>\r\n    <span class=\"hljs-type\">int</span> n{};  <span class=\"hljs-comment\">///&lt; n is the number of vertices on right side of Bipartite Graph</span>\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> NIL{<span class=\"hljs-number\">0</span>};\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> INF{INT_MAX};\r\n\r\n    std::vector&lt;std::list&lt;<span class=\"hljs-type\">int</span>&gt; &gt;adj;  <span class=\"hljs-comment\">///&lt; adj[u] stores adjacents of left side and 0 is used for dummy vertex</span>\r\n\r\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; pair_u; <span class=\"hljs-comment\">///&lt; value of vertex &#x27;u&#x27; ranges from 1 to m</span>\r\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; pair_v; <span class=\"hljs-comment\">///&lt; value of vertex &#x27;v&#x27; ranges from 1 to n</span>\r\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; dist;   <span class=\"hljs-comment\">///&lt; dist represents the distance between vertex &#x27;u&#x27; and vertex &#x27;v&#x27;</span>\r\n\r\n<span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-built_in\">HKGraph</span>();\t\t       <span class=\"hljs-comment\">// Default Constructor</span>\r\n    <span class=\"hljs-built_in\">HKGraph</span>(<span class=\"hljs-type\">int</span> m, <span class=\"hljs-type\">int</span> n);     <span class=\"hljs-comment\">// Constructor</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> v)</span></span>; <span class=\"hljs-comment\">// To add edge</span>\r\n    \r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">bfs</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// Returns true if there is an augmenting path    </span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u)</span></span>; <span class=\"hljs-comment\">// Adds augmenting path if there is one beginning with u  </span>\r\n\t\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">hopcroftKarpAlgorithm</span><span class=\"hljs-params\">()</span></span>;  <span class=\"hljs-comment\">// Returns size of maximum matching</span>\r\n};\r\n\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief This function counts the number of augmenting paths between left and right sides of the Bipartite graph\r\n * @returns size of maximum matching\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">HKGraph::hopcroftKarpAlgorithm</span><span class=\"hljs-params\">()</span>\r\n</span>{\r\n\r\n    <span class=\"hljs-comment\">// pair_u[u] stores pair of u in matching on left side of Bipartite Graph.</span>\r\n    <span class=\"hljs-comment\">// If u doesn&#x27;t have any pair, then pair_u[u] is NIL</span>\r\n    pair_u = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(m + <span class=\"hljs-number\">1</span>,NIL); \r\n\r\n    <span class=\"hljs-comment\">// pair_v[v] stores pair of v in matching on right side of Biparite Graph.</span>\r\n    <span class=\"hljs-comment\">// If v doesn&#x27;t have any pair, then pair_u[v] is NIL</span>\r\n    pair_v = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(n + <span class=\"hljs-number\">1</span>,NIL); \r\n\r\n    dist = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(m + <span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">// dist[u] stores distance of left side vertices</span>\r\n\r\n    <span class=\"hljs-type\">int</span> result = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// Initialize result</span>\r\n\r\n    <span class=\"hljs-comment\">// Keep updating the result while there is an augmenting path possible.</span>\r\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">bfs</span>())\r\n    {\r\n        <span class=\"hljs-comment\">// Find a free vertex to check for a matching</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> u = <span class=\"hljs-number\">1</span>; u &lt;= m; u++){\r\n\r\n            <span class=\"hljs-comment\">// If current vertex is free and there is</span>\r\n            <span class=\"hljs-comment\">// an augmenting path from current vertex</span>\r\n            <span class=\"hljs-comment\">// then increment the result</span>\r\n            <span class=\"hljs-keyword\">if</span> (pair_u[u] == NIL &amp;&amp; <span class=\"hljs-built_in\">dfs</span>(u)){\r\n                result++;\r\n\t    }\r\n\t}\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> result;\r\n}\r\n\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief This function checks for the possibility of augmented path availability \r\n * @returns `true` if there is an augmenting path available\r\n * @returns `false` if there is no augmenting path available\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">HKGraph::bfs</span><span class=\"hljs-params\">()</span>\r\n</span>{\r\n    std::queue&lt;<span class=\"hljs-type\">int</span>&gt; q; <span class=\"hljs-comment\">// an integer queue for bfs</span>\r\n\r\n    <span class=\"hljs-comment\">// First layer of vertices (set distance as 0)</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> u = <span class=\"hljs-number\">1</span>; u &lt;= m; u++)\r\n    {\r\n        <span class=\"hljs-comment\">// If this is a free vertex, add it to queue</span>\r\n        <span class=\"hljs-keyword\">if</span> (pair_u[u] == NIL){\r\n            \r\n            dist[u] = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// u is not matched so distance is 0</span>\r\n            q.<span class=\"hljs-built_in\">push</span>(u);\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">else</span>{\r\n            dist[u] = INF; <span class=\"hljs-comment\">// set distance as infinite so that this vertex is considered next time for availibility</span>\r\n\t}\r\n    }\r\n\r\n    \r\n    dist[NIL] = INF; <span class=\"hljs-comment\">// Initialize distance to NIL as infinite</span>\r\n\r\n    <span class=\"hljs-comment\">// q is going to contain vertices of left side only.</span>\r\n    <span class=\"hljs-keyword\">while</span> (!q.<span class=\"hljs-built_in\">empty</span>())\r\n    {\r\n        <span class=\"hljs-type\">int</span> u = q.<span class=\"hljs-built_in\">front</span>();  <span class=\"hljs-comment\">// dequeue a vertex</span>\r\n        q.<span class=\"hljs-built_in\">pop</span>();\r\n\r\n        <span class=\"hljs-comment\">// If this node is not NIL and can provide a shorter path to NIL then</span>\r\n        <span class=\"hljs-keyword\">if</span> (dist[u] &lt; dist[NIL])\r\n        {\r\n            <span class=\"hljs-comment\">// Get all the adjacent vertices of the dequeued vertex u</span>\r\n            std::list&lt;<span class=\"hljs-type\">int</span>&gt;::iterator it;\r\n            <span class=\"hljs-keyword\">for</span> (it = adj[u].<span class=\"hljs-built_in\">begin</span>(); it != adj[u].<span class=\"hljs-built_in\">end</span>(); ++it)\r\n            {\r\n                <span class=\"hljs-type\">int</span> v = *it;\r\n\r\n                <span class=\"hljs-comment\">// If pair of v is not considered so far i.e. (v, pair_v[v]) is not yet explored edge.</span>\r\n                <span class=\"hljs-keyword\">if</span> (dist[pair_v[v]] == INF)\r\n                {\r\n                    dist[pair_v[v]] = dist[u] + <span class=\"hljs-number\">1</span>; \r\n                    q.<span class=\"hljs-built_in\">push</span>(pair_v[v]);    <span class=\"hljs-comment\">// Consider the pair and push it to queue</span>\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n   \r\n   \r\n    <span class=\"hljs-keyword\">return</span> (dist[NIL] != INF);   <span class=\"hljs-comment\">// If we could come back to NIL using alternating path of distinct vertices then there is an augmenting path available</span>\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief This functions checks whether an augmenting path is available exists beginning with free vertex u\r\n * @param u represents position of vertex\r\n * @returns `true` if there is an augmenting path beginning with free vertex u\r\n * @returns `false` if there is no augmenting path beginning with free vertex u\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">HKGraph::dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u)</span>\r\n</span>{\r\n    <span class=\"hljs-keyword\">if</span> (u != NIL)\r\n    {\r\n        std::list&lt;<span class=\"hljs-type\">int</span>&gt;::iterator it;\r\n        <span class=\"hljs-keyword\">for</span> (it = adj[u].<span class=\"hljs-built_in\">begin</span>(); it != adj[u].<span class=\"hljs-built_in\">end</span>(); ++it)\r\n        {\r\n            \r\n            <span class=\"hljs-type\">int</span> v = *it; <span class=\"hljs-comment\">// Adjacent vertex of u</span>\r\n\r\n            <span class=\"hljs-comment\">// Follow the distances set by BFS search</span>\r\n            <span class=\"hljs-keyword\">if</span> (dist[pair_v[v]] == dist[u] + <span class=\"hljs-number\">1</span>)\r\n            {\r\n                <span class=\"hljs-comment\">// If dfs for pair of v also return true then new matching possible, store the matching</span>\r\n                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">dfs</span>(pair_v[v]) == <span class=\"hljs-literal\">true</span>)\r\n                {   \r\n                    pair_v[v] = u;\r\n                    pair_u[u] = v;\r\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n                }\r\n            }\r\n        }\r\n\r\n        \r\n        dist[u] = INF; <span class=\"hljs-comment\">// If there is no augmenting path beginning with u then set distance to infinite.</span>\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Default Constructor for initialization\r\n */</span>\r\nHKGraph::<span class=\"hljs-built_in\">HKGraph</span>() = <span class=\"hljs-keyword\">default</span>;\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Constructor for initialization\r\n * @param m is the number of vertices on left side of Bipartite Graph\r\n * @param n is the number of vertices on right side of Bipartite Graph\r\n */</span>\r\nHKGraph::<span class=\"hljs-built_in\">HKGraph</span>(<span class=\"hljs-type\">int</span> m, <span class=\"hljs-type\">int</span> n) {\r\n    <span class=\"hljs-keyword\">this</span>-&gt;m = m;\r\n    <span class=\"hljs-keyword\">this</span>-&gt;n = n;\r\n    adj = std::vector&lt;std::list&lt;<span class=\"hljs-type\">int</span>&gt; &gt;(m + <span class=\"hljs-number\">1</span>);\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief function to add edge from u to v\r\n * @param u is the position of first vertex\r\n * @param v is the position of second vertex\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">HKGraph::addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> v)</span>\r\n</span>{\r\n    adj[u].<span class=\"hljs-built_in\">push_back</span>(v); <span class=\"hljs-comment\">// Add v to u’s list.</span>\r\n}\r\n\r\n} <span class=\"hljs-comment\">// namespace graph</span>\r\n\r\n<span class=\"hljs-keyword\">using</span> graph::HKGraph;\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Self-test implementation\r\n * @returns none\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">tests</span><span class=\"hljs-params\">()</span></span>{\r\n     <span class=\"hljs-comment\">// Sample test case 1</span>\r\n\t     <span class=\"hljs-type\">int</span> v1a = <span class=\"hljs-number\">3</span>, v1b = <span class=\"hljs-number\">5</span>, e1 = <span class=\"hljs-number\">2</span>;  <span class=\"hljs-comment\">// vertices of left side, right side and edges</span>\r\n\t     <span class=\"hljs-function\">HKGraph <span class=\"hljs-title\">g1</span><span class=\"hljs-params\">(v1a, v1b)</span></span>; <span class=\"hljs-comment\">// execute the algorithm </span>\r\n\r\n\t     g1.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>);\r\n\t     g1.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">4</span>);\r\n\r\n\t     <span class=\"hljs-type\">int</span> expected_res1 = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// for the above sample data, this is the expected output</span>\r\n\t     <span class=\"hljs-type\">int</span> res1 = g1.<span class=\"hljs-built_in\">hopcroftKarpAlgorithm</span>();\r\n\r\n\t     <span class=\"hljs-built_in\">assert</span>(res1 == expected_res1); <span class=\"hljs-comment\">// assert check to ensure that the algorithm executed correctly for test 1</span>\r\n\t\r\n     <span class=\"hljs-comment\">// Sample test case 2</span>\r\n     \t     <span class=\"hljs-type\">int</span> v2a = <span class=\"hljs-number\">4</span>, v2b = <span class=\"hljs-number\">4</span>, e2 = <span class=\"hljs-number\">6</span>;  <span class=\"hljs-comment\">// vertices of left side, right side and edges</span>\r\n\t     <span class=\"hljs-function\">HKGraph <span class=\"hljs-title\">g2</span><span class=\"hljs-params\">(v2a, v2b)</span></span>; <span class=\"hljs-comment\">// execute the algorithm </span>\r\n\r\n             g2.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>);\r\n\t     g2.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>);\r\n\t     g2.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>);\r\n\t     g2.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>);\r\n\t     g2.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">3</span>);\r\n             g2.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">2</span>);\r\n\t\r\n\t     <span class=\"hljs-type\">int</span> expected_res2 = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// for the above sample data, this is the expected output</span>\r\n\t     <span class=\"hljs-type\">int</span> res2 = g2.<span class=\"hljs-built_in\">hopcroftKarpAlgorithm</span>();\r\n\r\n\t     <span class=\"hljs-built_in\">assert</span>(res2 == expected_res2); <span class=\"hljs-comment\">// assert check to ensure that the algorithm executed correctly for test 2</span>\r\n\t\r\n      <span class=\"hljs-comment\">// Sample test case 3</span>\r\n     \t     <span class=\"hljs-type\">int</span> v3a = <span class=\"hljs-number\">6</span>, v3b = <span class=\"hljs-number\">6</span>, e3 = <span class=\"hljs-number\">4</span>;  <span class=\"hljs-comment\">// vertices of left side, right side and edges</span>\r\n\t     <span class=\"hljs-function\">HKGraph <span class=\"hljs-title\">g3</span><span class=\"hljs-params\">(v3a, v3b)</span></span>; <span class=\"hljs-comment\">// execute the algorithm </span>\r\n\r\n             g3.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>);\r\n\t     g3.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">4</span>);\r\n\t     g3.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>);\r\n\t     g3.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">0</span>);\r\n\r\n\t     <span class=\"hljs-type\">int</span> expected_res3 = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// for the above sample data, this is the expected output</span>\r\n\t     <span class=\"hljs-type\">int</span> res3 = g3.<span class=\"hljs-built_in\">hopcroftKarpAlgorithm</span>();\r\n\r\n\t     <span class=\"hljs-built_in\">assert</span>(res3 == expected_res3); <span class=\"hljs-comment\">// assert check to ensure that the algorithm executed correctly for test 3</span>\r\n\t\r\n\t\r\n    \t\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>\r\n</span>{\r\n    <span class=\"hljs-built_in\">tests</span>();  <span class=\"hljs-comment\">// perform self-tests</span>\r\n\r\n    <span class=\"hljs-type\">int</span> v1 = <span class=\"hljs-number\">0</span>, v2 = <span class=\"hljs-number\">0</span>, e = <span class=\"hljs-number\">0</span>;\r\n    std::cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; e; <span class=\"hljs-comment\">// vertices of left side, right side and edges</span>\r\n    <span class=\"hljs-function\">HKGraph <span class=\"hljs-title\">g</span><span class=\"hljs-params\">(v1, v2)</span></span>;  \r\n    <span class=\"hljs-type\">int</span> u = <span class=\"hljs-number\">0</span>, v = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; e; ++i)\r\n    {\r\n        std::cin &gt;&gt; u &gt;&gt; v;\r\n        g.<span class=\"hljs-built_in\">addEdge</span>(u, v);\r\n    }\r\n  \r\n    <span class=\"hljs-type\">int</span> res = g.<span class=\"hljs-built_in\">hopcroftKarpAlgorithm</span>();\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Maximum matching is &quot;</span> &lt;&lt; res &lt;&lt;<span class=\"hljs-string\">&quot;\\n&quot;</span>;\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Krishna Pal Deora",
      "email": "53469625+Krishnapal4050@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}