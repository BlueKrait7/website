{
  "slug": "graham-scan",
  "name": "Graham Scan",
  "categories": [
    "others"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "other\\graham_scan.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/other\\graham_scan.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;\r\nThis is a pure Python implementation of the merge-insertion sort algorithm\r\nSource: https://en.wikipedia.org/wiki/Graham_scan\r\n\r\nFor doctests run following command:\r\npython3 -m doctest -v graham_scan.py\r\n&quot;&quot;&quot;</span>\r\n\r\n<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\r\n\r\n<span class=\"hljs-keyword\">from</span> collections <span class=\"hljs-keyword\">import</span> deque\r\n<span class=\"hljs-keyword\">from</span> enum <span class=\"hljs-keyword\">import</span> Enum\r\n<span class=\"hljs-keyword\">from</span> math <span class=\"hljs-keyword\">import</span> atan2, degrees\r\n<span class=\"hljs-keyword\">from</span> sys <span class=\"hljs-keyword\">import</span> maxsize\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">graham_scan</span>(<span class=\"hljs-params\">points: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>]]</span>) -&gt; <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>]]:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;Pure implementation of graham scan algorithm in Python\r\n\r\n    :param points: The unique points on coordinates.\r\n    :return: The points on convex hell.\r\n\r\n    Examples:\r\n    &gt;&gt;&gt; graham_scan([(9, 6), (3, 1), (0, 0), (5, 5), (5, 2), (7, 0), (3, 3), (1, 4)])\r\n    [(0, 0), (7, 0), (9, 6), (5, 5), (1, 4)]\r\n\r\n    &gt;&gt;&gt; graham_scan([(0, 0), (1, 0), (1, 1), (0, 1)])\r\n    [(0, 0), (1, 0), (1, 1), (0, 1)]\r\n\r\n    &gt;&gt;&gt; graham_scan([(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)])\r\n    [(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)]\r\n\r\n    &gt;&gt;&gt; graham_scan([(-100, 20), (99, 3), (1, 10000001), (5133186, -25), (-66, -4)])\r\n    [(5133186, -25), (1, 10000001), (-100, 20), (-66, -4)]\r\n    &quot;&quot;&quot;</span>\r\n\r\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(points) &lt;= <span class=\"hljs-number\">2</span>:\r\n        <span class=\"hljs-comment\"># There is no convex hull</span>\r\n        <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&quot;graham_scan: argument must contain more than 3 points.&quot;</span>)\r\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(points) == <span class=\"hljs-number\">3</span>:\r\n        <span class=\"hljs-keyword\">return</span> points\r\n    <span class=\"hljs-comment\"># find the lowest and the most left point</span>\r\n    minidx = <span class=\"hljs-number\">0</span>\r\n    miny, minx = maxsize, maxsize\r\n    <span class=\"hljs-keyword\">for</span> i, point <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(points):\r\n        x = point[<span class=\"hljs-number\">0</span>]\r\n        y = point[<span class=\"hljs-number\">1</span>]\r\n        <span class=\"hljs-keyword\">if</span> y &lt; miny:\r\n            miny = y\r\n            minx = x\r\n            minidx = i\r\n        <span class=\"hljs-keyword\">if</span> y == miny:\r\n            <span class=\"hljs-keyword\">if</span> x &lt; minx:\r\n                minx = x\r\n                minidx = i\r\n\r\n    <span class=\"hljs-comment\"># remove the lowest and the most left point from points for preparing for sort</span>\r\n    points.pop(minidx)\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">angle_comparer</span>(<span class=\"hljs-params\">point: <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>], minx: <span class=\"hljs-built_in\">int</span>, miny: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">float</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;Return the angle toward to point from (minx, miny)\r\n\r\n        :param point: The target point\r\n               minx: The starting point&#x27;s x\r\n               miny: The starting point&#x27;s y\r\n        :return: the angle\r\n\r\n        Examples:\r\n        &gt;&gt;&gt; angle_comparer((1,1), 0, 0)\r\n        45.0\r\n\r\n        &gt;&gt;&gt; angle_comparer((100,1), 10, 10)\r\n        -5.710593137499642\r\n\r\n        &gt;&gt;&gt; angle_comparer((5,5), 2, 3)\r\n        33.690067525979785\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-comment\"># sort the points accorgind to the angle from the lowest and the most left point</span>\r\n        x = point[<span class=\"hljs-number\">0</span>]\r\n        y = point[<span class=\"hljs-number\">1</span>]\r\n        angle = degrees(atan2(y - miny, x - minx))\r\n        <span class=\"hljs-keyword\">return</span> angle\r\n\r\n    sorted_points = <span class=\"hljs-built_in\">sorted</span>(points, key=<span class=\"hljs-keyword\">lambda</span> point: angle_comparer(point, minx, miny))\r\n    <span class=\"hljs-comment\"># This insert actually costs complexity,</span>\r\n    <span class=\"hljs-comment\"># and you should instead add (minx, miny) into stack later.</span>\r\n    <span class=\"hljs-comment\"># I&#x27;m using insert just for easy understanding.</span>\r\n    sorted_points.insert(<span class=\"hljs-number\">0</span>, (minx, miny))\r\n\r\n    <span class=\"hljs-comment\"># traversal from the lowest and the most left point in anti-clockwise direction</span>\r\n    <span class=\"hljs-comment\"># if direction gets right, the previous point is not the convex hull.</span>\r\n    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Direction</span>(<span class=\"hljs-title class_ inherited__\">Enum</span>):\r\n        left = <span class=\"hljs-number\">1</span>\r\n        straight = <span class=\"hljs-number\">2</span>\r\n        right = <span class=\"hljs-number\">3</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">check_direction</span>(<span class=\"hljs-params\">\r\n        starting: <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>], via: <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>], target: <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>]\r\n    </span>) -&gt; Direction:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;Return the direction toward to the line from via to target from starting\r\n\r\n        :param starting: The starting point\r\n               via: The via point\r\n               target: The target point\r\n        :return: the Direction\r\n\r\n        Examples:\r\n        &gt;&gt;&gt; check_direction((1,1), (2,2), (3,3))\r\n        Direction.straight\r\n\r\n        &gt;&gt;&gt; check_direction((60,1), (-50,199), (30,2))\r\n        Direction.left\r\n\r\n        &gt;&gt;&gt; check_direction((0,0), (5,5), (10,0))\r\n        Direction.right\r\n        &quot;&quot;&quot;</span>\r\n        x0, y0 = starting\r\n        x1, y1 = via\r\n        x2, y2 = target\r\n        via_angle = degrees(atan2(y1 - y0, x1 - x0))\r\n        <span class=\"hljs-keyword\">if</span> via_angle &lt; <span class=\"hljs-number\">0</span>:\r\n            via_angle += <span class=\"hljs-number\">360</span>\r\n        target_angle = degrees(atan2(y2 - y0, x2 - x0))\r\n        <span class=\"hljs-keyword\">if</span> target_angle &lt; <span class=\"hljs-number\">0</span>:\r\n            target_angle += <span class=\"hljs-number\">360</span>\r\n        <span class=\"hljs-comment\"># t-</span>\r\n        <span class=\"hljs-comment\">#  \\ \\</span>\r\n        <span class=\"hljs-comment\">#   \\ v</span>\r\n        <span class=\"hljs-comment\">#    \\|</span>\r\n        <span class=\"hljs-comment\">#     s</span>\r\n        <span class=\"hljs-comment\"># via_angle is always lower than target_angle, if direction is left.</span>\r\n        <span class=\"hljs-comment\"># If they are same, it means they are on a same line of convex hull.</span>\r\n        <span class=\"hljs-keyword\">if</span> target_angle &gt; via_angle:\r\n            <span class=\"hljs-keyword\">return</span> Direction.left\r\n        <span class=\"hljs-keyword\">elif</span> target_angle == via_angle:\r\n            <span class=\"hljs-keyword\">return</span> Direction.straight\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            <span class=\"hljs-keyword\">return</span> Direction.right\r\n\r\n    stack: deque[<span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>]] = deque()\r\n    stack.append(sorted_points[<span class=\"hljs-number\">0</span>])\r\n    stack.append(sorted_points[<span class=\"hljs-number\">1</span>])\r\n    stack.append(sorted_points[<span class=\"hljs-number\">2</span>])\r\n    <span class=\"hljs-comment\"># In any ways, the first 3 points line are towards left.</span>\r\n    <span class=\"hljs-comment\"># Because we sort them the angle from minx, miny.</span>\r\n    current_direction = Direction.left\r\n\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-built_in\">len</span>(sorted_points)):\r\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\r\n            starting = stack[-<span class=\"hljs-number\">2</span>]\r\n            via = stack[-<span class=\"hljs-number\">1</span>]\r\n            target = sorted_points[i]\r\n            next_direction = check_direction(starting, via, target)\r\n\r\n            <span class=\"hljs-keyword\">if</span> next_direction == Direction.left:\r\n                current_direction = Direction.left\r\n                <span class=\"hljs-keyword\">break</span>\r\n            <span class=\"hljs-keyword\">if</span> next_direction == Direction.straight:\r\n                <span class=\"hljs-keyword\">if</span> current_direction == Direction.left:\r\n                    <span class=\"hljs-comment\"># We keep current_direction as left.</span>\r\n                    <span class=\"hljs-comment\"># Because if the straight line keeps as straight,</span>\r\n                    <span class=\"hljs-comment\"># we want to know if this straight line is towards left.</span>\r\n                    <span class=\"hljs-keyword\">break</span>\r\n                <span class=\"hljs-keyword\">elif</span> current_direction == Direction.right:\r\n                    <span class=\"hljs-comment\"># If the straight line is towards right,</span>\r\n                    <span class=\"hljs-comment\"># every previous points on those straigh line is not convex hull.</span>\r\n                    stack.pop()\r\n            <span class=\"hljs-keyword\">if</span> next_direction == Direction.right:\r\n                stack.pop()\r\n        stack.append(sorted_points[i])\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">list</span>(stack)\r\n"
    }
  },
  "contributors": [
    {
      "name": "ulwlu",
      "email": "ooulwluoo@gmail.com",
      "commits": 1
    },
    {
      "name": "Andrew Grangaard",
      "email": "andrew.grangaard@gmail.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}