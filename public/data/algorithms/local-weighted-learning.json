{
  "slug": "local-weighted-learning",
  "name": "Local Weighted Learning",
  "categories": [
    "machinelearning"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "machine_learning\\local_weighted_learning\\local_weighted_learning.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/machine_learning\\local_weighted_learning\\local_weighted_learning.py",
      "code": "<span class=\"hljs-comment\"># Required imports to run this file</span>\r\n<span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt\r\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\r\n\r\n\r\n<span class=\"hljs-comment\"># weighted matrix</span>\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">weighted_matrix</span>(<span class=\"hljs-params\">point: np.mat, training_data_x: np.mat, bandwidth: <span class=\"hljs-built_in\">float</span></span>) -&gt; np.mat:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Calculate the weight for every point in the\r\n    data set. It takes training_point , query_point, and tau\r\n    Here Tau is not a fixed value it can be varied depends on output.\r\n    tau --&gt; bandwidth\r\n    xmat --&gt;Training data\r\n    point --&gt; the x where we want to make predictions\r\n    &gt;&gt;&gt; weighted_matrix(np.array([1., 1.]),np.mat([[16.99, 10.34], [21.01,23.68],\r\n    ...                    [24.59,25.69]]), 0.6)\r\n    matrix([[1.43807972e-207, 0.00000000e+000, 0.00000000e+000],\r\n            [0.00000000e+000, 0.00000000e+000, 0.00000000e+000],\r\n            [0.00000000e+000, 0.00000000e+000, 0.00000000e+000]])\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-comment\"># m is the number of training samples</span>\r\n    m, n = np.shape(training_data_x)\r\n    <span class=\"hljs-comment\"># Initializing weights as identity matrix</span>\r\n    weights = np.mat(np.eye(m))\r\n    <span class=\"hljs-comment\"># calculating weights for all training examples [x(i)&#x27;s]</span>\r\n    <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(m):\r\n        diff = point - training_data_x[j]\r\n        weights[j, j] = np.exp(diff * diff.T / (-<span class=\"hljs-number\">2.0</span> * bandwidth**<span class=\"hljs-number\">2</span>))\r\n    <span class=\"hljs-keyword\">return</span> weights\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">local_weight</span>(<span class=\"hljs-params\">\r\n    point: np.mat, training_data_x: np.mat, training_data_y: np.mat, bandwidth: <span class=\"hljs-built_in\">float</span>\r\n</span>) -&gt; np.mat:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Calculate the local weights using the weight_matrix function on training data.\r\n    Return the weighted matrix.\r\n    &gt;&gt;&gt; local_weight(np.array([1., 1.]),np.mat([[16.99, 10.34], [21.01,23.68],\r\n    ...                 [24.59,25.69]]),np.mat([[1.01, 1.66, 3.5]]), 0.6)\r\n    matrix([[0.00873174],\r\n            [0.08272556]])\r\n    &quot;&quot;&quot;</span>\r\n    weight = weighted_matrix(point, training_data_x, bandwidth)\r\n    W = (training_data_x.T * (weight * training_data_x)).I * (\r\n        training_data_x.T * weight * training_data_y.T\r\n    )\r\n\r\n    <span class=\"hljs-keyword\">return</span> W\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">local_weight_regression</span>(<span class=\"hljs-params\">\r\n    training_data_x: np.mat, training_data_y: np.mat, bandwidth: <span class=\"hljs-built_in\">float</span>\r\n</span>) -&gt; np.mat:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Calculate predictions for each data point on axis.\r\n    &gt;&gt;&gt; local_weight_regression(np.mat([[16.99, 10.34], [21.01,23.68],\r\n    ...                            [24.59,25.69]]),np.mat([[1.01, 1.66, 3.5]]), 0.6)\r\n    array([1.07173261, 1.65970737, 3.50160179])\r\n    &quot;&quot;&quot;</span>\r\n    m, n = np.shape(training_data_x)\r\n    ypred = np.zeros(m)\r\n\r\n    <span class=\"hljs-keyword\">for</span> i, item <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(training_data_x):\r\n        ypred[i] = item * local_weight(\r\n            item, training_data_x, training_data_y, bandwidth\r\n        )\r\n\r\n    <span class=\"hljs-keyword\">return</span> ypred\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">load_data</span>(<span class=\"hljs-params\">dataset_name: <span class=\"hljs-built_in\">str</span>, cola_name: <span class=\"hljs-built_in\">str</span>, colb_name: <span class=\"hljs-built_in\">str</span></span>) -&gt; np.mat:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Function used for loading data from the seaborn splitting into x and y points\r\n    &gt;&gt;&gt; pass # this function has no doctest\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-keyword\">import</span> seaborn <span class=\"hljs-keyword\">as</span> sns\r\n\r\n    data = sns.load_dataset(dataset_name)\r\n    col_a = np.array(data[cola_name])  <span class=\"hljs-comment\"># total_bill</span>\r\n    col_b = np.array(data[colb_name])  <span class=\"hljs-comment\"># tip</span>\r\n\r\n    mcol_a = np.mat(col_a)\r\n    mcol_b = np.mat(col_b)\r\n\r\n    m = np.shape(mcol_b)[<span class=\"hljs-number\">1</span>]\r\n    one = np.ones((<span class=\"hljs-number\">1</span>, m), dtype=<span class=\"hljs-built_in\">int</span>)\r\n\r\n    <span class=\"hljs-comment\"># horizontal stacking</span>\r\n    training_data_x = np.hstack((one.T, mcol_a.T))\r\n\r\n    <span class=\"hljs-keyword\">return</span> training_data_x, mcol_b, col_a, col_b\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_preds</span>(<span class=\"hljs-params\">training_data_x: np.mat, mcol_b: np.mat, tau: <span class=\"hljs-built_in\">float</span></span>) -&gt; np.ndarray:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Get predictions with minimum error for each training data\r\n    &gt;&gt;&gt; get_preds(np.mat([[16.99, 10.34], [21.01,23.68],\r\n    ...                     [24.59,25.69]]),np.mat([[1.01, 1.66, 3.5]]), 0.6)\r\n    array([1.07173261, 1.65970737, 3.50160179])\r\n    &quot;&quot;&quot;</span>\r\n    ypred = local_weight_regression(training_data_x, mcol_b, tau)\r\n    <span class=\"hljs-keyword\">return</span> ypred\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">plot_preds</span>(<span class=\"hljs-params\">\r\n    training_data_x: np.mat,\r\n    predictions: np.ndarray,\r\n    col_x: np.ndarray,\r\n    col_y: np.ndarray,\r\n    cola_name: <span class=\"hljs-built_in\">str</span>,\r\n    colb_name: <span class=\"hljs-built_in\">str</span>,\r\n</span>) -&gt; plt.plot:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    This function used to plot predictions and display the graph\r\n    &gt;&gt;&gt; pass #this function has no doctest\r\n    &quot;&quot;&quot;</span>\r\n    xsort = training_data_x.copy()\r\n    xsort.sort(axis=<span class=\"hljs-number\">0</span>)\r\n    plt.scatter(col_x, col_y, color=<span class=\"hljs-string\">&quot;blue&quot;</span>)\r\n    plt.plot(\r\n        xsort[:, <span class=\"hljs-number\">1</span>],\r\n        predictions[training_data_x[:, <span class=\"hljs-number\">1</span>].argsort(<span class=\"hljs-number\">0</span>)],\r\n        color=<span class=\"hljs-string\">&quot;yellow&quot;</span>,\r\n        linewidth=<span class=\"hljs-number\">5</span>,\r\n    )\r\n    plt.title(<span class=\"hljs-string\">&quot;Local Weighted Regression&quot;</span>)\r\n    plt.xlabel(cola_name)\r\n    plt.ylabel(colb_name)\r\n    plt.show()\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    training_data_x, mcol_b, col_a, col_b = load_data(<span class=\"hljs-string\">&quot;tips&quot;</span>, <span class=\"hljs-string\">&quot;total_bill&quot;</span>, <span class=\"hljs-string\">&quot;tip&quot;</span>)\r\n    predictions = get_preds(training_data_x, mcol_b, <span class=\"hljs-number\">0.5</span>)\r\n    plot_preds(training_data_x, predictions, col_a, col_b, <span class=\"hljs-string\">&quot;total_bill&quot;</span>, <span class=\"hljs-string\">&quot;tip&quot;</span>)\r\n"
    }
  },
  "contributors": [
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 1
    },
    {
      "name": "Venkatesh Tantravahi",
      "email": "64308188+venkateshtantravahi@users.noreply.github.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}