{
  "slug": "integral-approximation-2",
  "name": "Integral Approximation 2",
  "categories": [
    "math"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "math\\integral_approximation2.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/math\\integral_approximation2.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @brief [Monte Carlo\r\n * Integration](https://en.wikipedia.org/wiki/Monte_Carlo_integration)\r\n *\r\n * @details\r\n * In mathematics, Monte Carlo integration is a technique for numerical\r\n * integration using random numbers. It is a particular Monte Carlo method that\r\n * numerically computes a definite integral. While other algorithms usually\r\n * evaluate the integrand at a regular grid, Monte Carlo randomly chooses points\r\n * at which the integrand is evaluated. This method is particularly useful for\r\n * higher-dimensional integrals.\r\n *\r\n * This implementation supports arbitrary pdfs.\r\n * These pdfs are sampled using the [Metropolis-Hastings\r\n * algorithm](https://en.wikipedia.org/wiki/Metropolisâ€“Hastings_algorithm). This\r\n * can be swapped out by every other sampling techniques for example the inverse\r\n * method. Metropolis-Hastings was chosen because it is the most general and can\r\n * also be extended for a higher dimensional sampling space.\r\n *\r\n * @author [Domenic Zingsheim](https://github.com/DerAndereDomenic)\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> _USE_MATH_DEFINES  <span class=\"hljs-comment\">/// for M_PI on windows</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span>           <span class=\"hljs-comment\">/// for math functions</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdint&gt;</span>         <span class=\"hljs-comment\">/// for fixed size data types</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ctime&gt;</span>           <span class=\"hljs-comment\">/// for time to initialize rng</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;functional&gt;</span>      <span class=\"hljs-comment\">/// for function pointers</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>        <span class=\"hljs-comment\">/// for std::cout</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;random&gt;</span>          <span class=\"hljs-comment\">/// for random number generation</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>          <span class=\"hljs-comment\">/// for std::vector</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace math\r\n * @brief Math algorithms\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> math {\r\n<span class=\"hljs-comment\">/**\r\n * @namespace monte_carlo\r\n * @brief Functions for the [Monte Carlo\r\n * Integration](https://en.wikipedia.org/wiki/Monte_Carlo_integration)\r\n * implementation\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> monte_carlo {\r\n\r\n<span class=\"hljs-keyword\">using</span> Function = std::function&lt;<span class=\"hljs-built_in\">double</span>(\r\n    <span class=\"hljs-type\">double</span>&amp;)&gt;;  <span class=\"hljs-comment\">/// short-hand for std::functions used in this implementation</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Generate samples according to some pdf\r\n * @details This function uses Metropolis-Hastings to generate random numbers.\r\n * It generates a sequence of random numbers by using a markov chain. Therefore,\r\n * we need to define a start_point and the number of samples we want to\r\n * generate. Because the first samples generated by the markov chain may not be\r\n * distributed according to the given pdf, one can specify how many samples\r\n * should be discarded before storing samples.\r\n * @param start_point The starting point of the markov chain\r\n * @param pdf The pdf to sample\r\n * @param num_samples The number of samples to generate\r\n * @param discard How many samples should be discarded at the start\r\n * @returns A vector of size num_samples with samples distributed according to\r\n * the pdf\r\n */</span>\r\n<span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">generate_samples</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span>&amp; start_point,\r\n                                     <span class=\"hljs-type\">const</span> Function&amp; pdf,\r\n                                     <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span>&amp; num_samples,\r\n                                     <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span>&amp; discard = <span class=\"hljs-number\">100000</span>)</span> </span>{\r\n    std::vector&lt;<span class=\"hljs-type\">double</span>&gt; samples;\r\n    samples.<span class=\"hljs-built_in\">reserve</span>(num_samples);\r\n\r\n    <span class=\"hljs-type\">double</span> <span class=\"hljs-type\">x_t</span> = start_point;\r\n\r\n    std::default_random_engine generator;\r\n    <span class=\"hljs-function\">std::uniform_real_distribution&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">uniform</span><span class=\"hljs-params\">(<span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">1.0</span>)</span></span>;\r\n    <span class=\"hljs-function\">std::normal_distribution&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">normal</span><span class=\"hljs-params\">(<span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">1.0</span>)</span></span>;\r\n    generator.<span class=\"hljs-built_in\">seed</span>(<span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">nullptr</span>));\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> t = <span class=\"hljs-number\">0</span>; t &lt; num_samples + discard; ++t) {\r\n        <span class=\"hljs-comment\">// Generate a new proposal according to some mutation strategy.</span>\r\n        <span class=\"hljs-comment\">// This is arbitrary and can be swapped.</span>\r\n        <span class=\"hljs-type\">double</span> x_dash = <span class=\"hljs-built_in\">normal</span>(generator) + <span class=\"hljs-type\">x_t</span>;\r\n        <span class=\"hljs-type\">double</span> acceptance_probability = std::<span class=\"hljs-built_in\">min</span>(<span class=\"hljs-built_in\">pdf</span>(x_dash) / <span class=\"hljs-built_in\">pdf</span>(<span class=\"hljs-type\">x_t</span>), <span class=\"hljs-number\">1.0</span>);\r\n        <span class=\"hljs-type\">double</span> u = <span class=\"hljs-built_in\">uniform</span>(generator);\r\n\r\n        <span class=\"hljs-comment\">// Accept &quot;new state&quot; according to the acceptance_probability</span>\r\n        <span class=\"hljs-keyword\">if</span> (u &lt;= acceptance_probability) {\r\n            <span class=\"hljs-type\">x_t</span> = x_dash;\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">if</span> (t &gt;= discard) {\r\n            samples.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-type\">x_t</span>);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">return</span> samples;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Compute an approximation of an integral using Monte Carlo integration\r\n * @details The integration domain [a,b] is given by the pdf.\r\n * The pdf has to fulfill the following conditions:\r\n * 1) for all x \\in [a,b] : p(x) &gt; 0\r\n * 2) for all x \\not\\in [a,b] : p(x) = 0\r\n * 3) \\int_a^b p(x) dx = 1\r\n * @param start_point The start point of the Markov Chain (see generate_samples)\r\n * @param function The function to integrate\r\n * @param pdf The pdf to sample\r\n * @param num_samples The number of samples used to approximate the integral\r\n * @returns The approximation of the integral according to 1/N \\sum_{i}^N f(x_i)\r\n * / p(x_i)\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">integral_monte_carlo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span>&amp; start_point, <span class=\"hljs-type\">const</span> Function&amp; function,\r\n                            <span class=\"hljs-type\">const</span> Function&amp; pdf,\r\n                            <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span>&amp; num_samples = <span class=\"hljs-number\">1000000</span>)</span> </span>{\r\n    <span class=\"hljs-type\">double</span> integral = <span class=\"hljs-number\">0.0</span>;\r\n    std::vector&lt;<span class=\"hljs-type\">double</span>&gt; samples =\r\n        <span class=\"hljs-built_in\">generate_samples</span>(start_point, pdf, num_samples);\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">double</span> sample : samples) {\r\n        integral += <span class=\"hljs-built_in\">function</span>(sample) / <span class=\"hljs-built_in\">pdf</span>(sample);\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">return</span> integral / <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(samples.<span class=\"hljs-built_in\">size</span>());\r\n}\r\n\r\n}  <span class=\"hljs-comment\">// namespace monte_carlo</span>\r\n}  <span class=\"hljs-comment\">// namespace math</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Self-test implementations\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Disclaimer: Because this is a randomized algorithm,&quot;</span>\r\n              &lt;&lt; std::endl;\r\n    std::cout\r\n        &lt;&lt; <span class=\"hljs-string\">&quot;it may happen that singular samples deviate from the true result.&quot;</span>\r\n        &lt;&lt; std::endl\r\n        &lt;&lt; std::endl;\r\n    ;\r\n\r\n    math::monte_carlo::Function f;\r\n    math::monte_carlo::Function pdf;\r\n    <span class=\"hljs-type\">double</span> integral = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">double</span> lower_bound = <span class=\"hljs-number\">0</span>, upper_bound = <span class=\"hljs-number\">0</span>;\r\n\r\n    <span class=\"hljs-comment\">/* \\int_{-2}^{2} -x^2 + 4 dx */</span>\r\n    f = [&amp;](<span class=\"hljs-type\">double</span>&amp; x) { <span class=\"hljs-keyword\">return</span> -x * x + <span class=\"hljs-number\">4.0</span>; };\r\n\r\n    lower_bound = <span class=\"hljs-number\">-2.0</span>;\r\n    upper_bound = <span class=\"hljs-number\">2.0</span>;\r\n    pdf = [&amp;](<span class=\"hljs-type\">double</span>&amp; x) {\r\n        <span class=\"hljs-keyword\">if</span> (x &gt;= lower_bound &amp;&amp; x &lt;= <span class=\"hljs-number\">-1.0</span>) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.1</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (x &lt;= upper_bound &amp;&amp; x &gt;= <span class=\"hljs-number\">1.0</span>) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.1</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (x &gt; <span class=\"hljs-number\">-1.0</span> &amp;&amp; x &lt; <span class=\"hljs-number\">1.0</span>) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.4</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.0</span>;\r\n    };\r\n\r\n    integral = math::monte_carlo::<span class=\"hljs-built_in\">integral_monte_carlo</span>(\r\n        (upper_bound - lower_bound) / <span class=\"hljs-number\">2.0</span>, f, pdf);\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;This number should be close to 10.666666: &quot;</span> &lt;&lt; integral\r\n              &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-comment\">/* \\int_{0}^{1} e^x dx */</span>\r\n    f = [&amp;](<span class=\"hljs-type\">double</span>&amp; x) { <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">exp</span>(x); };\r\n\r\n    lower_bound = <span class=\"hljs-number\">0.0</span>;\r\n    upper_bound = <span class=\"hljs-number\">1.0</span>;\r\n    pdf = [&amp;](<span class=\"hljs-type\">double</span>&amp; x) {\r\n        <span class=\"hljs-keyword\">if</span> (x &gt;= lower_bound &amp;&amp; x &lt;= <span class=\"hljs-number\">0.2</span>) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.1</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (x &gt; <span class=\"hljs-number\">0.2</span> &amp;&amp; x &lt;= <span class=\"hljs-number\">0.4</span>) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.4</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (x &gt; <span class=\"hljs-number\">0.4</span> &amp;&amp; x &lt; upper_bound) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1.5</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.0</span>;\r\n    };\r\n\r\n    integral = math::monte_carlo::<span class=\"hljs-built_in\">integral_monte_carlo</span>(\r\n        (upper_bound - lower_bound) / <span class=\"hljs-number\">2.0</span>, f, pdf);\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;This number should be close to 1.7182818: &quot;</span> &lt;&lt; integral\r\n              &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-comment\">/* \\int_{-\\infty}^{\\infty} sinc(x) dx, sinc(x) = sin(pi * x) / (pi * x)\r\n       This is a difficult integral because of its infinite domain.\r\n       Therefore, it may deviate largely from the expected result.\r\n    */</span>\r\n    f = [&amp;](<span class=\"hljs-type\">double</span>&amp; x) { <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">sin</span>(M_PI * x) / (M_PI * x); };\r\n\r\n    pdf = [&amp;](<span class=\"hljs-type\">double</span>&amp; x) {\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1.0</span> / std::<span class=\"hljs-built_in\">sqrt</span>(<span class=\"hljs-number\">2.0</span> * M_PI) * std::<span class=\"hljs-built_in\">exp</span>(-x * x / <span class=\"hljs-number\">2.0</span>);\r\n    };\r\n\r\n    integral = math::monte_carlo::<span class=\"hljs-built_in\">integral_monte_carlo</span>(<span class=\"hljs-number\">0.0</span>, f, pdf, <span class=\"hljs-number\">10000000</span>);\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;This number should be close to 1.0: &quot;</span> &lt;&lt; integral\r\n              &lt;&lt; std::endl;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// run self-test implementations</span>\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [],
  "explanationUrl": {}
}