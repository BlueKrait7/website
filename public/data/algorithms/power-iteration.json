{
  "slug": "power-iteration",
  "name": "Power Iteration",
  "categories": [
    "linearalgebra"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "linear_algebra\\src\\power_iteration.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/linear_algebra\\src\\power_iteration.py",
      "code": "<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">power_iteration</span>(<span class=\"hljs-params\">\r\n    input_matrix: np.ndarray,\r\n    vector: np.ndarray,\r\n    error_tol: <span class=\"hljs-built_in\">float</span> = <span class=\"hljs-number\">1e-12</span>,\r\n    max_iterations: <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">100</span>,\r\n</span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">float</span>, np.ndarray]:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Power Iteration.\r\n    Find the largest eigenvalue and corresponding eigenvector\r\n    of matrix input_matrix given a random vector in the same space.\r\n    Will work so long as vector has component of largest eigenvector.\r\n    input_matrix must be either real or Hermitian.\r\n\r\n    Input\r\n    input_matrix: input matrix whose largest eigenvalue we will find.\r\n    Numpy array. np.shape(input_matrix) == (N,N).\r\n    vector: random initial vector in same space as matrix.\r\n    Numpy array. np.shape(vector) == (N,) or (N,1)\r\n\r\n    Output\r\n    largest_eigenvalue: largest eigenvalue of the matrix input_matrix.\r\n    Float. Scalar.\r\n    largest_eigenvector: eigenvector corresponding to largest_eigenvalue.\r\n    Numpy array. np.shape(largest_eigenvector) == (N,) or (N,1).\r\n\r\n    &gt;&gt;&gt; import numpy as np\r\n    &gt;&gt;&gt; input_matrix = np.array([\r\n    ... [41,  4, 20],\r\n    ... [ 4, 26, 30],\r\n    ... [20, 30, 50]\r\n    ... ])\r\n    &gt;&gt;&gt; vector = np.array([41,4,20])\r\n    &gt;&gt;&gt; power_iteration(input_matrix,vector)\r\n    (79.66086378788381, array([0.44472726, 0.46209842, 0.76725662]))\r\n    &quot;&quot;&quot;</span>\r\n\r\n    <span class=\"hljs-comment\"># Ensure matrix is square.</span>\r\n    <span class=\"hljs-keyword\">assert</span> np.shape(input_matrix)[<span class=\"hljs-number\">0</span>] == np.shape(input_matrix)[<span class=\"hljs-number\">1</span>]\r\n    <span class=\"hljs-comment\"># Ensure proper dimensionality.</span>\r\n    <span class=\"hljs-keyword\">assert</span> np.shape(input_matrix)[<span class=\"hljs-number\">0</span>] == np.shape(vector)[<span class=\"hljs-number\">0</span>]\r\n    <span class=\"hljs-comment\"># Ensure inputs are either both complex or both real</span>\r\n    <span class=\"hljs-keyword\">assert</span> np.iscomplexobj(input_matrix) == np.iscomplexobj(vector)\r\n    is_complex = np.iscomplexobj(input_matrix)\r\n    <span class=\"hljs-keyword\">if</span> is_complex:\r\n        <span class=\"hljs-comment\"># Ensure complex input_matrix is Hermitian</span>\r\n        <span class=\"hljs-keyword\">assert</span> np.array_equal(input_matrix, input_matrix.conj().T)\r\n\r\n    <span class=\"hljs-comment\"># Set convergence to False. Will define convergence when we exceed max_iterations</span>\r\n    <span class=\"hljs-comment\"># or when we have small changes from one iteration to next.</span>\r\n\r\n    convergence = <span class=\"hljs-literal\">False</span>\r\n    lamda_previous = <span class=\"hljs-number\">0</span>\r\n    iterations = <span class=\"hljs-number\">0</span>\r\n    error = <span class=\"hljs-number\">1e12</span>\r\n\r\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">not</span> convergence:\r\n        <span class=\"hljs-comment\"># Multiple matrix by the vector.</span>\r\n        w = np.dot(input_matrix, vector)\r\n        <span class=\"hljs-comment\"># Normalize the resulting output vector.</span>\r\n        vector = w / np.linalg.norm(w)\r\n        <span class=\"hljs-comment\"># Find rayleigh quotient</span>\r\n        <span class=\"hljs-comment\"># (faster than usual b/c we know vector is normalized already)</span>\r\n        vectorH = vector.conj().T <span class=\"hljs-keyword\">if</span> is_complex <span class=\"hljs-keyword\">else</span> vector.T\r\n        lamda = np.dot(vectorH, np.dot(input_matrix, vector))\r\n\r\n        <span class=\"hljs-comment\"># Check convergence.</span>\r\n        error = np.<span class=\"hljs-built_in\">abs</span>(lamda - lamda_previous) / lamda\r\n        iterations += <span class=\"hljs-number\">1</span>\r\n\r\n        <span class=\"hljs-keyword\">if</span> error &lt;= error_tol <span class=\"hljs-keyword\">or</span> iterations &gt;= max_iterations:\r\n            convergence = <span class=\"hljs-literal\">True</span>\r\n\r\n        lamda_previous = lamda\r\n\r\n    <span class=\"hljs-keyword\">if</span> is_complex:\r\n        lamda = np.real(lamda)\r\n\r\n    <span class=\"hljs-keyword\">return</span> lamda, vector\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">test_power_iteration</span>() -&gt; <span class=\"hljs-literal\">None</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    &gt;&gt;&gt; test_power_iteration()  # self running tests\r\n    &quot;&quot;&quot;</span>\r\n    real_input_matrix = np.array([[<span class=\"hljs-number\">41</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">20</span>], [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">26</span>, <span class=\"hljs-number\">30</span>], [<span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">50</span>]])\r\n    real_vector = np.array([<span class=\"hljs-number\">41</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">20</span>])\r\n    complex_input_matrix = real_input_matrix.astype(np.complex128)\r\n    imag_matrix = np.triu(<span class=\"hljs-number\">1j</span> * complex_input_matrix, <span class=\"hljs-number\">1</span>)\r\n    complex_input_matrix += imag_matrix\r\n    complex_input_matrix += -<span class=\"hljs-number\">1</span> * imag_matrix.T\r\n    complex_vector = np.array([<span class=\"hljs-number\">41</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">20</span>]).astype(np.complex128)\r\n\r\n    <span class=\"hljs-keyword\">for</span> problem_type <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-string\">&quot;real&quot;</span>, <span class=\"hljs-string\">&quot;complex&quot;</span>]:\r\n        <span class=\"hljs-keyword\">if</span> problem_type == <span class=\"hljs-string\">&quot;real&quot;</span>:\r\n            input_matrix = real_input_matrix\r\n            vector = real_vector\r\n        <span class=\"hljs-keyword\">elif</span> problem_type == <span class=\"hljs-string\">&quot;complex&quot;</span>:\r\n            input_matrix = complex_input_matrix\r\n            vector = complex_vector\r\n\r\n        <span class=\"hljs-comment\"># Our implementation.</span>\r\n        eigen_value, eigen_vector = power_iteration(input_matrix, vector)\r\n\r\n        <span class=\"hljs-comment\"># Numpy implementation.</span>\r\n\r\n        <span class=\"hljs-comment\"># Get eigenvalues and eigenvectors using built-in numpy</span>\r\n        <span class=\"hljs-comment\"># eigh (eigh used for symmetric or hermetian matrices).</span>\r\n        eigen_values, eigen_vectors = np.linalg.eigh(input_matrix)\r\n        <span class=\"hljs-comment\"># Last eigenvalue is the maximum one.</span>\r\n        eigen_value_max = eigen_values[-<span class=\"hljs-number\">1</span>]\r\n        <span class=\"hljs-comment\"># Last column in this matrix is eigenvector corresponding to largest eigenvalue.</span>\r\n        eigen_vector_max = eigen_vectors[:, -<span class=\"hljs-number\">1</span>]\r\n\r\n        <span class=\"hljs-comment\"># Check our implementation and numpy gives close answers.</span>\r\n        <span class=\"hljs-keyword\">assert</span> np.<span class=\"hljs-built_in\">abs</span>(eigen_value - eigen_value_max) &lt;= <span class=\"hljs-number\">1e-6</span>\r\n        <span class=\"hljs-comment\"># Take absolute values element wise of each eigenvector.</span>\r\n        <span class=\"hljs-comment\"># as they are only unique to a minus sign.</span>\r\n        <span class=\"hljs-keyword\">assert</span> np.linalg.norm(np.<span class=\"hljs-built_in\">abs</span>(eigen_vector) - np.<span class=\"hljs-built_in\">abs</span>(eigen_vector_max)) &lt;= <span class=\"hljs-number\">1e-6</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    <span class=\"hljs-keyword\">import</span> doctest\r\n\r\n    doctest.testmod()\r\n    test_power_iteration()\r\n"
    },
    "c-sharp": {
      "dir": "./Algorithms/LinearAlgebra/Eigenvalue/PowerIteration.cs",
      "url": "https:\\github.com\\TheAlgorithms\\C-Sharp\\tree\\master\\Algorithms\\LinearAlgebra\\Eigenvalue\\PowerIteration.cs",
      "code": "<span class=\"hljs-keyword\">using</span> System;\r\n<span class=\"hljs-keyword\">using</span> System.Linq;\r\n<span class=\"hljs-keyword\">using</span> Utilities.Extensions;\r\n\r\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">Algorithms.LinearAlgebra.Eigenvalue</span>\r\n{\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Power iteration method - eigenvalue numeric algorithm, based on recurrent relation:</span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Li+1 = (A * Li) / || A * Li ||, where Li - eigenvector approximation.</span>\r\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PowerIteration</span>\r\n    {\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Returns approximation of the dominant eigenvalue and eigenvector of <span class=\"hljs-doctag\">&lt;paramref name=&quot;source&quot; /&gt;</span> matrix.</span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;list type=&quot;bullet&quot;&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;item&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;description&gt;</span>The algorithm will not converge if the start vector is orthogonal to the eigenvector.<span class=\"hljs-doctag\">&lt;/description&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;/item&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;item&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;description&gt;</span>The <span class=\"hljs-doctag\">&lt;paramref name=&quot;source&quot; /&gt;</span> matrix must be square-shaped.<span class=\"hljs-doctag\">&lt;/description&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;/item&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/list&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;source&quot;&gt;</span>Source square-shaped matrix.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;startVector&quot;&gt;</span>Start vector.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;error&quot;&gt;</span>Accuracy of the result.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Dominant eigenvalue and eigenvector pair.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;exception cref=&quot;ArgumentException&quot;&gt;</span>The <span class=\"hljs-doctag\">&lt;paramref name=&quot;source&quot; /&gt;</span> matrix is not square-shaped.<span class=\"hljs-doctag\">&lt;/exception&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;exception cref=&quot;ArgumentException&quot;&gt;</span>The length of the start vector doesn&#x27;t equal the size of the source matrix.<span class=\"hljs-doctag\">&lt;/exception&gt;</span></span>\r\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> (<span class=\"hljs-params\"><span class=\"hljs-built_in\">double</span> eigenvalue, <span class=\"hljs-built_in\">double</span>[] eigenvector</span>) <span class=\"hljs-title\">Dominant</span>(<span class=\"hljs-params\">\r\n            <span class=\"hljs-built_in\">double</span>[,] source,\r\n            <span class=\"hljs-built_in\">double</span>[] startVector,\r\n            <span class=\"hljs-built_in\">double</span> error = <span class=\"hljs-number\">0.00001</span></span>)</span>\r\n        {\r\n            <span class=\"hljs-keyword\">if</span> (source.GetLength(<span class=\"hljs-number\">0</span>) != source.GetLength(<span class=\"hljs-number\">1</span>))\r\n            {\r\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ArgumentException(<span class=\"hljs-string\">&quot;The source matrix is not square-shaped.&quot;</span>);\r\n            }\r\n\r\n            <span class=\"hljs-keyword\">if</span> (source.GetLength(<span class=\"hljs-number\">0</span>) != startVector.Length)\r\n            {\r\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ArgumentException(\r\n                    <span class=\"hljs-string\">&quot;The length of the start vector doesn&#x27;t equal the size of the source matrix.&quot;</span>);\r\n            }\r\n\r\n            <span class=\"hljs-built_in\">double</span> eigenNorm;\r\n            <span class=\"hljs-built_in\">double</span>[] previousEigenVector;\r\n            <span class=\"hljs-built_in\">double</span>[] currentEigenVector = startVector;\r\n\r\n            <span class=\"hljs-keyword\">do</span>\r\n            {\r\n                previousEigenVector = currentEigenVector;\r\n                currentEigenVector = source.Multiply(\r\n                        previousEigenVector.ToColumnVector())\r\n                    .ToRowVector();\r\n\r\n                eigenNorm = currentEigenVector.Magnitude();\r\n                currentEigenVector = currentEigenVector.Select(x =&gt; x / eigenNorm).ToArray();\r\n            }\r\n            <span class=\"hljs-keyword\">while</span> (Math.Abs(currentEigenVector.Dot(previousEigenVector)) &lt; <span class=\"hljs-number\">1.0</span> - error);\r\n\r\n            <span class=\"hljs-keyword\">var</span> eigenvalue = source.Multiply(currentEigenVector.ToColumnVector()).ToRowVector().Magnitude();\r\n\r\n            <span class=\"hljs-keyword\">return</span> (eigenvalue, eigenvector: currentEigenVector);\r\n        }\r\n\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Returns approximation of the dominant eigenvalue and eigenvector of <span class=\"hljs-doctag\">&lt;paramref name=&quot;source&quot; /&gt;</span> matrix.</span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Random normalized vector is used as the start vector to decrease chance of orthogonality to the eigenvector.</span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;list type=&quot;bullet&quot;&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;item&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;description&gt;</span>The algorithm will not converge if the start vector is orthogonal to the eigenvector.<span class=\"hljs-doctag\">&lt;/description&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;/item&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;item&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;description&gt;</span>The <span class=\"hljs-doctag\">&lt;paramref name=&quot;source&quot; /&gt;</span> matrix should be square-shaped.<span class=\"hljs-doctag\">&lt;/description&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;/item&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/list&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;source&quot;&gt;</span>Source square-shaped matrix.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;error&quot;&gt;</span>Accuracy of the result.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Dominant eigenvalue and eigenvector pair.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;exception cref=&quot;ArgumentException&quot;&gt;</span>The <span class=\"hljs-doctag\">&lt;paramref name=&quot;source&quot; /&gt;</span> matrix is not square-shaped.<span class=\"hljs-doctag\">&lt;/exception&gt;</span></span>\r\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;exception cref=&quot;ArgumentException&quot;&gt;</span>The length of the start vector doesn&#x27;t equal the size of the source matrix.<span class=\"hljs-doctag\">&lt;/exception&gt;</span></span>\r\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> (<span class=\"hljs-params\"><span class=\"hljs-built_in\">double</span> eigenvalue, <span class=\"hljs-built_in\">double</span>[] eigenvector</span>) <span class=\"hljs-title\">Dominant</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">double</span>[,] source, <span class=\"hljs-built_in\">double</span> error = <span class=\"hljs-number\">0.00001</span></span>)</span> =&gt;\r\n            Dominant(source, <span class=\"hljs-keyword\">new</span> Random().NextVector(source.GetLength(<span class=\"hljs-number\">1</span>)), error);\r\n    }\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Anton Kozyriev",
      "email": "sonara4mus@gmail.com",
      "commits": 1
    },
    {
      "name": "Calvin McCarter",
      "email": "calvin199@gmail.com",
      "commits": 1
    },
    {
      "name": "Dhruv Manilawala",
      "email": "dhruvmanila@gmail.com",
      "commits": 1
    },
    {
      "name": "zakademic",
      "email": "67771932+zakademic@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Andrii Siriak",
      "email": "siryaka@gmail.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}