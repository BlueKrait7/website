{
  "slug": "inorder-successor-of-bst",
  "name": "Inorder Successor of Bst",
  "categories": [
    "operationsondatastructures"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "operations_on_datastructures\\inorder_successor_of_bst.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/operations_on_datastructures\\inorder_successor_of_bst.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @brief An implementation for finding the [Inorder successor of a binary\r\n * search tree](https://www.youtube.com/watch?v=5cPbNCrdotA) Inorder\r\n * successor of a node is the next node in Inorder traversal of the Binary Tree.\r\n * Inorder Successor is NULL for the last node in Inorder traversal.\r\n * @details\r\n * ### Case 1: The given node has the right node/subtree\r\n *\r\n *      * In this case, the left-most deepest node in the right subtree will\r\n * come just after the given node as we go to left deep in inorder.\r\n *      - Go deep to left most node in right subtree.\r\n *        OR, we can also say in case if BST, find the minimum of the subtree\r\n * for a given node.\r\n *\r\n * ### Case 2: The given node does not have a right node/subtree\r\n *\r\n * #### Method 1: Use parent pointer (store the address of parent nodes)\r\n *      * If a node does not have the right subtree, and we already visited the\r\n * node itself, then the next node will be its parent node according to inorder\r\n * traversal, and if we are going to parent from left, then the parent would be\r\n * unvisited.\r\n *      * In other words, go to the nearest ancestor for which given node would\r\n * be in left subtree.\r\n *\r\n * #### Method 2: Search from the root node\r\n *      * In case if there is no link from a child node to the parent node, we\r\n * need to walk down the tree starting from the root node to the given node, by\r\n * doing so, we are visiting every ancestor of the given node.\r\n *      * In order successor would be the deepest node in this path for which\r\n * given node is in left subtree.\r\n *\r\n * @author [Nitin Sharma](https://github.com/foo290)\r\n * */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>   <span class=\"hljs-comment\">///  for assert</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">///  for IO Operations</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>    <span class=\"hljs-comment\">///  for std::vector</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace operations_on_datastructures\r\n * @brief Operations on data structures\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> operations_on_datastructures {\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace inorder_successor_of_bst\r\n * @brief Functions for the [Inorder successor of a binary search\r\n * tree](https://www.youtube.com/watch?v=5cPbNCrdotA) implementation\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> inorder_traversal_of_bst {\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief A Node structure representing a single node in BST\r\n */</span>\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span> {\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-type\">int64_t</span> data;  <span class=\"hljs-comment\">///&lt; The key/value of the node</span>\r\n    Node *left;    <span class=\"hljs-comment\">///&lt; Pointer to Left child</span>\r\n    Node *right;   <span class=\"hljs-comment\">///&lt; Pointer to right child</span>\r\n};\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Allocates a new node in heap for given data and returns it&#x27;s pointer.\r\n * @param data Data for the node.\r\n * @returns A pointer to the newly allocated Node.\r\n * */</span>\r\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">makeNode</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> data)</span> </span>{\r\n    Node *node = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>();\r\n    node-&gt;data = data;      <span class=\"hljs-comment\">///&lt; setting data for node</span>\r\n    node-&gt;left = <span class=\"hljs-literal\">nullptr</span>;   <span class=\"hljs-comment\">///&lt; setting left child as null</span>\r\n    node-&gt;right = <span class=\"hljs-literal\">nullptr</span>;  <span class=\"hljs-comment\">///&lt; setting right child as null</span>\r\n    <span class=\"hljs-keyword\">return</span> node;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Inserts the given data in BST while maintaining the properties of BST.\r\n * @param root Pointer to the root node of the BST\r\n * @param data Data to be inserted.\r\n * @returns Node* Pointer to the root node.\r\n * */</span>\r\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(Node *root, <span class=\"hljs-type\">int64_t</span> data)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>) {\r\n        root = <span class=\"hljs-built_in\">makeNode</span>(data);\r\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (data &lt;= root-&gt;data) {\r\n        root-&gt;left = <span class=\"hljs-built_in\">Insert</span>(root-&gt;left, data);\r\n    } <span class=\"hljs-keyword\">else</span> {\r\n        root-&gt;right = <span class=\"hljs-built_in\">Insert</span>(root-&gt;right, data);\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> root;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Searches the given data in BST and returns the pointer to the node\r\n * containing that data.\r\n * @param root Pointer to the root node of the BST\r\n * @param data Data to be Searched.\r\n * @returns Node* pointer to the found node\r\n * */</span>\r\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">getNode</span><span class=\"hljs-params\">(Node *root, <span class=\"hljs-type\">int64_t</span> data)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>) {\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;\r\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (root-&gt;data == data) {\r\n        <span class=\"hljs-keyword\">return</span> root;  <span class=\"hljs-comment\">/// Node found!</span>\r\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (data &gt; root-&gt;data) {\r\n        <span class=\"hljs-comment\">/// Traverse right subtree recursively as the given data is greater than</span>\r\n        <span class=\"hljs-comment\">/// the data in root node, data must be present in right subtree.</span>\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">getNode</span>(root-&gt;right, data);\r\n    } <span class=\"hljs-keyword\">else</span> {\r\n        <span class=\"hljs-comment\">/// Traverse left subtree recursively as the given data is less than the</span>\r\n        <span class=\"hljs-comment\">/// data in root node, data must be present in left subtree.</span>\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">getNode</span>(root-&gt;left, data);\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Finds and return the minimum node in BST.\r\n * @param root A pointer to root node.\r\n * @returns Node* Pointer to the found node\r\n * */</span>\r\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">findMinNode</span><span class=\"hljs-params\">(Node *root)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>) {\r\n        <span class=\"hljs-keyword\">return</span> root;\r\n    }\r\n    <span class=\"hljs-keyword\">while</span> (root-&gt;left != <span class=\"hljs-literal\">nullptr</span>) {\r\n        root = root-&gt;left;\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> root;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Prints the BST in inorder traversal using recursion.\r\n * @param root A pointer to the root node of the BST.\r\n * @returns void\r\n * */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printInorder</span><span class=\"hljs-params\">(Node *root)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>) {\r\n        <span class=\"hljs-keyword\">return</span>;\r\n    }\r\n\r\n    <span class=\"hljs-built_in\">printInorder</span>(root-&gt;left);  <span class=\"hljs-comment\">/// recursive call to left subtree</span>\r\n    std::cout &lt;&lt; root-&gt;data &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;\r\n    <span class=\"hljs-built_in\">printInorder</span>(root-&gt;right);  <span class=\"hljs-comment\">/// recursive call to right subtree</span>\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief This function is used in test cases to quickly create BST containing\r\n * large data instead of hard coding it in code. For a given root, this will add\r\n * all the nodes containing data passes in data vector.\r\n * @param root Pointer to the root node.\r\n * @param data A vector containing integer values which are suppose to be\r\n * inserted as nodes in BST.\r\n * @returns Node pointer to the root node.\r\n * */</span>\r\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">makeBST</span><span class=\"hljs-params\">(Node *root, <span class=\"hljs-type\">const</span> std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; &amp;data)</span> </span>{\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int64_t</span> values : data) {\r\n        root = <span class=\"hljs-built_in\">Insert</span>(root, values);\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> root;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Inorder successor of a node is the next node in inorder traversal of\r\n * the Binary Tree. This function takes the root node and the data of the node\r\n * for which we have to find the inorder successor, and returns the inorder\r\n * successor node.\r\n * @details Search from the root node as we need to walk the tree starting from\r\n * the root node to the given node, by doing so, we are visiting every ancestor\r\n * of the given node. In order successor would be the deepest node in this path\r\n * for which given node is in left subtree. Time complexity O(h)\r\n * @param root A pointer to the root node of the BST\r\n * @param data The data (or the data of node) for which we have to find inorder\r\n * successor.\r\n * @returns Node pointer to the inorder successor node.\r\n * */</span>\r\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">getInorderSuccessor</span><span class=\"hljs-params\">(Node *root, <span class=\"hljs-type\">int64_t</span> data)</span> </span>{\r\n    Node *current = <span class=\"hljs-built_in\">getNode</span>(root, data);\r\n    <span class=\"hljs-keyword\">if</span> (current == <span class=\"hljs-literal\">nullptr</span>) {\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// Case - 1</span>\r\n    <span class=\"hljs-keyword\">if</span> (current-&gt;right != <span class=\"hljs-literal\">nullptr</span>) {\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">findMinNode</span>(current-&gt;right);\r\n    }\r\n    <span class=\"hljs-comment\">// case - 2</span>\r\n    <span class=\"hljs-keyword\">else</span> {\r\n        Node *successor = <span class=\"hljs-literal\">nullptr</span>;\r\n        Node *ancestor = root;\r\n\r\n        <span class=\"hljs-keyword\">while</span> (ancestor != current &amp;&amp; ancestor != <span class=\"hljs-literal\">nullptr</span>) {\r\n            <span class=\"hljs-comment\">// This means my current node is in left of the root node</span>\r\n            <span class=\"hljs-keyword\">if</span> (current-&gt;data &lt; ancestor-&gt;data) {\r\n                successor = ancestor;\r\n                ancestor = ancestor-&gt;left;  <span class=\"hljs-comment\">// keep going left</span>\r\n            } <span class=\"hljs-keyword\">else</span> {\r\n                ancestor = ancestor-&gt;right;\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> successor;  <span class=\"hljs-comment\">// Nodes with maximum vales will not have a successor</span>\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief This function clears the memory allocated to entire tree recursively.\r\n * Its just for clean up the memory and not relevant to the actual topic.\r\n * @param root Root node of the tree.\r\n * @returns void\r\n * */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">deallocate</span><span class=\"hljs-params\">(Node *rootNode)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (rootNode == <span class=\"hljs-literal\">nullptr</span>) {\r\n        <span class=\"hljs-keyword\">return</span>;\r\n    }\r\n    <span class=\"hljs-built_in\">deallocate</span>(rootNode-&gt;left);\r\n    <span class=\"hljs-built_in\">deallocate</span>(rootNode-&gt;right);\r\n    <span class=\"hljs-built_in\">delete</span> (rootNode);\r\n}\r\n\r\n}  <span class=\"hljs-comment\">// namespace inorder_traversal_of_bst</span>\r\n}  <span class=\"hljs-comment\">// namespace operations_on_datastructures</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief class encapsulating the necessary test cases\r\n */</span>\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TestCases</span> {\r\n <span class=\"hljs-keyword\">private</span>:\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief A function to print given message on console.\r\n     * @tparam T Type of the given message.\r\n     * @returns void\r\n     * */</span>\r\n    <span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">log</span><span class=\"hljs-params\">(T msg)</span> </span>{\r\n        <span class=\"hljs-comment\">// It&#x27;s just to avoid writing cout and endl</span>\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;[TESTS] : ---&gt; &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;\r\n    }\r\n\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Executes test cases\r\n     * @returns void\r\n     * */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">runTests</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Running Tests...&quot;</span>);\r\n\r\n        <span class=\"hljs-built_in\">testCase_1</span>();\r\n        <span class=\"hljs-built_in\">testCase_2</span>();\r\n        <span class=\"hljs-built_in\">testCase_3</span>();\r\n\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Test Cases over!&quot;</span>);\r\n        std::cout &lt;&lt; std::endl;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief A test case contains edge case, printing inorder successor of last\r\n     * node.\r\n     * @returns void\r\n     * */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">testCase_1</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-type\">const</span> operations_on_datastructures::inorder_traversal_of_bst::Node\r\n            *expectedOutput = <span class=\"hljs-literal\">nullptr</span>;  <span class=\"hljs-comment\">///&lt; Expected output of this test</span>\r\n\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;</span>);\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;This is test case 1 : &quot;</span>);\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Description:&quot;</span>);\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;   EDGE CASE : Printing inorder successor for last node in the &quot;</span>\r\n            <span class=\"hljs-string\">&quot;BST, Output will be nullptr.&quot;</span>);\r\n\r\n        operations_on_datastructures::inorder_traversal_of_bst::Node *root =\r\n            <span class=\"hljs-literal\">nullptr</span>;\r\n        std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; node_data{\r\n            <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">23</span>, <span class=\"hljs-number\">45</span>, <span class=\"hljs-number\">78</span>, <span class=\"hljs-number\">21</span>};  <span class=\"hljs-comment\">///&lt; Data to make nodes in BST</span>\r\n\r\n        root = operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">makeBST</span>(\r\n            root,\r\n            node_data);  <span class=\"hljs-comment\">///&lt; Adding nodes to BST</span>\r\n\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Inorder sequence is : &quot;</span>;\r\n        operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">printInorder</span>(\r\n            root);  <span class=\"hljs-comment\">///&lt; Printing inorder to cross-verify.</span>\r\n        std::cout &lt;&lt; std::endl;\r\n\r\n        operations_on_datastructures::inorder_traversal_of_bst::Node\r\n            *inorderSuccessor = operations_on_datastructures::\r\n                inorder_traversal_of_bst::<span class=\"hljs-built_in\">getInorderSuccessor</span>(\r\n                    root, <span class=\"hljs-number\">78</span>);  <span class=\"hljs-comment\">///&lt; The inorder successor node for given data</span>\r\n\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Checking assert expression...&quot;</span>);\r\n        <span class=\"hljs-built_in\">assert</span>(inorderSuccessor == expectedOutput);\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Assertion check passed!&quot;</span>);\r\n\r\n        operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">deallocate</span>(\r\n            root);  <span class=\"hljs-comment\">/// memory cleanup!</span>\r\n\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;[PASS] : TEST CASE 1 PASS!&quot;</span>);\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;</span>);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief A test case which contains main list of 100 elements and sublist\r\n     * of 20.\r\n     * @returns void\r\n     * */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">testCase_2</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> expectedOutput = <span class=\"hljs-number\">21</span>;  <span class=\"hljs-comment\">///&lt; Expected output of this test</span>\r\n\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;</span>);\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;This is test case 2 : &quot;</span>);\r\n\r\n        operations_on_datastructures::inorder_traversal_of_bst::Node *root =\r\n            <span class=\"hljs-literal\">nullptr</span>;\r\n        std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; node_data{\r\n            <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">23</span>, <span class=\"hljs-number\">45</span>, <span class=\"hljs-number\">78</span>, <span class=\"hljs-number\">21</span>};  <span class=\"hljs-comment\">///&lt; Data to make nodes in BST</span>\r\n\r\n        root = operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">makeBST</span>(\r\n            root,\r\n            node_data);  <span class=\"hljs-comment\">///&lt; Adding nodes to BST</span>\r\n\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Inorder sequence is : &quot;</span>;\r\n        operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">printInorder</span>(\r\n            root);  <span class=\"hljs-comment\">///&lt; Printing inorder to cross-verify.</span>\r\n        std::cout &lt;&lt; std::endl;\r\n\r\n        operations_on_datastructures::inorder_traversal_of_bst::Node\r\n            *inorderSuccessor = operations_on_datastructures::\r\n                inorder_traversal_of_bst::<span class=\"hljs-built_in\">getInorderSuccessor</span>(\r\n                    root, <span class=\"hljs-number\">20</span>);  <span class=\"hljs-comment\">///&lt; The inorder successor node for given data</span>\r\n\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Checking assert expression...&quot;</span>);\r\n        <span class=\"hljs-built_in\">assert</span>(inorderSuccessor-&gt;data == expectedOutput);\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Assertion check passed!&quot;</span>);\r\n\r\n        operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">deallocate</span>(\r\n            root);  <span class=\"hljs-comment\">/// memory cleanup!</span>\r\n\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;[PASS] : TEST CASE 2 PASS!&quot;</span>);\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;</span>);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief A test case which contains main list of 50 elements and sublist\r\n     * of 20.\r\n     * @returns void\r\n     * */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">testCase_3</span><span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> expectedOutput = <span class=\"hljs-number\">110</span>;  <span class=\"hljs-comment\">///&lt; Expected output of this test</span>\r\n\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;</span>);\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;This is test case 3 : &quot;</span>);\r\n\r\n        operations_on_datastructures::inorder_traversal_of_bst::Node *root =\r\n            <span class=\"hljs-literal\">nullptr</span>;\r\n        std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; node_data{\r\n            <span class=\"hljs-number\">89</span>,  <span class=\"hljs-number\">67</span>,  <span class=\"hljs-number\">32</span>, <span class=\"hljs-number\">56</span>, <span class=\"hljs-number\">90</span>, <span class=\"hljs-number\">123</span>, <span class=\"hljs-number\">120</span>,\r\n            <span class=\"hljs-number\">110</span>, <span class=\"hljs-number\">115</span>, <span class=\"hljs-number\">6</span>,  <span class=\"hljs-number\">78</span>, <span class=\"hljs-number\">7</span>,  <span class=\"hljs-number\">10</span>};  <span class=\"hljs-comment\">///&lt; Data to make nodes in BST</span>\r\n\r\n        root = operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">makeBST</span>(\r\n            root,\r\n            node_data);  <span class=\"hljs-comment\">///&lt; Adding nodes to BST</span>\r\n\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Inorder sequence is : &quot;</span>;\r\n        operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">printInorder</span>(\r\n            root);  <span class=\"hljs-comment\">///&lt; Printing inorder to cross-verify.</span>\r\n        std::cout &lt;&lt; std::endl;\r\n\r\n        operations_on_datastructures::inorder_traversal_of_bst::Node\r\n            *inorderSuccessor = operations_on_datastructures::\r\n                inorder_traversal_of_bst::<span class=\"hljs-built_in\">getInorderSuccessor</span>(\r\n                    root, <span class=\"hljs-number\">90</span>);  <span class=\"hljs-comment\">///&lt; The inorder successor node for given data</span>\r\n\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Checking assert expression...&quot;</span>);\r\n        <span class=\"hljs-built_in\">assert</span>(inorderSuccessor-&gt;data == expectedOutput);\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Assertion check passed!&quot;</span>);\r\n\r\n        operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">deallocate</span>(\r\n            root);  <span class=\"hljs-comment\">/// memory cleanup!</span>\r\n\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;[PASS] : TEST CASE 3 PASS!&quot;</span>);\r\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;</span>);\r\n    }\r\n};\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Self-test implementations\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\r\n    TestCases tc;\r\n    tc.<span class=\"hljs-built_in\">runTests</span>();\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @param argc commandline argument count (ignored)\r\n * @param argv commandline array of arguments (ignored)\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span> </span>{\r\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// run self-test implementations</span>\r\n\r\n    operations_on_datastructures::inorder_traversal_of_bst::Node *root =\r\n        <span class=\"hljs-literal\">nullptr</span>;  <span class=\"hljs-comment\">///&lt; root node of the bst</span>\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; node_data{<span class=\"hljs-number\">3</span>,  <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>,\r\n                                   <span class=\"hljs-number\">89</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>};  <span class=\"hljs-comment\">///&lt; Data to add nodes in BST</span>\r\n\r\n    <span class=\"hljs-type\">int64_t</span> targetElement = <span class=\"hljs-number\">4</span>;  <span class=\"hljs-comment\">///&lt; An element to find inorder successor for.</span>\r\n    root = operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">makeBST</span>(\r\n        root, node_data);  <span class=\"hljs-comment\">///&lt; Making BST</span>\r\n\r\n    operations_on_datastructures::inorder_traversal_of_bst::Node\r\n        *inorderSuccessor = operations_on_datastructures::\r\n            inorder_traversal_of_bst::<span class=\"hljs-built_in\">getInorderSuccessor</span>(root, targetElement);\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;In-order sequence is : &quot;</span>;\r\n    operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">printInorder</span>(root);\r\n    std::cout &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-keyword\">if</span> (inorderSuccessor == <span class=\"hljs-literal\">nullptr</span>) {\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Inorder successor for last node is NULL&quot;</span> &lt;&lt; std::endl;\r\n    } <span class=\"hljs-keyword\">else</span> {\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Target element is : &quot;</span> &lt;&lt; targetElement &lt;&lt; std::endl;\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Inorder successor for target element is : &quot;</span>\r\n                  &lt;&lt; inorderSuccessor-&gt;data &lt;&lt; std::endl;\r\n    }\r\n\r\n    <span class=\"hljs-built_in\">deallocate</span>(root);  <span class=\"hljs-comment\">/// memory cleanup!</span>\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Nitin Sharma",
      "email": "32377892+foo290@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}