{
  "slug": "bst-recursive",
  "name": "BST Recursive",
  "categories": [
    "datastructures",
    "tree"
  ],
  "body": {},
  "implementations": {
    "java": {
      "dir": "src\\main\\java\\com\\thealgorithms\\datastructures\\trees\\BSTRecursive.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src\\main\\java\\com\\thealgorithms\\datastructures\\trees\\BSTRecursive.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.datastructures.trees;\r\n\r\n<span class=\"hljs-comment\">/**\r\n *\r\n *\r\n * &lt;h1&gt;Binary Search Tree (Recursive)&lt;/h1&gt;\r\n *\r\n * An implementation of BST recursively. In recursive implementation the checks\r\n * are down the tree First root is checked if not found then its childs are\r\n * checked Binary Search Tree is a binary tree which satisfies three properties:\r\n * left child is less than root node, right child is grater than root node, both\r\n * left and right childs must themselves be a BST.\r\n *\r\n * &lt;p&gt;\r\n * I have made public functions as methods and to actually implement recursive\r\n * approach I have used private methods\r\n *\r\n * <span class=\"hljs-doctag\">@author</span> [Lakhan Nad](https://github.com/Lakhan-Nad)\r\n */</span>\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BSTRecursive</span> {\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * only data member is root of BST\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> Node root;\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Constructor use to initialize node as null\r\n     */</span>\r\n    BSTRecursive() {\r\n        root = <span class=\"hljs-literal\">null</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * main function for tests\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\r\n        <span class=\"hljs-type\">BSTRecursive</span> <span class=\"hljs-variable\">tree</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BSTRecursive</span>();\r\n        tree.add(<span class=\"hljs-number\">5</span>);\r\n        tree.add(<span class=\"hljs-number\">10</span>);\r\n        tree.add(<span class=\"hljs-number\">9</span>);\r\n        <span class=\"hljs-keyword\">assert</span> !tree.find(<span class=\"hljs-number\">4</span>) : <span class=\"hljs-string\">&quot;4 is not yet present in BST&quot;</span>;\r\n        <span class=\"hljs-keyword\">assert</span> tree.find(<span class=\"hljs-number\">10</span>) : <span class=\"hljs-string\">&quot;10 should be present in BST&quot;</span>;\r\n        tree.remove(<span class=\"hljs-number\">9</span>);\r\n        <span class=\"hljs-keyword\">assert</span> !tree.find(<span class=\"hljs-number\">9</span>) : <span class=\"hljs-string\">&quot;9 was just deleted from BST&quot;</span>;\r\n        tree.remove(<span class=\"hljs-number\">1</span>);\r\n        <span class=\"hljs-keyword\">assert</span> !tree.find(<span class=\"hljs-number\">1</span>) : <span class=\"hljs-string\">&quot;Since 1 was not present so find deleting would do no change&quot;</span>;\r\n        tree.add(<span class=\"hljs-number\">20</span>);\r\n        tree.add(<span class=\"hljs-number\">70</span>);\r\n        <span class=\"hljs-keyword\">assert</span> tree.find(<span class=\"hljs-number\">70</span>) : <span class=\"hljs-string\">&quot;70 was inserted but not found&quot;</span>;\r\n        <span class=\"hljs-comment\">/*\r\n     Will print in following order\r\n     5 10 20 70\r\n         */</span>\r\n        tree.inorder();\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Recursive method to delete a data if present in BST.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> node the current node to search for data\r\n     * <span class=\"hljs-doctag\">@param</span> data the value to be deleted\r\n     * <span class=\"hljs-doctag\">@return</span> Node the updated value of root parameter after delete operation\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> Node <span class=\"hljs-title function_\">delete</span><span class=\"hljs-params\">(Node node, <span class=\"hljs-type\">int</span> data)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-literal\">null</span>) {\r\n            System.out.println(<span class=\"hljs-string\">&quot;No such data present in BST.&quot;</span>);\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.data &gt; data) {\r\n            node.left = delete(node.left, data);\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.data &lt; data) {\r\n            node.right = delete(node.right, data);\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            <span class=\"hljs-keyword\">if</span> (node.right == <span class=\"hljs-literal\">null</span> &amp;&amp; node.left == <span class=\"hljs-literal\">null</span>) { <span class=\"hljs-comment\">// If it is leaf node</span>\r\n                node = <span class=\"hljs-literal\">null</span>;\r\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.left == <span class=\"hljs-literal\">null</span>) { <span class=\"hljs-comment\">// If only right node is present</span>\r\n                <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> node.right;\r\n                node.right = <span class=\"hljs-literal\">null</span>;\r\n                node = temp;\r\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.right == <span class=\"hljs-literal\">null</span>) { <span class=\"hljs-comment\">// Only left node is present</span>\r\n                <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> node.left;\r\n                node.left = <span class=\"hljs-literal\">null</span>;\r\n                node = temp;\r\n            } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-comment\">// both child are present</span>\r\n                <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> node.right;\r\n                <span class=\"hljs-comment\">// Find leftmost child of right subtree</span>\r\n                <span class=\"hljs-keyword\">while</span> (temp.left != <span class=\"hljs-literal\">null</span>) {\r\n                    temp = temp.left;\r\n                }\r\n                node.data = temp.data;\r\n                node.right = delete(node.right, temp.data);\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> node;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Recursive insertion of value in BST.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> node to check if the data can be inserted in current node or its\r\n     * subtree\r\n     * <span class=\"hljs-doctag\">@param</span> data the value to be inserted\r\n     * <span class=\"hljs-doctag\">@return</span> the modified value of the root parameter after insertion\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> Node <span class=\"hljs-title function_\">insert</span><span class=\"hljs-params\">(Node node, <span class=\"hljs-type\">int</span> data)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-literal\">null</span>) {\r\n            node = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(data);\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.data &gt; data) {\r\n            node.left = insert(node.left, data);\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.data &lt; data) {\r\n            node.right = insert(node.right, data);\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> node;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Recursively print Preorder traversal of the BST\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> node the root node\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">preOrder</span><span class=\"hljs-params\">(Node node)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-literal\">null</span>) {\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        System.out.print(node.data + <span class=\"hljs-string\">&quot; &quot;</span>);\r\n        <span class=\"hljs-keyword\">if</span> (node.left != <span class=\"hljs-literal\">null</span>) {\r\n            preOrder(node.left);\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (node.right != <span class=\"hljs-literal\">null</span>) {\r\n            preOrder(node.right);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Recursively print Postorder travesal of BST.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> node the root node\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">postOrder</span><span class=\"hljs-params\">(Node node)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-literal\">null</span>) {\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (node.left != <span class=\"hljs-literal\">null</span>) {\r\n            postOrder(node.left);\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (node.right != <span class=\"hljs-literal\">null</span>) {\r\n            postOrder(node.right);\r\n        }\r\n        System.out.print(node.data + <span class=\"hljs-string\">&quot; &quot;</span>);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Recursively print Inorder traversal of BST.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> node the root node\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">inOrder</span><span class=\"hljs-params\">(Node node)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-literal\">null</span>) {\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (node.left != <span class=\"hljs-literal\">null</span>) {\r\n            inOrder(node.left);\r\n        }\r\n        System.out.print(node.data + <span class=\"hljs-string\">&quot; &quot;</span>);\r\n        <span class=\"hljs-keyword\">if</span> (node.right != <span class=\"hljs-literal\">null</span>) {\r\n            inOrder(node.right);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Serach recursively if the given value is present in BST or not.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> node the current node to check\r\n     * <span class=\"hljs-doctag\">@param</span> data the value to be checked\r\n     * <span class=\"hljs-doctag\">@return</span> boolean if data is present or not\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">search</span><span class=\"hljs-params\">(Node node, <span class=\"hljs-type\">int</span> data)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-literal\">null</span>) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.data == data) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.data &gt; data) {\r\n            <span class=\"hljs-keyword\">return</span> search(node.left, data);\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            <span class=\"hljs-keyword\">return</span> search(node.right, data);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * add in BST. if the value is not already present it is inserted or else no\r\n     * change takes place.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> data the value to be inserted\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> data)</span> {\r\n        <span class=\"hljs-built_in\">this</span>.root = insert(<span class=\"hljs-built_in\">this</span>.root, data);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * If data is present in BST delete it else do nothing.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> data the value to be removed\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> data)</span> {\r\n        <span class=\"hljs-built_in\">this</span>.root = delete(<span class=\"hljs-built_in\">this</span>.root, data);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * To call inorder traversal on tree\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">inorder</span><span class=\"hljs-params\">()</span> {\r\n        System.out.println(<span class=\"hljs-string\">&quot;Inorder traversal of this tree is:&quot;</span>);\r\n        inOrder(<span class=\"hljs-built_in\">this</span>.root);\r\n        System.out.println(); <span class=\"hljs-comment\">// for next line</span>\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * To call postorder traversal on tree\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">postorder</span><span class=\"hljs-params\">()</span> {\r\n        System.out.println(<span class=\"hljs-string\">&quot;Postorder traversal of this tree is:&quot;</span>);\r\n        postOrder(<span class=\"hljs-built_in\">this</span>.root);\r\n        System.out.println(); <span class=\"hljs-comment\">// for next li</span>\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * To call preorder traversal on tree.\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">preorder</span><span class=\"hljs-params\">()</span> {\r\n        System.out.println(<span class=\"hljs-string\">&quot;Preorder traversal of this tree is:&quot;</span>);\r\n        preOrder(<span class=\"hljs-built_in\">this</span>.root);\r\n        System.out.println(); <span class=\"hljs-comment\">// for next li</span>\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * To check if given value is present in tree or not.\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> data the data to be found for\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> data)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (search(<span class=\"hljs-built_in\">this</span>.root, data)) {\r\n            System.out.println(data + <span class=\"hljs-string\">&quot; is present in given BST.&quot;</span>);\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n        }\r\n        System.out.println(data + <span class=\"hljs-string\">&quot; not found.&quot;</span>);\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * The Node class used for building binary search tree\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span> {\r\n\r\n        <span class=\"hljs-type\">int</span> data;\r\n        Node left;\r\n        Node right;\r\n\r\n        <span class=\"hljs-comment\">/**\r\n         * Constructor with data as parameter\r\n         */</span>\r\n        Node(<span class=\"hljs-type\">int</span> d) {\r\n            data = d;\r\n            left = <span class=\"hljs-literal\">null</span>;\r\n            right = <span class=\"hljs-literal\">null</span>;\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Madhur Panwar",
      "email": "39766613+mdrpanwar@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "lakhan_nad",
      "email": "lakhannad1999@gmail.com",
      "commits": 2
    },
    {
      "name": "Aitor Fidalgo SÃ¡nchez",
      "email": "64830228+aitorfi@users.noreply.github.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}