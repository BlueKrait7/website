{
  "slug": "bom",
  "name": "Bom",
  "categories": [
    "strings"
  ],
  "body": {},
  "implementations": {
    "go": {
      "dir": "strings\\bom\\bom.go",
      "url": "https://github.com/TheAlgorithms/go/tree/master/strings\\bom\\bom.go",
      "code": "<span class=\"hljs-keyword\">package</span> bom\r\n\r\n<span class=\"hljs-comment\">// User defined.</span>\r\n<span class=\"hljs-comment\">// Set to true to print various extra stuff out (slows down the execution)</span>\r\n<span class=\"hljs-comment\">// Set to false for quick and quiet execution.</span>\r\n<span class=\"hljs-comment\">// const debugMode bool = false</span>\r\n\r\n<span class=\"hljs-comment\">// User defined.</span>\r\n<span class=\"hljs-comment\">// Set to true to read input from two command line arguments</span>\r\n<span class=\"hljs-comment\">// Set to false to read input from two files &quot;pattern.txt&quot; and &quot;text.txt&quot;</span>\r\n<span class=\"hljs-comment\">// const commandLineInput bool = false</span>\r\n\r\n<span class=\"hljs-comment\">// Implementation of Backward Oracle Matching algorithm (Factor based approach).</span>\r\n<span class=\"hljs-comment\">// Requires either a two command line arguments separated by a single space,</span>\r\n<span class=\"hljs-comment\">// or two files in the same folder: &quot;pattern.txt&quot; containing the string to</span>\r\n<span class=\"hljs-comment\">// be searched for, &quot;text.txt&quot; containing the text to be searched in.</span>\r\n<span class=\"hljs-comment\">// func main() {</span>\r\n<span class=\"hljs-comment\">// \tif commandLineInput == true { // case of command line input</span>\r\n<span class=\"hljs-comment\">// \t\targs := os.Args</span>\r\n<span class=\"hljs-comment\">// \t\tif len(args) &lt;= 2 {</span>\r\n<span class=\"hljs-comment\">// \t\t\tlog.Fatal(&quot;Not enough arguments. Two string arguments separated by spaces are required!&quot;)</span>\r\n<span class=\"hljs-comment\">// \t\t}</span>\r\n<span class=\"hljs-comment\">// \t\tpattern := args[1]</span>\r\n<span class=\"hljs-comment\">// \t\ts := args[2]</span>\r\n<span class=\"hljs-comment\">// \t\tfor i := 3; i &lt; len(args); i++ {</span>\r\n<span class=\"hljs-comment\">// \t\t\ts = s + &quot; &quot; + args[i]</span>\r\n<span class=\"hljs-comment\">// \t\t}</span>\r\n<span class=\"hljs-comment\">// \t\tif len(args[1]) &gt; len(s) {</span>\r\n<span class=\"hljs-comment\">// \t\t\tlog.Fatal(&quot;Pattern  is longer than text!&quot;)</span>\r\n<span class=\"hljs-comment\">// \t\t}</span>\r\n<span class=\"hljs-comment\">// \t\tif debugMode == true {</span>\r\n<span class=\"hljs-comment\">// \t\t\tfmt.Printf(&quot;\\nRunning: Backward Oracle Matching algorithm.\\n\\n&quot;)</span>\r\n<span class=\"hljs-comment\">// \t\t\tfmt.Printf(&quot;Search word (%d chars long): %q.\\n&quot;, len(args[1]), pattern)</span>\r\n<span class=\"hljs-comment\">// \t\t\tfmt.Printf(&quot;Text        (%d chars long): %q.\\n\\n&quot;, len(s), s)</span>\r\n<span class=\"hljs-comment\">// \t\t} else {</span>\r\n<span class=\"hljs-comment\">// \t\t\tfmt.Printf(&quot;\\nRunning: Backward Oracle Matching algorithm.\\n\\n&quot;)</span>\r\n<span class=\"hljs-comment\">// \t\t}</span>\r\n<span class=\"hljs-comment\">// \t\tbom(s, pattern)</span>\r\n<span class=\"hljs-comment\">// \t} else if commandLineInput == false { // case of file line input</span>\r\n<span class=\"hljs-comment\">// \t\tpatFile, err := ioutil.ReadFile(&quot;pattern.txt&quot;)</span>\r\n<span class=\"hljs-comment\">// \t\tif err != nil {</span>\r\n<span class=\"hljs-comment\">// \t\t\tlog.Fatal(err)</span>\r\n<span class=\"hljs-comment\">// \t\t}</span>\r\n<span class=\"hljs-comment\">// \t\ttextFile, err := ioutil.ReadFile(&quot;text.txt&quot;)</span>\r\n<span class=\"hljs-comment\">// \t\tif err != nil {</span>\r\n<span class=\"hljs-comment\">// \t\t\tlog.Fatal(err)</span>\r\n<span class=\"hljs-comment\">// \t\t}</span>\r\n<span class=\"hljs-comment\">// \t\tif len(patFile) &gt; len(textFile) {</span>\r\n<span class=\"hljs-comment\">// \t\t\tlog.Fatal(&quot;Pattern  is longer than text!&quot;)</span>\r\n<span class=\"hljs-comment\">// \t\t}</span>\r\n<span class=\"hljs-comment\">// \t\tif debugMode == true {</span>\r\n<span class=\"hljs-comment\">// \t\t\tfmt.Printf(&quot;\\nRunning: Backward Oracle Matching algorithm.\\n\\n&quot;)</span>\r\n<span class=\"hljs-comment\">// \t\t\tfmt.Printf(&quot;Search word (%d chars long): %q.\\n&quot;, len(patFile), patFile)</span>\r\n<span class=\"hljs-comment\">// \t\t\tfmt.Printf(&quot;Text        (%d chars long): %q.\\n\\n&quot;, len(textFile), textFile)</span>\r\n<span class=\"hljs-comment\">// \t\t} else {</span>\r\n<span class=\"hljs-comment\">// \t\t\tfmt.Printf(&quot;\\nRunning: Backward Oracle Matching algorithm.\\n\\n&quot;)</span>\r\n<span class=\"hljs-comment\">// \t\t}</span>\r\n<span class=\"hljs-comment\">// \t\tbom(string(textFile), string(patFile))</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// }</span>\r\n\r\n<span class=\"hljs-comment\">// // Function bom performing the Backward Oracle Matching algorithm.</span>\r\n<span class=\"hljs-comment\">// // Prints whether the word/pattern was found + positions of possible multiple occurrences</span>\r\n<span class=\"hljs-comment\">// // or that the word was not found.</span>\r\n<span class=\"hljs-comment\">// func bom(t, p string) {</span>\r\n<span class=\"hljs-comment\">// \tstartTime := time.Now()</span>\r\n<span class=\"hljs-comment\">// \tn, m := len(t), len(p)</span>\r\n<span class=\"hljs-comment\">// \tvar current, j, pos int</span>\r\n<span class=\"hljs-comment\">// \toracle := oracleOnLine(reverse(p))</span>\r\n<span class=\"hljs-comment\">// \toccurrences := make([]int, len(t))</span>\r\n<span class=\"hljs-comment\">// \tcurrentOcc := 0</span>\r\n<span class=\"hljs-comment\">// \tpos = 0</span>\r\n<span class=\"hljs-comment\">// \tif debugMode == true {</span>\r\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;\\n\\nWe are reading backwards in %q, searching for %q\\n\\nat position %d:\\n&quot;, t, p, pos+m-1)</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// \tfor pos &lt;= n-m {</span>\r\n<span class=\"hljs-comment\">// \t\tcurrent = 0 //initial state of the oracle</span>\r\n<span class=\"hljs-comment\">// \t\tj = m</span>\r\n<span class=\"hljs-comment\">// \t\tfor j &gt; 0 &amp;&amp; stateExists(current, oracle) {</span>\r\n<span class=\"hljs-comment\">// \t\t\tif debugMode == true {</span>\r\n<span class=\"hljs-comment\">// \t\t\t\tprettyPrint(current, j, n, pos, t, oracle)</span>\r\n<span class=\"hljs-comment\">// \t\t\t}</span>\r\n<span class=\"hljs-comment\">// \t\t\tcurrent = getTransition(current, t[pos+j-1], oracle)</span>\r\n<span class=\"hljs-comment\">// \t\t\tj--</span>\r\n<span class=\"hljs-comment\">// \t\t}</span>\r\n<span class=\"hljs-comment\">// \t\tif stateExists(current, oracle) {</span>\r\n<span class=\"hljs-comment\">// \t\t\tif debugMode == true {</span>\r\n<span class=\"hljs-comment\">// \t\t\t\tfmt.Printf(&quot; We got an occurrence!&quot;)</span>\r\n<span class=\"hljs-comment\">// \t\t\t}</span>\r\n<span class=\"hljs-comment\">// \t\t\toccurrences[currentOcc] = pos</span>\r\n<span class=\"hljs-comment\">// \t\t\tcurrentOcc++</span>\r\n<span class=\"hljs-comment\">// \t\t}</span>\r\n<span class=\"hljs-comment\">// \t\tpos = pos + j + 1</span>\r\n<span class=\"hljs-comment\">// \t\tif pos+m-1 &lt; len(t) {</span>\r\n<span class=\"hljs-comment\">// \t\t\tif debugMode == true {</span>\r\n<span class=\"hljs-comment\">// \t\t\t\tfmt.Printf(&quot;\\n\\nposition %d:\\n&quot;, pos+m-1)</span>\r\n<span class=\"hljs-comment\">// \t\t\t}</span>\r\n<span class=\"hljs-comment\">// \t\t}</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// \telapsed := time.Since(startTime)</span>\r\n<span class=\"hljs-comment\">// \tfmt.Printf(&quot;\\n\\nElapsed %f secs\\n&quot;, elapsed.Seconds())</span>\r\n<span class=\"hljs-comment\">// \tfmt.Printf(&quot;\\n\\n&quot;)</span>\r\n<span class=\"hljs-comment\">// \tif currentOcc &gt; 0 {</span>\r\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;Word %q was found %d times at positions: &quot;, p, currentOcc)</span>\r\n<span class=\"hljs-comment\">// \t\tfor k := 0; k &lt; currentOcc-1; k++ {</span>\r\n<span class=\"hljs-comment\">// \t\t\tfmt.Printf(&quot;%d, &quot;, occurrences[k])</span>\r\n<span class=\"hljs-comment\">// \t\t}</span>\r\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;%d&quot;, occurrences[currentOcc-1])</span>\r\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;.\\n&quot;)</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// \tif currentOcc == 0 {</span>\r\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;\\nWord was not found.\\n&quot;)</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// \treturn</span>\r\n<span class=\"hljs-comment\">// }</span>\r\n\r\n<span class=\"hljs-comment\">// // Construction of the factor oracle automaton for a word p.</span>\r\n<span class=\"hljs-comment\">// func oracleOnLine(p string) (oracle map[int]map[uint8]int) {</span>\r\n<span class=\"hljs-comment\">// \tif debugMode == true {</span>\r\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;Oracle construction: \\n&quot;)</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// \toracle = make(map[int]map[uint8]int)</span>\r\n<span class=\"hljs-comment\">// \tsupply := make([]int, len(p)+2) // supply function</span>\r\n<span class=\"hljs-comment\">// \tcreateNewState(0, oracle)</span>\r\n<span class=\"hljs-comment\">// \tsupply[0] = -1</span>\r\n<span class=\"hljs-comment\">// \tvar orP string</span>\r\n<span class=\"hljs-comment\">// \tfor j := 0; j &lt; len(p); j++ {</span>\r\n<span class=\"hljs-comment\">// \t\toracle, orP = oracleAddLetter(oracle, supply, orP, p[j])</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// \treturn oracle</span>\r\n<span class=\"hljs-comment\">// }</span>\r\n\r\n<span class=\"hljs-comment\">// // Adds one letter to the oracle.</span>\r\n<span class=\"hljs-comment\">// func oracleAddLetter(oracle map[int]map[uint8]int, supply []int, orP string, o uint8) (oracleToReturn map[int]map[uint8]int, orPToReturn string) {</span>\r\n<span class=\"hljs-comment\">// \tm := len(orP)</span>\r\n<span class=\"hljs-comment\">// \tvar s int</span>\r\n<span class=\"hljs-comment\">// \tcreateNewState(m+1, oracle)</span>\r\n<span class=\"hljs-comment\">// \tcreateTransition(m, o, m+1, oracle)</span>\r\n<span class=\"hljs-comment\">// \tk := supply[m]</span>\r\n<span class=\"hljs-comment\">// \tfor k &gt; -1 &amp;&amp; getTransition(k, o, oracle) == -1 {</span>\r\n<span class=\"hljs-comment\">// \t\tcreateTransition(k, o, m+1, oracle)</span>\r\n<span class=\"hljs-comment\">// \t\tk = supply[k]</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// \tif k == -1 {</span>\r\n<span class=\"hljs-comment\">// \t\ts = 0</span>\r\n<span class=\"hljs-comment\">// \t} else {</span>\r\n<span class=\"hljs-comment\">// \t\ts = getTransition(k, o, oracle)</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// \tsupply[m+1] = s</span>\r\n<span class=\"hljs-comment\">// \treturn oracle, orP + string(o)</span>\r\n<span class=\"hljs-comment\">// }</span>\r\n\r\n<span class=\"hljs-comment\">// // Function that takes a single string and reverses it.</span>\r\n<span class=\"hljs-comment\">// // @author &#x27;Walter&#x27; http://stackoverflow.com/a/10043083</span>\r\n<span class=\"hljs-comment\">// func reverse(s string) string {</span>\r\n<span class=\"hljs-comment\">// \tl := len(s)</span>\r\n<span class=\"hljs-comment\">// \tm := make([]rune, l)</span>\r\n<span class=\"hljs-comment\">// \tfor _, c := range s {</span>\r\n<span class=\"hljs-comment\">// \t\tl--</span>\r\n<span class=\"hljs-comment\">// \t\tm[l] = c</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// \treturn string(m)</span>\r\n<span class=\"hljs-comment\">// }</span>\r\n\r\n<span class=\"hljs-comment\">// // Automaton function for creating a new state.</span>\r\n<span class=\"hljs-comment\">// func createNewState(state int, at map[int]map[uint8]int) {</span>\r\n<span class=\"hljs-comment\">// \tat[state] = make(map[uint8]int)</span>\r\n<span class=\"hljs-comment\">// \tif debugMode == true {</span>\r\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;\\ncreated state %d&quot;, state)</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// }</span>\r\n\r\n<span class=\"hljs-comment\">// // Creates a transition for function σ(state,letter) = end.</span>\r\n<span class=\"hljs-comment\">// func createTransition(fromState int, overChar uint8, toState int, at map[int]map[uint8]int) {</span>\r\n<span class=\"hljs-comment\">// \tat[fromState][overChar] = toState</span>\r\n<span class=\"hljs-comment\">// \tif debugMode == true {</span>\r\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;\\n    σ(%d,%c)=%d;&quot;, fromState, overChar, toState)</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// }</span>\r\n\r\n<span class=\"hljs-comment\">// // Returns ending state for transition σ(fromState,overChar), -1 if there is none.</span>\r\n<span class=\"hljs-comment\">// func getTransition(fromState int, overChar uint8, at map[int]map[uint8]int) (toState int) {</span>\r\n<span class=\"hljs-comment\">// \tif !stateExists(fromState, at) {</span>\r\n<span class=\"hljs-comment\">// \t\treturn -1</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// \ttoState, ok := at[fromState][overChar]</span>\r\n<span class=\"hljs-comment\">// \tif ok == false {</span>\r\n<span class=\"hljs-comment\">// \t\treturn -1</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// \treturn toState</span>\r\n<span class=\"hljs-comment\">// }</span>\r\n\r\n<span class=\"hljs-comment\">// // Checks if state exists. Returns true if it does, false otherwise.</span>\r\n<span class=\"hljs-comment\">// func stateExists(state int, at map[int]map[uint8]int) bool {</span>\r\n<span class=\"hljs-comment\">// \t_, ok := at[state]</span>\r\n<span class=\"hljs-comment\">// \tif !ok || state == -1 || at[state] == nil {</span>\r\n<span class=\"hljs-comment\">// \t\treturn false</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// \treturn true</span>\r\n<span class=\"hljs-comment\">// }</span>\r\n\r\n<span class=\"hljs-comment\">// // Just some printing of extra information about what the algorithm does.</span>\r\n<span class=\"hljs-comment\">// func prettyPrint(current int, j int, n int, pos int, t string, oracle map[int]map[uint8]int) {</span>\r\n<span class=\"hljs-comment\">// \tif current == 0 &amp;&amp; !(getTransition(current, t[pos+j-1], oracle) == -1) {</span>\r\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;\\n --&gt;(%d)---(%c)---&gt;(%d)&quot;, current, t[pos+j-1], getTransition(current, t[pos+j-1], oracle))</span>\r\n<span class=\"hljs-comment\">// \t} else if getTransition(current, t[pos+j-1], oracle) == -1 &amp;&amp; current != 0 {</span>\r\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;\\n    (%d)---(%c)       &quot;, current, t[pos+j-1])</span>\r\n<span class=\"hljs-comment\">// \t} else if getTransition(current, t[pos+j-1], oracle) == -1 &amp;&amp; current == 0 {</span>\r\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;\\n --&gt;(%d)---(%c)       &quot;, current, t[pos+j-1])</span>\r\n<span class=\"hljs-comment\">// \t} else {</span>\r\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;\\n    (%d)---(%c)---&gt;(%d)&quot;, current, t[pos+j-1], getTransition(current, t[pos+j-1], oracle))</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// \tfmt.Printf(&quot; &quot;)</span>\r\n<span class=\"hljs-comment\">// \tfor a := 0; a &lt; pos+j-1; a++ {</span>\r\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;%c&quot;, t[a])</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// \tif getTransition(current, t[pos+j-1], oracle) == -1 {</span>\r\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;[%c]&quot;, t[pos+j-1])</span>\r\n<span class=\"hljs-comment\">// \t} else {</span>\r\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;[%c]&quot;, t[pos+j-1])</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// \tfor a := pos + j; a &lt; n; a++ {</span>\r\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;%c&quot;, t[a])</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// \tif getTransition(current, t[pos+j-1], oracle) == -1 {</span>\r\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot; FAIL on the character[%c]&quot;, t[pos+j-1])</span>\r\n<span class=\"hljs-comment\">// \t}</span>\r\n<span class=\"hljs-comment\">// }</span>\r\n"
    }
  },
  "contributors": [
    {
      "name": "Rak Laptudirm",
      "email": "raklaptudirm@gmail.com",
      "commits": 1
    },
    {
      "name": "halafi",
      "email": "filiphalas74@gmail.com",
      "commits": 1
    },
    {
      "name": "Taj",
      "email": "tjgurwara99@users.noreply.github.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}