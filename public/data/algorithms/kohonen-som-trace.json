{
  "slug": "kohonen-som-trace",
  "name": "Kohonen Som Trace",
  "categories": [
    "machinelearning"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "machine_learning\\kohonen_som_trace.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/machine_learning\\kohonen_som_trace.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * \\addtogroup machine_learning Machine Learning Algorithms\r\n * @{\r\n * \\file\r\n * \\brief [Kohonen self organizing\r\n * map](https://en.wikipedia.org/wiki/Self-organizing_map) (data tracing)\r\n *\r\n * This example implements a powerful self organizing map algorithm.\r\n * The algorithm creates a connected network of weights that closely\r\n * follows the given data points. This this creates a chain of nodes that\r\n * resembles the given input shape.\r\n *\r\n * \\author [Krishna Vedala](https://github.com/kvedala)\r\n *\r\n * \\note This C++ version of the program is considerable slower than its [C\r\n * counterpart](https://github.com/kvedala/C/blob/master/machine_learning/kohonen_som_trace.c)\r\n * \\note The compiled code is much slower when compiled with MS Visual C++ 2019\r\n * than with GCC on windows\r\n * \\see kohonen_som_topology.cpp\r\n */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> _USE_MATH_DEFINES  <span class=\"hljs-comment\">// required for MS Visual C++</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;array&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ctime&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;fstream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;valarray&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP  <span class=\"hljs-comment\">// check if OpenMP based parallellization is available</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;omp.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Helper function to generate a random number in a given interval.\r\n * \\n Steps:\r\n * 1. `r1 = rand() % 100` gets a random number between 0 and 99\r\n * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99\r\n * 3. scale and offset the random number to given range of \\f$[a,b]\\f$\r\n *\r\n * \\param[in] a lower limit\r\n * \\param[in] b upper limit\r\n * \\returns random number in the range \\f$[a,b]\\f$\r\n */</span>\r\n<span class=\"hljs-type\">double</span> _random(<span class=\"hljs-type\">double</span> a, <span class=\"hljs-type\">double</span> b) {\r\n    <span class=\"hljs-keyword\">return</span> ((b - a) * (std::<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span>) / <span class=\"hljs-number\">100.f</span>) + a;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Save a given n-dimensional data martix to file.\r\n *\r\n * \\param[in] fname filename to save in (gets overwriten without confirmation)\r\n * \\param[in] X matrix to save\r\n * \\returns 0 if all ok\r\n * \\returns -1 if file creation failed\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">save_nd_data</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fname,\r\n                 <span class=\"hljs-type\">const</span> std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; &amp;X)</span> </span>{\r\n    <span class=\"hljs-type\">size_t</span> num_points = X.<span class=\"hljs-built_in\">size</span>();       <span class=\"hljs-comment\">// number of rows</span>\r\n    <span class=\"hljs-type\">size_t</span> num_features = X[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>();  <span class=\"hljs-comment\">// number of columns</span>\r\n\r\n    std::ofstream fp;\r\n    fp.<span class=\"hljs-built_in\">open</span>(fname);\r\n    <span class=\"hljs-keyword\">if</span> (!fp.<span class=\"hljs-built_in\">is_open</span>()) {\r\n        <span class=\"hljs-comment\">// error with opening file to write</span>\r\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Error opening file &quot;</span> &lt;&lt; fname &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// for each point in the array</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; num_points; i++) {\r\n        <span class=\"hljs-comment\">// for each feature in the array</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; num_features; j++) {\r\n            fp &lt;&lt; X[i][j];               <span class=\"hljs-comment\">// print the feature value</span>\r\n            <span class=\"hljs-keyword\">if</span> (j &lt; num_features - <span class=\"hljs-number\">1</span>) {  <span class=\"hljs-comment\">// if not the last feature</span>\r\n                fp &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span>;               <span class=\"hljs-comment\">// suffix comma</span>\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_points - <span class=\"hljs-number\">1</span>) {  <span class=\"hljs-comment\">// if not the last row</span>\r\n            fp &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;            <span class=\"hljs-comment\">// start a new line</span>\r\n        }\r\n    }\r\n\r\n    fp.<span class=\"hljs-built_in\">close</span>();\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/** \\namespace machine_learning\r\n * \\brief Machine learning algorithms\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> machine_learning {\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Update weights of the SOM using Kohonen algorithm\r\n *\r\n * \\param[in] X data point\r\n * \\param[in,out] W weights matrix\r\n * \\param[in,out] D temporary vector to store distances\r\n * \\param[in] alpha learning rate \\f$0&lt;\\alpha\\le1\\f$\r\n * \\param[in] R neighborhood range\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">update_weights</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; &amp;x,\r\n                    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *W,\r\n                    std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; *D, <span class=\"hljs-type\">double</span> alpha, <span class=\"hljs-type\">int</span> R)</span> </span>{\r\n    <span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>, k = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">int</span> num_out = W-&gt;<span class=\"hljs-built_in\">size</span>();  <span class=\"hljs-comment\">// number of SOM output nodes</span>\r\n    <span class=\"hljs-comment\">// int num_features = x.size();  // number of data features</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-comment\">// step 1: for each output point</span>\r\n    <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; num_out; j++) {\r\n        <span class=\"hljs-comment\">// compute Euclidian distance of each output</span>\r\n        <span class=\"hljs-comment\">// point from the current sample</span>\r\n        (*D)[j] = (((*W)[j] - x) * ((*W)[j] - x)).<span class=\"hljs-built_in\">sum</span>();\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// step 2:  get closest node i.e., node with snallest Euclidian distance to</span>\r\n    <span class=\"hljs-comment\">// the current pattern</span>\r\n    <span class=\"hljs-keyword\">auto</span> result = std::<span class=\"hljs-built_in\">min_element</span>(std::<span class=\"hljs-built_in\">begin</span>(*D), std::<span class=\"hljs-built_in\">end</span>(*D));\r\n    <span class=\"hljs-comment\">// double d_min = *result;</span>\r\n    <span class=\"hljs-type\">int</span> d_min_idx = std::<span class=\"hljs-built_in\">distance</span>(std::<span class=\"hljs-built_in\">begin</span>(*D), result);\r\n\r\n    <span class=\"hljs-comment\">// step 3a: get the neighborhood range</span>\r\n    <span class=\"hljs-type\">int</span> from_node = std::<span class=\"hljs-built_in\">max</span>(<span class=\"hljs-number\">0</span>, d_min_idx - R);\r\n    <span class=\"hljs-type\">int</span> to_node = std::<span class=\"hljs-built_in\">min</span>(num_out, d_min_idx + R + <span class=\"hljs-number\">1</span>);\r\n\r\n    <span class=\"hljs-comment\">// step 3b: update the weights of nodes in the</span>\r\n    <span class=\"hljs-comment\">// neighborhood</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-keyword\">for</span> (j = from_node; j &lt; to_node; j++) {\r\n        <span class=\"hljs-comment\">// update weights of nodes in the neighborhood</span>\r\n        (*W)[j] += alpha * (x - (*W)[j]);\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Apply incremental algorithm with updating neighborhood and learning rates\r\n * on all samples in the given datset.\r\n *\r\n * \\param[in] X data set\r\n * \\param[in,out] W weights matrix\r\n * \\param[in] alpha_min terminal value of alpha\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">kohonen_som_tracer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; &amp;X,\r\n                        std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *W,\r\n                        <span class=\"hljs-type\">double</span> alpha_min)</span> </span>{\r\n    <span class=\"hljs-type\">int</span> num_samples = X.<span class=\"hljs-built_in\">size</span>();  <span class=\"hljs-comment\">// number of rows</span>\r\n    <span class=\"hljs-comment\">// int num_features = X[0].size();  // number of columns</span>\r\n    <span class=\"hljs-type\">int</span> num_out = W-&gt;<span class=\"hljs-built_in\">size</span>();  <span class=\"hljs-comment\">// number of rows</span>\r\n    <span class=\"hljs-type\">int</span> R = num_out &gt;&gt; <span class=\"hljs-number\">2</span>, iter = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">double</span> alpha = <span class=\"hljs-number\">1.f</span>;\r\n\r\n    <span class=\"hljs-function\">std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">D</span><span class=\"hljs-params\">(num_out)</span></span>;\r\n\r\n    <span class=\"hljs-comment\">// Loop alpha from 1 to slpha_min</span>\r\n    <span class=\"hljs-keyword\">do</span> {\r\n        <span class=\"hljs-comment\">// Loop for each sample pattern in the data set</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> sample = <span class=\"hljs-number\">0</span>; sample &lt; num_samples; sample++) {\r\n            <span class=\"hljs-comment\">// update weights for the current input pattern sample</span>\r\n            <span class=\"hljs-built_in\">update_weights</span>(X[sample], W, &amp;D, alpha, R);\r\n        }\r\n\r\n        <span class=\"hljs-comment\">// every 10th iteration, reduce the neighborhood range</span>\r\n        <span class=\"hljs-keyword\">if</span> (iter % <span class=\"hljs-number\">10</span> == <span class=\"hljs-number\">0</span> &amp;&amp; R &gt; <span class=\"hljs-number\">1</span>) {\r\n            R--;\r\n        }\r\n\r\n        alpha -= <span class=\"hljs-number\">0.01</span>;\r\n        iter++;\r\n    } <span class=\"hljs-keyword\">while</span> (alpha &gt; alpha_min);\r\n}\r\n\r\n}  <span class=\"hljs-comment\">// namespace machine_learning</span>\r\n\r\n<span class=\"hljs-comment\">/** @} */</span>\r\n\r\n<span class=\"hljs-keyword\">using</span> machine_learning::kohonen_som_tracer;\r\n\r\n<span class=\"hljs-comment\">/** Creates a random set of points distributed *near* the circumference\r\n * of a circle and trains an SOM that finds that circular pattern. The\r\n * generating function is\r\n * \\f{eqnarray*}{\r\n * r &amp;\\in&amp; [1-\\delta r, 1+\\delta r)\\\\\r\n * \\theta &amp;\\in&amp; [0, 2\\pi)\\\\\r\n * x &amp;=&amp; r\\cos\\theta\\\\\r\n * y &amp;=&amp; r\\sin\\theta\r\n * \\f}\r\n *\r\n * \\param[out] data matrix to store data in\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_circle</span><span class=\"hljs-params\">(std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *data)</span> </span>{\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N = data-&gt;<span class=\"hljs-built_in\">size</span>();\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.75</span>, dr = <span class=\"hljs-number\">0.3</span>;\r\n    <span class=\"hljs-type\">double</span> <span class=\"hljs-type\">a_t</span> = <span class=\"hljs-number\">0.</span>, <span class=\"hljs-type\">b_t</span> = <span class=\"hljs-number\">2.f</span> * M_PI;  <span class=\"hljs-comment\">// theta random between 0 and 2*pi</span>\r\n    <span class=\"hljs-type\">double</span> a_r = R - dr, b_r = R + dr;  <span class=\"hljs-comment\">// radius random between R-dr and R+dr</span>\r\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\r\n        <span class=\"hljs-type\">double</span> r = _random(a_r, b_r);      <span class=\"hljs-comment\">// random radius</span>\r\n        <span class=\"hljs-type\">double</span> theta = _random(<span class=\"hljs-type\">a_t</span>, <span class=\"hljs-type\">b_t</span>);  <span class=\"hljs-comment\">// random theta</span>\r\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">0</span>] = r * <span class=\"hljs-built_in\">cos</span>(theta);    <span class=\"hljs-comment\">// convert from polar to cartesian</span>\r\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">1</span>] = r * <span class=\"hljs-built_in\">sin</span>(theta);\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed *near* the\r\n * circumference of a circle and trains an SOM that finds that circular pattern.\r\n * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)\r\n * files are created to validate the execution:\r\n * * `test1.csv`: random test samples points with a circular pattern\r\n * * `w11.csv`: initial random map\r\n * * `w12.csv`: trained SOM map\r\n *\r\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\r\n * the following snippet\r\n * ```gnuplot\r\n * set datafile separator &#x27;,&#x27;\r\n * plot &quot;test1.csv&quot; title &quot;original&quot;, \\\r\n *      &quot;w11.csv&quot; title &quot;w1&quot;, \\\r\n *      &quot;w12.csv&quot; title &quot;w2&quot;\r\n * ```\r\n * ![Sample execution\r\n * output](https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/machine_learning/kohonen/test1.svg)\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>, N = <span class=\"hljs-number\">500</span>;\r\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">2</span>;\r\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">50</span>;\r\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">X</span>(N);\r\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">W</span>(num_out);\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; std::<span class=\"hljs-built_in\">max</span>(num_out, N); i++) {\r\n        <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; N) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\r\n            X[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\r\n            W[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n            <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) {\r\n                <span class=\"hljs-comment\">// preallocate with random initial weights</span>\r\n                W[i][j] = _random(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>);\r\n            }\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-built_in\">test_circle</span>(&amp;X);  <span class=\"hljs-comment\">// create test data around circumference of a circle</span>\r\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;test1.csv&quot;</span>, X);    <span class=\"hljs-comment\">// save test data points</span>\r\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;w11.csv&quot;</span>, W);      <span class=\"hljs-comment\">// save initial random weights</span>\r\n    <span class=\"hljs-built_in\">kohonen_som_tracer</span>(X, &amp;W, <span class=\"hljs-number\">0.1</span>);  <span class=\"hljs-comment\">// train the SOM</span>\r\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;w12.csv&quot;</span>, W);      <span class=\"hljs-comment\">// save the resultant weights</span>\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Creates a random set of points distributed *near* the locus\r\n * of the [Lamniscate of\r\n * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono).\r\n * \\f{eqnarray*}{\r\n * \\delta r &amp;=&amp; 0.2\\\\\r\n * \\delta x &amp;\\in&amp; [-\\delta r, \\delta r)\\\\\r\n * \\delta y &amp;\\in&amp; [-\\delta r, \\delta r)\\\\\r\n * \\theta &amp;\\in&amp; [0, \\pi)\\\\\r\n * x &amp;=&amp; \\delta x + \\cos\\theta\\\\\r\n * y &amp;=&amp; \\delta y + \\frac{\\sin(2\\theta)}{2}\r\n * \\f}\r\n * \\param[out] data matrix to store data in\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_lamniscate</span><span class=\"hljs-params\">(std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *data)</span> </span>{\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N = data-&gt;<span class=\"hljs-built_in\">size</span>();\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> dr = <span class=\"hljs-number\">0.2</span>;\r\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\r\n        <span class=\"hljs-type\">double</span> dx = _random(-dr, dr);     <span class=\"hljs-comment\">// random change in x</span>\r\n        <span class=\"hljs-type\">double</span> dy = _random(-dr, dr);     <span class=\"hljs-comment\">// random change in y</span>\r\n        <span class=\"hljs-type\">double</span> theta = _random(<span class=\"hljs-number\">0</span>, M_PI);  <span class=\"hljs-comment\">// random theta</span>\r\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">0</span>] = dx + <span class=\"hljs-built_in\">cos</span>(theta);  <span class=\"hljs-comment\">// convert from polar to cartesian</span>\r\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">1</span>] = dy + <span class=\"hljs-built_in\">sin</span>(<span class=\"hljs-number\">2.</span> * theta) / <span class=\"hljs-number\">2.f</span>;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed *near* the locus\r\n * of the [Lamniscate of\r\n * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono) and trains an SOM\r\n * that finds that circular pattern. The following\r\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\r\n * to validate the execution:\r\n * * `test2.csv`: random test samples points with a lamniscate pattern\r\n * * `w21.csv`: initial random map\r\n * * `w22.csv`: trained SOM map\r\n *\r\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\r\n * the following snippet\r\n * ```gnuplot\r\n * set datafile separator &#x27;,&#x27;\r\n * plot &quot;test2.csv&quot; title &quot;original&quot;, \\\r\n *      &quot;w21.csv&quot; title &quot;w1&quot;, \\\r\n *      &quot;w22.csv&quot; title &quot;w2&quot;\r\n * ```\r\n * ![Sample execution\r\n * output](https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/machine_learning/kohonen/test2.svg)\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>, N = <span class=\"hljs-number\">500</span>;\r\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">2</span>;\r\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">20</span>;\r\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">X</span>(N);\r\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">W</span>(num_out);\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; std::<span class=\"hljs-built_in\">max</span>(num_out, N); i++) {\r\n        <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; N) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\r\n            X[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\r\n            W[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n            <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) {\r\n                <span class=\"hljs-comment\">// preallocate with random initial weights</span>\r\n                W[i][j] = _random(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>);\r\n            }\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-built_in\">test_lamniscate</span>(&amp;X);              <span class=\"hljs-comment\">// create test data around the lamniscate</span>\r\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;test2.csv&quot;</span>, X);     <span class=\"hljs-comment\">// save test data points</span>\r\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;w21.csv&quot;</span>, W);       <span class=\"hljs-comment\">// save initial random weights</span>\r\n    <span class=\"hljs-built_in\">kohonen_som_tracer</span>(X, &amp;W, <span class=\"hljs-number\">0.01</span>);  <span class=\"hljs-comment\">// train the SOM</span>\r\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;w22.csv&quot;</span>, W);       <span class=\"hljs-comment\">// save the resultant weights</span>\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Creates a random set of points distributed in six clusters in\r\n * 3D space with centroids at the points\r\n * * \\f${0.5, 0.5, 0.5}\\f$\r\n * * \\f${0.5, 0.5, -0.5}\\f$\r\n * * \\f${0.5, -0.5, 0.5}\\f$\r\n * * \\f${0.5, -0.5, -0.5}\\f$\r\n * * \\f${-0.5, 0.5, 0.5}\\f$\r\n * * \\f${-0.5, 0.5, -0.5}\\f$\r\n * * \\f${-0.5, -0.5, 0.5}\\f$\r\n * * \\f${-0.5, -0.5, -0.5}\\f$\r\n *\r\n * \\param[out] data matrix to store data in\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_3d_classes</span><span class=\"hljs-params\">(std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *data)</span> </span>{\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N = data-&gt;<span class=\"hljs-built_in\">size</span>();\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.1</span>;  <span class=\"hljs-comment\">// radius of cluster</span>\r\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> num_classes = <span class=\"hljs-number\">8</span>;\r\n    <span class=\"hljs-type\">const</span> std::array&lt;<span class=\"hljs-type\">const</span> std::array&lt;<span class=\"hljs-type\">double</span>, 3&gt;, num_classes&gt; centres = {\r\n        <span class=\"hljs-comment\">// centres of each class cluster</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>}),    <span class=\"hljs-comment\">// centre of class 0</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>}),   <span class=\"hljs-comment\">// centre of class 1</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>}),   <span class=\"hljs-comment\">// centre of class 2</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>}),  <span class=\"hljs-comment\">// centre of class 3</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>}),   <span class=\"hljs-comment\">// centre of class 4</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>}),  <span class=\"hljs-comment\">// centre of class 5</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>}),  <span class=\"hljs-comment\">// centre of class 6</span>\r\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>})  <span class=\"hljs-comment\">// centre of class 7</span>\r\n    };\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\r\n        <span class=\"hljs-type\">int</span> cls =\r\n            std::<span class=\"hljs-built_in\">rand</span>() % num_classes;  <span class=\"hljs-comment\">// select a random class for the point</span>\r\n\r\n        <span class=\"hljs-comment\">// create random coordinates (x,y,z) around the centre of the class</span>\r\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">0</span>] = _random(centres[cls][<span class=\"hljs-number\">0</span>] - R, centres[cls][<span class=\"hljs-number\">0</span>] + R);\r\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">1</span>] = _random(centres[cls][<span class=\"hljs-number\">1</span>] - R, centres[cls][<span class=\"hljs-number\">1</span>] + R);\r\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">2</span>] = _random(centres[cls][<span class=\"hljs-number\">2</span>] - R, centres[cls][<span class=\"hljs-number\">2</span>] + R);\r\n\r\n        <span class=\"hljs-comment\">/* The follosing can also be used\r\n        for (int j = 0; j &lt; 3; j++)\r\n            data[0][i][j] = _random(centres[cls][j] - R, centres[cls][j] + R);\r\n        */</span>\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed in six clusters in\r\n * 3D space. The following\r\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\r\n * to validate the execution:\r\n * * `test3.csv`: random test samples points with a circular pattern\r\n * * `w31.csv`: initial random map\r\n * * `w32.csv`: trained SOM map\r\n *\r\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\r\n * the following snippet\r\n * ```gnuplot\r\n * set datafile separator &#x27;,&#x27;\r\n * plot &quot;test3.csv&quot; title &quot;original&quot;, \\\r\n *      &quot;w31.csv&quot; title &quot;w1&quot;, \\\r\n *      &quot;w32.csv&quot; title &quot;w2&quot;\r\n * ```\r\n * ![Sample execution\r\n * output](https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/machine_learning/kohonen/test3.svg)\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test3</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>, N = <span class=\"hljs-number\">200</span>;\r\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">3</span>;\r\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">20</span>;\r\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">X</span>(N);\r\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">W</span>(num_out);\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; std::<span class=\"hljs-built_in\">max</span>(num_out, N); i++) {\r\n        <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; N) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\r\n            X[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\r\n            W[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n            <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) {\r\n                <span class=\"hljs-comment\">// preallocate with random initial weights</span>\r\n                W[i][j] = _random(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>);\r\n            }\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-built_in\">test_3d_classes</span>(&amp;X);              <span class=\"hljs-comment\">// create test data around the lamniscate</span>\r\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;test3.csv&quot;</span>, X);     <span class=\"hljs-comment\">// save test data points</span>\r\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;w31.csv&quot;</span>, W);       <span class=\"hljs-comment\">// save initial random weights</span>\r\n    <span class=\"hljs-built_in\">kohonen_som_tracer</span>(X, &amp;W, <span class=\"hljs-number\">0.01</span>);  <span class=\"hljs-comment\">// train the SOM</span>\r\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;w32.csv&quot;</span>, W);       <span class=\"hljs-comment\">// save the resultant weights</span>\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Convert clock cycle difference to time in seconds\r\n *\r\n * \\param[in] start_t start clock\r\n * \\param[in] end_t end clock\r\n * \\returns time difference in seconds\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">get_clock_diff</span><span class=\"hljs-params\">(<span class=\"hljs-type\">clock_t</span> <span class=\"hljs-type\">start_t</span>, <span class=\"hljs-type\">clock_t</span> <span class=\"hljs-type\">end_t</span>)</span> </span>{\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(<span class=\"hljs-type\">end_t</span> - <span class=\"hljs-type\">start_t</span>) / CLOCKS_PER_SEC;\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Main function */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span> </span>{\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Using OpenMP based parallelization\\n&quot;</span>;\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;NOT using OpenMP based parallelization\\n&quot;</span>;\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n\r\n    std::<span class=\"hljs-built_in\">srand</span>(std::<span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">nullptr</span>));\r\n\r\n    std::<span class=\"hljs-type\">clock_t</span> start_clk = std::<span class=\"hljs-built_in\">clock</span>();\r\n    <span class=\"hljs-built_in\">test1</span>();\r\n    <span class=\"hljs-keyword\">auto</span> end_clk = std::<span class=\"hljs-built_in\">clock</span>();\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1 completed in &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">get_clock_diff</span>(start_clk, end_clk)\r\n              &lt;&lt; <span class=\"hljs-string\">&quot; sec\\n&quot;</span>;\r\n\r\n    start_clk = std::<span class=\"hljs-built_in\">clock</span>();\r\n    <span class=\"hljs-built_in\">test2</span>();\r\n    end_clk = std::<span class=\"hljs-built_in\">clock</span>();\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2 completed in &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">get_clock_diff</span>(start_clk, end_clk)\r\n              &lt;&lt; <span class=\"hljs-string\">&quot; sec\\n&quot;</span>;\r\n\r\n    start_clk = std::<span class=\"hljs-built_in\">clock</span>();\r\n    <span class=\"hljs-built_in\">test3</span>();\r\n    end_clk = std::<span class=\"hljs-built_in\">clock</span>();\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 3 completed in &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">get_clock_diff</span>(start_clk, end_clk)\r\n              &lt;&lt; <span class=\"hljs-string\">&quot; sec\\n&quot;</span>;\r\n\r\n    std::cout\r\n        &lt;&lt; <span class=\"hljs-string\">&quot;(Note: Calculated times include: creating test sets, training &quot;</span>\r\n           <span class=\"hljs-string\">&quot;model and writing files to disk.)\\n\\n&quot;</span>;\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    },
    "c": {
      "dir": "machine_learning\\kohonen_som_trace.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/machine_learning\\kohonen_som_trace.c",
      "code": "<span class=\"hljs-comment\">/**\r\n * \\file\r\n * \\brief [Kohonen self organizing\r\n * map](https://en.wikipedia.org/wiki/Self-organizing_map) (data tracing)\r\n *\r\n * \\details\r\n * This example implements a powerful self organizing map algorithm.\r\n * The algorithm creates a connected network of weights that closely\r\n * follows the given data points. This this creates a chain of nodes that\r\n * resembles the given input shape.\r\n * \\author [Krishna Vedala](https://github.com/kvedala)\r\n * \\see kohonen_som_topology.c\r\n */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> _USE_MATH_DEFINES <span class=\"hljs-comment\">/**&lt; required for MS Visual C */</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;math.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;time.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP  <span class=\"hljs-comment\">// check if OpenMP based parallelization is available</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;omp.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @addtogroup machine_learning Machine learning algorithms\r\n * @{\r\n * @addtogroup kohonen_1d Kohonen SOM trace/chain algorithm\r\n * @{\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> max</span>\r\n<span class=\"hljs-comment\">/** shorthand for maximum value */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> max(a, b) (((a) &gt; (b)) ? (a) : (b))</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> min</span>\r\n<span class=\"hljs-comment\">/** shorthand for minimum value */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> min(a, b) (((a) &lt; (b)) ? (a) : (b))</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * \\brief Helper function to generate a random number in a given interval.\r\n * \\details\r\n * \\n Steps:\r\n * 1. `r1 = rand() % 100` gets a random number between 0 and 99\r\n * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99\r\n * 3. scale and offset the random number to given range of \\f$[a,b)\\f$\r\n * \\f[\r\n * y = (b - a) \\times \\frac{\\text{(random number between 0 and RAND_MAX)} \\;\r\n * \\text{mod}\\; 100}{100} + a \\f]\r\n *\r\n * \\param a lower limit\r\n * \\param b upper limit\r\n * \\returns random number in the range \\f$[a,b)\\f$\r\n */</span>\r\n<span class=\"hljs-type\">double</span> _random(<span class=\"hljs-type\">double</span> a, <span class=\"hljs-type\">double</span> b)\r\n{\r\n    <span class=\"hljs-type\">int</span> r = rand() % <span class=\"hljs-number\">100</span>;\r\n    <span class=\"hljs-keyword\">return</span> ((b - a) * r / <span class=\"hljs-number\">100.f</span>) + a;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Save a given n-dimensional data martix to file.\r\n *\r\n * \\param [in] fname filename to save in (gets overwriten without confirmation)\r\n * \\param [in] X matrix to save\r\n * \\param [in] num_points rows in the matrix = number of points\r\n * \\param [in] num_features columns in the matrix = dimensions of points\r\n * \\returns 0 if all ok\r\n * \\returns -1 if file creation failed\r\n */</span>\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">save_nd_data</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fname, <span class=\"hljs-type\">double</span> **X, <span class=\"hljs-type\">int</span> num_points,\r\n                 <span class=\"hljs-type\">int</span> num_features)</span>\r\n{\r\n    FILE *fp = fopen(fname, <span class=\"hljs-string\">&quot;wt&quot;</span>);\r\n    <span class=\"hljs-keyword\">if</span> (!fp)  <span class=\"hljs-comment\">// error with fopen</span>\r\n    {\r\n        <span class=\"hljs-type\">char</span> msg[<span class=\"hljs-number\">120</span>];\r\n        <span class=\"hljs-built_in\">sprintf</span>(msg, <span class=\"hljs-string\">&quot;File error (%s): &quot;</span>, fname);\r\n        perror(msg);\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; num_points; i++)  <span class=\"hljs-comment\">// for each point in the array</span>\r\n    {\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; num_features; j++)  <span class=\"hljs-comment\">// for each feature in the array</span>\r\n        {\r\n            <span class=\"hljs-built_in\">fprintf</span>(fp, <span class=\"hljs-string\">&quot;%.4g&quot;</span>, X[i][j]);  <span class=\"hljs-comment\">// print the feature value</span>\r\n            <span class=\"hljs-keyword\">if</span> (j &lt; num_features - <span class=\"hljs-number\">1</span>)      <span class=\"hljs-comment\">// if not the last feature</span>\r\n                <span class=\"hljs-built_in\">fprintf</span>(fp, <span class=\"hljs-string\">&quot;,&quot;</span>);          <span class=\"hljs-comment\">// suffix comma</span>\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_points - <span class=\"hljs-number\">1</span>)  <span class=\"hljs-comment\">// if not the last row</span>\r\n            <span class=\"hljs-built_in\">fprintf</span>(fp, <span class=\"hljs-string\">&quot;\\n&quot;</span>);   <span class=\"hljs-comment\">// start a new line</span>\r\n    }\r\n    fclose(fp);\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Get minimum value and index of the value in a vector\r\n * \\param[in] X vector to search\r\n * \\param[in] N number of points in the vector\r\n * \\param[out] val minimum value found\r\n * \\param[out] idx index where minimum value was found\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">kohonen_get_min_1d</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> <span class=\"hljs-type\">const</span> *X, <span class=\"hljs-type\">int</span> N, <span class=\"hljs-type\">double</span> *val, <span class=\"hljs-type\">int</span> *idx)</span>\r\n{\r\n    val[<span class=\"hljs-number\">0</span>] = INFINITY;  <span class=\"hljs-comment\">// initial min value</span>\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)  <span class=\"hljs-comment\">// check each value</span>\r\n    {\r\n        <span class=\"hljs-keyword\">if</span> (X[i] &lt; val[<span class=\"hljs-number\">0</span>])  <span class=\"hljs-comment\">// if a lower value is found</span>\r\n        {                   <span class=\"hljs-comment\">// save the value and its index</span>\r\n            idx[<span class=\"hljs-number\">0</span>] = i;\r\n            val[<span class=\"hljs-number\">0</span>] = X[i];\r\n        }\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Update weights of the SOM using Kohonen algorithm\r\n *\r\n * \\param[in] x data point\r\n * \\param[in,out] W weights matrix\r\n * \\param[in,out] D temporary vector to store distances\r\n * \\param[in] num_out number of output points\r\n * \\param[in] num_features number of features per input sample\r\n * \\param[in] alpha learning rate \\f$0&lt;\\alpha\\le1\\f$\r\n * \\param[in] R neighborhood range\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">kohonen_update_weights</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> <span class=\"hljs-type\">const</span> *x, <span class=\"hljs-type\">double</span> *<span class=\"hljs-type\">const</span> *W, <span class=\"hljs-type\">double</span> *D,\r\n                            <span class=\"hljs-type\">int</span> num_out, <span class=\"hljs-type\">int</span> num_features, <span class=\"hljs-type\">double</span> alpha, <span class=\"hljs-type\">int</span> R)</span>\r\n{\r\n    <span class=\"hljs-type\">int</span> j, k;\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-comment\">// step 1: for each output point</span>\r\n    <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; num_out; j++)\r\n    {\r\n        D[j] = <span class=\"hljs-number\">0.f</span>;\r\n        <span class=\"hljs-comment\">// compute Euclidian distance of each output</span>\r\n        <span class=\"hljs-comment\">// point from the current sample</span>\r\n        <span class=\"hljs-keyword\">for</span> (k = <span class=\"hljs-number\">0</span>; k &lt; num_features; k++)\r\n            D[j] += (W[j][k] - x[k]) * (W[j][k] - x[k]);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// step 2:  get closest node i.e., node with smallest Euclidian distance to</span>\r\n    <span class=\"hljs-comment\">// the current pattern</span>\r\n    <span class=\"hljs-type\">int</span> d_min_idx;\r\n    <span class=\"hljs-type\">double</span> d_min;\r\n    kohonen_get_min_1d(D, num_out, &amp;d_min, &amp;d_min_idx);\r\n\r\n    <span class=\"hljs-comment\">// step 3a: get the neighborhood range</span>\r\n    <span class=\"hljs-type\">int</span> from_node = max(<span class=\"hljs-number\">0</span>, d_min_idx - R);\r\n    <span class=\"hljs-type\">int</span> to_node = min(num_out, d_min_idx + R + <span class=\"hljs-number\">1</span>);\r\n\r\n    <span class=\"hljs-comment\">// step 3b: update the weights of nodes in the</span>\r\n    <span class=\"hljs-comment\">// neighborhood</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-keyword\">for</span> (j = from_node; j &lt; to_node; j++)\r\n        <span class=\"hljs-keyword\">for</span> (k = <span class=\"hljs-number\">0</span>; k &lt; num_features; k++)\r\n            <span class=\"hljs-comment\">// update weights of nodes in the neighborhood</span>\r\n            W[j][k] += alpha * (x[k] - W[j][k]);\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Apply incremental algorithm with updating neighborhood and learning rates\r\n * on all samples in the given datset.\r\n *\r\n * \\param[in] X data set\r\n * \\param[in,out] W weights matrix\r\n * \\param[in] num_samples number of output points\r\n * \\param[in] num_features number of features per input sample\r\n * \\param[in] num_out number of output points\r\n * \\param[in] alpha_min terminal value of alpha\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">kohonen_som_tracer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> **X, <span class=\"hljs-type\">double</span> *<span class=\"hljs-type\">const</span> *W, <span class=\"hljs-type\">int</span> num_samples,\r\n                        <span class=\"hljs-type\">int</span> num_features, <span class=\"hljs-type\">int</span> num_out, <span class=\"hljs-type\">double</span> alpha_min)</span>\r\n{\r\n    <span class=\"hljs-type\">int</span> R = num_out &gt;&gt; <span class=\"hljs-number\">2</span>, iter = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">double</span> alpha = <span class=\"hljs-number\">1.f</span>;\r\n    <span class=\"hljs-type\">double</span> *D = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(num_out * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\r\n\r\n    <span class=\"hljs-comment\">// Loop alpha from 1 to alpha_min</span>\r\n    <span class=\"hljs-keyword\">for</span> (; alpha &gt; alpha_min; alpha -= <span class=\"hljs-number\">0.01</span>, iter++)\r\n    {\r\n        <span class=\"hljs-comment\">// Loop for each sample pattern in the data set</span>\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> sample = <span class=\"hljs-number\">0</span>; sample &lt; num_samples; sample++)\r\n        {\r\n            <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> *x = X[sample];\r\n            <span class=\"hljs-comment\">// update weights for the current input pattern sample</span>\r\n            kohonen_update_weights(x, W, D, num_out, num_features, alpha, R);\r\n        }\r\n\r\n        <span class=\"hljs-comment\">// every 10th iteration, reduce the neighborhood range</span>\r\n        <span class=\"hljs-keyword\">if</span> (iter % <span class=\"hljs-number\">10</span> == <span class=\"hljs-number\">0</span> &amp;&amp; R &gt; <span class=\"hljs-number\">1</span>)\r\n            R--;\r\n    }\r\n\r\n    <span class=\"hljs-built_in\">free</span>(D);\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @}\r\n * @}\r\n */</span>\r\n\r\n<span class=\"hljs-comment\">/** Creates a random set of points distributed *near* the circumference\r\n * of a circle and trains an SOM that finds that circular pattern. The\r\n * generating function is\r\n * \\f{eqnarray*}{\r\n * r &amp;\\in&amp; [1-\\delta r, 1+\\delta r)\\\\\r\n * \\theta &amp;\\in&amp; [0, 2\\pi)\\\\\r\n * x &amp;=&amp; r\\cos\\theta\\\\\r\n * y &amp;=&amp; r\\sin\\theta\r\n * \\f}\r\n *\r\n * \\param[out] data matrix to store data in\r\n * \\param[in] N number of points required\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test_circle</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> *<span class=\"hljs-type\">const</span> *data, <span class=\"hljs-type\">int</span> N)</span>\r\n{\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.75</span>, dr = <span class=\"hljs-number\">0.3</span>;\r\n    <span class=\"hljs-type\">double</span> <span class=\"hljs-type\">a_t</span> = <span class=\"hljs-number\">0.</span>, <span class=\"hljs-type\">b_t</span> = <span class=\"hljs-number\">2.f</span> * M_PI;  <span class=\"hljs-comment\">// theta random between 0 and 2*pi</span>\r\n    <span class=\"hljs-type\">double</span> a_r = R - dr, b_r = R + dr;  <span class=\"hljs-comment\">// radius random between R-dr and R+dr</span>\r\n    <span class=\"hljs-type\">int</span> i;\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\r\n    {\r\n        <span class=\"hljs-type\">double</span> r = _random(a_r, b_r);      <span class=\"hljs-comment\">// random radius</span>\r\n        <span class=\"hljs-type\">double</span> theta = _random(<span class=\"hljs-type\">a_t</span>, <span class=\"hljs-type\">b_t</span>);  <span class=\"hljs-comment\">// random theta</span>\r\n        data[i][<span class=\"hljs-number\">0</span>] = r * <span class=\"hljs-built_in\">cos</span>(theta);       <span class=\"hljs-comment\">// convert from polar to cartesian</span>\r\n        data[i][<span class=\"hljs-number\">1</span>] = r * <span class=\"hljs-built_in\">sin</span>(theta);\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed *near* the\r\n * circumference of a circle and trains an SOM that finds that circular pattern.\r\n * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)\r\n * files are created to validate the execution:\r\n * * `test1.csv`: random test samples points with a circular pattern\r\n * * `w11.csv`: initial random map\r\n * * `w12.csv`: trained SOM map\r\n *\r\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\r\n * the following snippet\r\n * ```gnuplot\r\n * set datafile separator &#x27;,&#x27;\r\n * plot &quot;test1.csv&quot; title &quot;original&quot;, \\\r\n *      &quot;w11.csv&quot; title &quot;w1&quot;, \\\r\n *      &quot;w12.csv&quot; title &quot;w2&quot;\r\n * ```\r\n * ![Sample execution\r\n * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test1.svg)\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test1</span><span class=\"hljs-params\">()</span>\r\n{\r\n    <span class=\"hljs-type\">int</span> j, N = <span class=\"hljs-number\">500</span>;\r\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">2</span>;\r\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">50</span>;\r\n\r\n    <span class=\"hljs-comment\">// 2D space, hence size = number of rows * 2</span>\r\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\r\n\r\n    <span class=\"hljs-comment\">// number of clusters nodes * 2</span>\r\n    <span class=\"hljs-type\">double</span> **W = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(num_out * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)  <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\r\n    {\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\r\n            X[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\r\n        {\r\n            W[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n            <span class=\"hljs-comment\">// preallocate with random initial weights</span>\r\n            <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) W[i][j] = _random(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>);\r\n        }\r\n    }\r\n\r\n    test_circle(X, N);  <span class=\"hljs-comment\">// create test data around circumference of a circle</span>\r\n    save_nd_data(<span class=\"hljs-string\">&quot;test1.csv&quot;</span>, X, N, features);  <span class=\"hljs-comment\">// save test data points</span>\r\n    save_nd_data(<span class=\"hljs-string\">&quot;w11.csv&quot;</span>, W, num_out,\r\n                 features);  <span class=\"hljs-comment\">// save initial random weights</span>\r\n    kohonen_som_tracer(X, W, N, features, num_out, <span class=\"hljs-number\">0.1</span>);  <span class=\"hljs-comment\">// train the SOM</span>\r\n    save_nd_data(<span class=\"hljs-string\">&quot;w12.csv&quot;</span>, W, num_out,\r\n                 features);  <span class=\"hljs-comment\">// save the resultant weights</span>\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)\r\n    {\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)\r\n            <span class=\"hljs-built_in\">free</span>(X[i]);\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)\r\n            <span class=\"hljs-built_in\">free</span>(W[i]);\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Creates a random set of points distributed *near* the locus\r\n * of the [Lamniscate of\r\n * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono).\r\n * \\f{eqnarray*}{\r\n * \\delta r &amp;=&amp; 0.2\\\\\r\n * \\delta x &amp;\\in&amp; [-\\delta r, \\delta r)\\\\\r\n * \\delta y &amp;\\in&amp; [-\\delta r, \\delta r)\\\\\r\n * \\theta &amp;\\in&amp; [0, \\pi)\\\\\r\n * x &amp;=&amp; \\delta x + \\cos\\theta\\\\\r\n * y &amp;=&amp; \\delta y + \\frac{\\sin(2\\theta)}{2}\r\n * \\f}\r\n * \\param[out] data matrix to store data in\r\n * \\param[in] N number of points required\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test_lamniscate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> *<span class=\"hljs-type\">const</span> *data, <span class=\"hljs-type\">int</span> N)</span>\r\n{\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> dr = <span class=\"hljs-number\">0.2</span>;\r\n    <span class=\"hljs-type\">int</span> i;\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\r\n    {\r\n        <span class=\"hljs-type\">double</span> dx = _random(-dr, dr);     <span class=\"hljs-comment\">// random change in x</span>\r\n        <span class=\"hljs-type\">double</span> dy = _random(-dr, dr);     <span class=\"hljs-comment\">// random change in y</span>\r\n        <span class=\"hljs-type\">double</span> theta = _random(<span class=\"hljs-number\">0</span>, M_PI);  <span class=\"hljs-comment\">// random theta</span>\r\n        data[i][<span class=\"hljs-number\">0</span>] = dx + <span class=\"hljs-built_in\">cos</span>(theta);     <span class=\"hljs-comment\">// convert from polar to cartesian</span>\r\n        data[i][<span class=\"hljs-number\">1</span>] = dy + <span class=\"hljs-built_in\">sin</span>(<span class=\"hljs-number\">2.</span> * theta) / <span class=\"hljs-number\">2.f</span>;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed *near* the locus\r\n * of the [Lamniscate of\r\n * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono) and trains an SOM\r\n * that finds that circular pattern. The following\r\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\r\n * to validate the execution:\r\n * * `test2.csv`: random test samples points with a lamniscate pattern\r\n * * `w21.csv`: initial random map\r\n * * `w22.csv`: trained SOM map\r\n *\r\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\r\n * the following snippet\r\n * ```gnuplot\r\n * set datafile separator &#x27;,&#x27;\r\n * plot &quot;test2.csv&quot; title &quot;original&quot;, \\\r\n *      &quot;w21.csv&quot; title &quot;w1&quot;, \\\r\n *      &quot;w22.csv&quot; title &quot;w2&quot;\r\n * ```\r\n * ![Sample execution\r\n * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test2.svg)\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test2</span><span class=\"hljs-params\">()</span>\r\n{\r\n    <span class=\"hljs-type\">int</span> j, N = <span class=\"hljs-number\">500</span>;\r\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">2</span>;\r\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">20</span>;\r\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\r\n    <span class=\"hljs-type\">double</span> **W = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(num_out * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)\r\n    {\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\r\n            X[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\r\n        {\r\n            W[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n            <span class=\"hljs-comment\">// preallocate with random initial weights</span>\r\n            <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) W[i][j] = _random(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>);\r\n        }\r\n    }\r\n\r\n    test_lamniscate(X, N);  <span class=\"hljs-comment\">// create test data around the lamniscate</span>\r\n    save_nd_data(<span class=\"hljs-string\">&quot;test2.csv&quot;</span>, X, N, features);  <span class=\"hljs-comment\">// save test data points</span>\r\n    save_nd_data(<span class=\"hljs-string\">&quot;w21.csv&quot;</span>, W, num_out,\r\n                 features);  <span class=\"hljs-comment\">// save initial random weights</span>\r\n    kohonen_som_tracer(X, W, N, features, num_out, <span class=\"hljs-number\">0.01</span>);  <span class=\"hljs-comment\">// train the SOM</span>\r\n    save_nd_data(<span class=\"hljs-string\">&quot;w22.csv&quot;</span>, W, num_out,\r\n                 features);  <span class=\"hljs-comment\">// save the resultant weights</span>\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)\r\n    {\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)\r\n            <span class=\"hljs-built_in\">free</span>(X[i]);\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)\r\n            <span class=\"hljs-built_in\">free</span>(W[i]);\r\n    }\r\n    <span class=\"hljs-built_in\">free</span>(X);\r\n    <span class=\"hljs-built_in\">free</span>(W);\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Creates a random set of points distributed in four clusters in\r\n * 3D space with centroids at the points\r\n * * \\f$(0,5, 0.5, 0.5)\\f$\r\n * * \\f$(0,5,-0.5, -0.5)\\f$\r\n * * \\f$(-0,5, 0.5, 0.5)\\f$\r\n * * \\f$(-0,5,-0.5, -0.5)\\f$\r\n *\r\n * \\param[out] data matrix to store data in\r\n * \\param[in] N number of points required\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test_3d_classes</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> *<span class=\"hljs-type\">const</span> *data, <span class=\"hljs-type\">int</span> N)</span>\r\n{\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.1</span>;  <span class=\"hljs-comment\">// radius of cluster</span>\r\n    <span class=\"hljs-type\">int</span> i;\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> num_classes = <span class=\"hljs-number\">4</span>;\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> centres[][<span class=\"hljs-number\">3</span>] = {\r\n        <span class=\"hljs-comment\">// centres of each class cluster</span>\r\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>},    <span class=\"hljs-comment\">// centre of class 1</span>\r\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>},  <span class=\"hljs-comment\">// centre of class 2</span>\r\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>},   <span class=\"hljs-comment\">// centre of class 3</span>\r\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span> - <span class=\"hljs-number\">.5</span>}  <span class=\"hljs-comment\">// centre of class 4</span>\r\n    };\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\r\n    {\r\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> =</span>\r\n            rand() % num_classes;  <span class=\"hljs-comment\">// select a random class for the point</span>\r\n\r\n        <span class=\"hljs-comment\">// create random coordinates (x,y,z) around the centre of the class</span>\r\n        data[i][<span class=\"hljs-number\">0</span>] = _random(centres[class][<span class=\"hljs-number\">0</span>] - R, centres[class][<span class=\"hljs-number\">0</span>] + R);\r\n        data[i][<span class=\"hljs-number\">1</span>] = _random(centres[class][<span class=\"hljs-number\">1</span>] - R, centres[class][<span class=\"hljs-number\">1</span>] + R);\r\n        data[i][<span class=\"hljs-number\">2</span>] = _random(centres[class][<span class=\"hljs-number\">2</span>] - R, centres[class][<span class=\"hljs-number\">2</span>] + R);\r\n\r\n        <span class=\"hljs-comment\">/* The follosing can also be used\r\n        for (int j = 0; j &lt; 3; j++)\r\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\r\n        */</span>\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed in six clusters in\r\n * 3D space. The following\r\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\r\n * to validate the execution:\r\n * * `test3.csv`: random test samples points with a circular pattern\r\n * * `w31.csv`: initial random map\r\n * * `w32.csv`: trained SOM map\r\n *\r\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\r\n * the following snippet\r\n * ```gnuplot\r\n * set datafile separator &#x27;,&#x27;\r\n * plot &quot;test3.csv&quot; title &quot;original&quot;, \\\r\n *      &quot;w31.csv&quot; title &quot;w1&quot;, \\\r\n *      &quot;w32.csv&quot; title &quot;w2&quot;\r\n * ```\r\n * ![Sample execution\r\n * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test3.svg)\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test3</span><span class=\"hljs-params\">()</span>\r\n{\r\n    <span class=\"hljs-type\">int</span> j, N = <span class=\"hljs-number\">200</span>;\r\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">3</span>;\r\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">20</span>;\r\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\r\n    <span class=\"hljs-type\">double</span> **W = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(num_out * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)\r\n    {\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\r\n            X[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\r\n        {\r\n            W[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n            <span class=\"hljs-comment\">// preallocate with random initial weights</span>\r\n            <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) W[i][j] = _random(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>);\r\n        }\r\n    }\r\n\r\n    test_3d_classes(X, N);  <span class=\"hljs-comment\">// create test data around the lamniscate</span>\r\n    save_nd_data(<span class=\"hljs-string\">&quot;test3.csv&quot;</span>, X, N, features);  <span class=\"hljs-comment\">// save test data points</span>\r\n    save_nd_data(<span class=\"hljs-string\">&quot;w31.csv&quot;</span>, W, num_out,\r\n                 features);  <span class=\"hljs-comment\">// save initial random weights</span>\r\n    kohonen_som_tracer(X, W, N, features, num_out, <span class=\"hljs-number\">0.01</span>);  <span class=\"hljs-comment\">// train the SOM</span>\r\n    save_nd_data(<span class=\"hljs-string\">&quot;w32.csv&quot;</span>, W, num_out,\r\n                 features);  <span class=\"hljs-comment\">// save the resultant weights</span>\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)\r\n    {\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)\r\n            <span class=\"hljs-built_in\">free</span>(X[i]);\r\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)\r\n            <span class=\"hljs-built_in\">free</span>(W[i]);\r\n    }\r\n    <span class=\"hljs-built_in\">free</span>(X);\r\n    <span class=\"hljs-built_in\">free</span>(W);\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Convert clock cycle difference to time in seconds\r\n *\r\n * \\param[in] start_t start clock\r\n * \\param[in] end_t end clock\r\n * \\returns time difference in seconds\r\n */</span>\r\n<span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">get_clock_diff</span><span class=\"hljs-params\">(<span class=\"hljs-type\">clock_t</span> <span class=\"hljs-type\">start_t</span>, <span class=\"hljs-type\">clock_t</span> <span class=\"hljs-type\">end_t</span>)</span>\r\n{\r\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-type\">double</span>)(<span class=\"hljs-type\">end_t</span> - <span class=\"hljs-type\">start_t</span>) / (<span class=\"hljs-type\">double</span>)CLOCKS_PER_SEC;\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Main function */</span>\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span>\r\n{\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Using OpenMP based parallelization\\n&quot;</span>);\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;NOT using OpenMP based parallelization\\n&quot;</span>);\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\r\n    <span class=\"hljs-type\">clock_t</span> start_clk = clock();\r\n    test1();\r\n    <span class=\"hljs-type\">clock_t</span> end_clk = clock();\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Test 1 completed in %.4g sec\\n&quot;</span>,\r\n           get_clock_diff(start_clk, end_clk));\r\n    start_clk = clock();\r\n    test2();\r\n    end_clk = clock();\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Test 2 completed in %.4g sec\\n&quot;</span>,\r\n           get_clock_diff(start_clk, end_clk));\r\n    start_clk = clock();\r\n    test3();\r\n    end_clk = clock();\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Test 3 completed in %.4g sec\\n&quot;</span>,\r\n           get_clock_diff(start_clk, end_clk));\r\n    <span class=\"hljs-built_in\">printf</span>(\r\n        <span class=\"hljs-string\">&quot;(Note: Calculated times include: creating test sets, training &quot;</span>\r\n        <span class=\"hljs-string\">&quot;model and writing files to disk.)\\n\\n&quot;</span>);\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 12
    }
  ],
  "explanationUrl": {}
}