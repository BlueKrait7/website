{
  "slug": "bellman-ford",
  "name": "Bellman Ford",
  "categories": [
    "graphs"
  ],
  "body": {
    "en": "<h4>Problem Statement</h4>\n<p>Given a weighted directed graph G(V,E) and a source vertex s ∈ V, determine for each vertex v ∈ V the shortest path between s and v.</p>\n<h4>Approach</h4>\n<ul>\n<li>Initialize the distance from the source to all vertices as infinite.</li>\n<li>Initialize the distance to itself as 0.</li>\n<li>Create an array dist[] of size |V| with all values as infinite except dist[s].</li>\n<li>Repeat the following |V| - 1 times. Where |V| is number of vertices.</li>\n<li>Create another loop to go through each edge (u, v) in E and do the following:\n<ol>\n<li>dist[v] = minimum(dist[v], dist[u] + weight of edge).</li>\n</ol>\n</li>\n<li>Lastly iterate through all edges on last time to make sure there are no negatively weighted cycles.</li>\n</ul>\n<h4>Time Complexity</h4>\n<p>O(VE)</p>\n<h4>Space Complexity</h4>\n<p>O(V^2)</p>\n<h4>Founder's Name</h4>\n<ul>\n<li>Richard Bellman &#x26; Lester Ford, Jr.</li>\n</ul>\n<h4>Example</h4>\n<pre><code class=\"hljs language-json\">    # of vertices in graph = <span class=\"hljs-number\">5</span> [A, B, C, D, E]\r\n    # of edges in graph = <span class=\"hljs-number\">8</span> \r\n\r\n    edges  [A->B, A->C, B->C, B->D, B->E, D->C, D->B, E->D]\r\n    weight [ <span class=\"hljs-number\">-1</span>,    <span class=\"hljs-number\">4</span>,    <span class=\"hljs-number\">3</span>,    <span class=\"hljs-number\">2</span>,    <span class=\"hljs-number\">2</span>,    <span class=\"hljs-number\">5</span>,    <span class=\"hljs-number\">1</span>,   <span class=\"hljs-number\">-4</span> ]\r\n    source [  A,    A,    B,    B,    B,    D,    D,    E ]\r\n\r\n\r\n\r\n    <span class=\"hljs-comment\">// edge A->B </span>\r\n    graph->edge[<span class=\"hljs-number\">0</span>].src = A \r\n    graph->edge[<span class=\"hljs-number\">0</span>].dest = B \r\n    graph->edge[<span class=\"hljs-number\">0</span>].weight = <span class=\"hljs-number\">-1</span> \r\n  \r\n    <span class=\"hljs-comment\">// edge A->C </span>\r\n    graph->edge[<span class=\"hljs-number\">1</span>].src = A \r\n    graph->edge[<span class=\"hljs-number\">1</span>].dest = C \r\n    graph->edge[<span class=\"hljs-number\">1</span>].weight = <span class=\"hljs-number\">4</span> \r\n  \r\n    <span class=\"hljs-comment\">// edge B->C </span>\r\n    graph->edge[<span class=\"hljs-number\">2</span>].src = B \r\n    graph->edge[<span class=\"hljs-number\">2</span>].dest = C \r\n    graph->edge[<span class=\"hljs-number\">2</span>].weight = <span class=\"hljs-number\">3</span> \r\n  \r\n    <span class=\"hljs-comment\">// edge B->D </span>\r\n    graph->edge[<span class=\"hljs-number\">3</span>].src = B \r\n    graph->edge[<span class=\"hljs-number\">3</span>].dest = D \r\n    graph->edge[<span class=\"hljs-number\">3</span>].weight = <span class=\"hljs-number\">2</span> \r\n  \r\n    <span class=\"hljs-comment\">// edge B->E </span>\r\n    graph->edge[<span class=\"hljs-number\">4</span>].src = B \r\n    graph->edge[<span class=\"hljs-number\">4</span>].dest = E \r\n    graph->edge[<span class=\"hljs-number\">4</span>].weight = <span class=\"hljs-number\">2</span> \r\n  \r\n    <span class=\"hljs-comment\">// edge D->C </span>\r\n    graph->edge[<span class=\"hljs-number\">5</span>].src = D\r\n    graph->edge[<span class=\"hljs-number\">5</span>].dest = C \r\n    graph->edge[<span class=\"hljs-number\">5</span>].weight = <span class=\"hljs-number\">5</span> \r\n  \r\n    <span class=\"hljs-comment\">// edge D->B </span>\r\n    graph->edge[<span class=\"hljs-number\">6</span>].src = D\r\n    graph->edge[<span class=\"hljs-number\">6</span>].dest = B \r\n    graph->edge[<span class=\"hljs-number\">6</span>].weight = <span class=\"hljs-number\">1</span> \r\n  \r\n    <span class=\"hljs-comment\">// edge E->D </span>\r\n    graph->edge[<span class=\"hljs-number\">7</span>].src = E\r\n    graph->edge[<span class=\"hljs-number\">7</span>].dest = D \r\n    graph->edge[<span class=\"hljs-number\">7</span>].weight = <span class=\"hljs-number\">-3</span>\r\n\r\n    for source = A\r\n\r\n    Vertex   Distance from Source\r\n\tA                <span class=\"hljs-number\">0</span>\t\t\t\tA->A\r\n\tB                <span class=\"hljs-number\">-1</span>\t\t\t\tA->B\r\n\tC                <span class=\"hljs-number\">2</span> \t\t\t\tA->B->C = <span class=\"hljs-number\">-1</span> + <span class=\"hljs-number\">3</span>\r\n\tD                <span class=\"hljs-number\">-2</span>\t\t\t\tA->B->E->D = <span class=\"hljs-number\">-1</span> + <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">-3</span>\r\n\tE                <span class=\"hljs-number\">1</span>\t\t\t\tA->B->E = <span class=\"hljs-number\">-1</span> + <span class=\"hljs-number\">2</span>\n</code></pre>\n<h4>Code Implementation Links</h4>\n<ul>\n<li><a href=\"https://github.com/TheAlgorithms/Java/blob/master/DataStructures/Graphs/BellmanFord.java\">Java</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/bellman_ford.cpp\">C++</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/Python/blob/master/graphs/bellman_ford.py\">Python</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/C/blob/master/data_structures/graphs/bellman_ford.c\">C</a></li>\n</ul>\n<h4>Video Explanation</h4>\n<p><a href=\"https://www.youtube.com/watch?v=hxMWBBCpR6A\">A video explaining the Bellman-Ford Algorithm</a></p>\n<h4>Others</h4>\n<p>Sources Used:</p>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/\">https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\">https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm</a></li>\n</ul>",
    "es": "<h4>Declaración de problema</h4>\n<p>Dado un gráfico dirigido ponderado <code>G(V,E)</code> y un vértice de origen s ∈ V, determine para cada <code>v v v ∈ V</code> el trayecto más corto entre <code>s</code> y <code>v</code>.</p>\n<h4>Enfoque</h4>\n<ul>\n<li>Inicializar la distancia de la fuente a todos los vértices como infinito.</li>\n<li>Inicializar la distancia a sí mismo como 0.</li>\n<li>Crear una matriz dist[] de tamaño | V| con todos los valores como infinitos excepto dist[s].</li>\n<li>Repita los siguientes |V| - 1 vez, dónde |V| es el número de vértices.</li>\n<li>Crear otro bucle para ir a través de cada borde <code>(u, v)</code> en E y hacer lo siguiente:\n<ol>\n<li><code>dist[v] = minimum(dist[v], dist[u] + peso de borde</code>.</li>\n</ol>\n</li>\n<li>Por último, iterar a través de todos los bordes en la última vez, para asegurarse de que no hay ciclos ponderados negativamente.</li>\n</ul>\n<h4>Complejidad temporal</h4>\n<p><code>O(VE)</code></p>\n<h4>Complejidad espacial</h4>\n<p><code>O(V^2)</code></p>\n<h4>Nombre del Fundador</h4>\n<ul>\n<li>Richard Bellman &#x26; Lester Ford, Jr.</li>\n</ul>\n<h4>Ejemplo</h4>\n<pre><code class=\"hljs language-markdown\"><span class=\"hljs-section\"># de vértices en el gráfico = 5 [A, B, C, D, E]</span>\r\n<span class=\"hljs-section\"># de bordes en gráfico = 8</span>\r\n\r\nbordes [A->B, A->C, B->C, B->D, B->E, D->C, D->B, E->D]\r\npeso [ -1, 4, 3, 2, 2, 5, 1, -4 ]\r\nfuente [ A, A, B, B, B, D, D, E ]\r\n\r\nborde A->B\r\ngraph->edge[0].src = A\r\ngraph->edge[0].dest = B\r\ngraph->edge[0].weight = -1\r\n\r\nborde A->C\r\ngraph->edge[1] .src = A\r\ngraph->edge[1].dest = C\r\ngráfico->edge[1] .weight = 4\r\n\r\nborde B->C\r\ngraph->edge[2].src = B\r\ngraph->edge[2].dest = C\r\ngráfico->edge[2].peso = 3\r\n\r\nborde B->D\r\ngráfico->edge[3] .src = B\r\ngraph->edge[3] .dest = D\r\ngráfico->edge[3] .peso = 2\r\n\r\nborde B->E\r\ngraph->edge[4].src = B\r\ngraph->edge[4].dest = E\r\ngráfico->edge[4].peso = 2\r\n\r\nborde D->C\r\ngraph->edge[5].src = D\r\ngraph->edge[5].dest = C\r\ngráfico->edge[5].peso = 5\r\n\r\nborde D->B\r\ngraph->edge[6] .src = D\r\ngraph->edge[6].dest = B\r\ngráfico->edge[6].weight = 1\r\n\r\nborde E->D\r\ngraph->edge[7] .src = E\r\ngraph->edge[7].dest = D\r\ngráfico->edge[7].weight = -3\r\n\r\npara la fuente = A\r\n\r\nDistancia de vértice desde la fuente\r\nA 0 A->A\r\nB -1 A->B\r\nC 2 A->B->C = -1 + 3\r\nD -2 A->B->E->D = -1 + 2 + -3\r\nE 1 A->B->E = -1 + 2\n</code></pre>\n<h4>Enlaces de implementación de código</h4>\n<ul>\n<li><a href=\"https://github.com/TheAlgorithms/Java/blob/master/DataStructures/Graphs/BellmanFord.java\">Java</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/Dynamic%20Programming/Bellman-Ford.cpp\">C++</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/Python/blob/master/data_structures/graph/bellman_ford.py\">Python</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/C/blob/master/data_structures/graphs/Bellman-Ford.c\">C</a></li>\n</ul>\n<h4>Explicación de vídeo</h4>\n<p><a href=\"https://www.youtube.com/watch?v=hxMWBBCpR6A\">Un video explicando el algoritmo Bellman Ford</a></p>\n<h4>Otros</h4>\n<p>Fuentes utilizadas:</p>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/\">https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\">https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm</a></li>\n</ul>"
  },
  "implementations": {
    "python": {
      "dir": "graphs\\bellman_ford.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/graphs\\bellman_ford.py",
      "code": "<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print_distance</span>(<span class=\"hljs-params\">distance: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">float</span>], src</span>):\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;Vertex\\tShortest Distance from vertex <span class=\"hljs-subst\">{src}</span>&quot;</span>)\r\n    <span class=\"hljs-keyword\">for</span> i, d <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(distance):\r\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;<span class=\"hljs-subst\">{i}</span>\\t\\t<span class=\"hljs-subst\">{d}</span>&quot;</span>)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">check_negative_cycle</span>(<span class=\"hljs-params\">\r\n    graph: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">int</span>]], distance: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">float</span>], edge_count: <span class=\"hljs-built_in\">int</span>\r\n</span>):\r\n    <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(edge_count):\r\n        u, v, w = (graph[j][k] <span class=\"hljs-keyword\">for</span> k <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-string\">&quot;src&quot;</span>, <span class=\"hljs-string\">&quot;dst&quot;</span>, <span class=\"hljs-string\">&quot;weight&quot;</span>])\r\n        <span class=\"hljs-keyword\">if</span> distance[u] != <span class=\"hljs-built_in\">float</span>(<span class=\"hljs-string\">&quot;inf&quot;</span>) <span class=\"hljs-keyword\">and</span> distance[u] + w &lt; distance[v]:\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">bellman_ford</span>(<span class=\"hljs-params\">\r\n    graph: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">int</span>]], vertex_count: <span class=\"hljs-built_in\">int</span>, edge_count: <span class=\"hljs-built_in\">int</span>, src: <span class=\"hljs-built_in\">int</span>\r\n</span>) -&gt; <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">float</span>]:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Returns shortest paths from a vertex src to all\r\n    other vertices.\r\n    &gt;&gt;&gt; edges = [(2, 1, -10), (3, 2, 3), (0, 3, 5), (0, 1, 4)]\r\n    &gt;&gt;&gt; g = [{&quot;src&quot;: s, &quot;dst&quot;: d, &quot;weight&quot;: w} for s, d, w in edges]\r\n    &gt;&gt;&gt; bellman_ford(g, 4, 4, 0)\r\n    [0.0, -2.0, 8.0, 5.0]\r\n    &gt;&gt;&gt; g = [{&quot;src&quot;: s, &quot;dst&quot;: d, &quot;weight&quot;: w} for s, d, w in edges + [(1, 3, 5)]]\r\n    &gt;&gt;&gt; bellman_ford(g, 4, 5, 0)\r\n    Traceback (most recent call last):\r\n     ...\r\n    Exception: Negative cycle found\r\n    &quot;&quot;&quot;</span>\r\n    distance = [<span class=\"hljs-built_in\">float</span>(<span class=\"hljs-string\">&quot;inf&quot;</span>)] * vertex_count\r\n    distance[src] = <span class=\"hljs-number\">0.0</span>\r\n\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(vertex_count - <span class=\"hljs-number\">1</span>):\r\n        <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(edge_count):\r\n            u, v, w = (graph[j][k] <span class=\"hljs-keyword\">for</span> k <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-string\">&quot;src&quot;</span>, <span class=\"hljs-string\">&quot;dst&quot;</span>, <span class=\"hljs-string\">&quot;weight&quot;</span>])\r\n\r\n            <span class=\"hljs-keyword\">if</span> distance[u] != <span class=\"hljs-built_in\">float</span>(<span class=\"hljs-string\">&quot;inf&quot;</span>) <span class=\"hljs-keyword\">and</span> distance[u] + w &lt; distance[v]:\r\n                distance[v] = distance[u] + w\r\n\r\n    negative_cycle_exists = check_negative_cycle(graph, distance, edge_count)\r\n    <span class=\"hljs-keyword\">if</span> negative_cycle_exists:\r\n        <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">&quot;Negative cycle found&quot;</span>)\r\n\r\n    <span class=\"hljs-keyword\">return</span> distance\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    <span class=\"hljs-keyword\">import</span> doctest\r\n\r\n    doctest.testmod()\r\n\r\n    V = <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&quot;Enter number of vertices: &quot;</span>).strip())\r\n    E = <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&quot;Enter number of edges: &quot;</span>).strip())\r\n\r\n    graph: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">int</span>]] = [<span class=\"hljs-built_in\">dict</span>() <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(E)]\r\n\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(E):\r\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Edge &quot;</span>, i + <span class=\"hljs-number\">1</span>)\r\n        src, dest, weight = (\r\n            <span class=\"hljs-built_in\">int</span>(x)\r\n            <span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&quot;Enter source, destination, weight: &quot;</span>).strip().split(<span class=\"hljs-string\">&quot; &quot;</span>)\r\n        )\r\n        graph[i] = {<span class=\"hljs-string\">&quot;src&quot;</span>: src, <span class=\"hljs-string\">&quot;dst&quot;</span>: dest, <span class=\"hljs-string\">&quot;weight&quot;</span>: weight}\r\n\r\n    source = <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&quot;\\nEnter shortest path source:&quot;</span>).strip())\r\n    shortest_distance = bellman_ford(graph, V, E, source)\r\n    print_distance(shortest_distance, <span class=\"hljs-number\">0</span>)\r\n"
    },
    "javascript": {
      "dir": "Graphs\\test\\BellmanFord.test.js",
      "url": "https://github.com/TheAlgorithms/javascript/tree/master/Graphs\\test\\BellmanFord.test.js",
      "code": "<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BellmanFord</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;../BellmanFord.js&#x27;</span>\r\n\r\n<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;Test Case 1&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\r\n  <span class=\"hljs-keyword\">const</span> V = <span class=\"hljs-number\">5</span>\r\n  <span class=\"hljs-keyword\">const</span> E = <span class=\"hljs-number\">8</span>\r\n  <span class=\"hljs-keyword\">const</span> destination = <span class=\"hljs-number\">3</span>\r\n  <span class=\"hljs-keyword\">const</span> graph = [[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>], [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>],\r\n    [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>], [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>],\r\n    [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>],\r\n    [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, -<span class=\"hljs-number\">3</span>]]\r\n  <span class=\"hljs-keyword\">const</span> dist = <span class=\"hljs-title class_\">BellmanFord</span>(graph, V, E, <span class=\"hljs-number\">0</span>, destination)\r\n  <span class=\"hljs-title function_\">expect</span>(dist).<span class=\"hljs-title function_\">toBe</span>(-<span class=\"hljs-number\">2</span>)\r\n})\r\n<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;Test Case 2&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\r\n  <span class=\"hljs-keyword\">const</span> V = <span class=\"hljs-number\">6</span>\r\n  <span class=\"hljs-keyword\">const</span> E = <span class=\"hljs-number\">9</span>\r\n  <span class=\"hljs-keyword\">const</span> destination = <span class=\"hljs-number\">4</span>\r\n  <span class=\"hljs-keyword\">const</span> graph = [[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>], [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>],\r\n    [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>, -<span class=\"hljs-number\">1</span>], [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">3</span>],\r\n    [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, -<span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>],\r\n    [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>], [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>]]\r\n  <span class=\"hljs-keyword\">const</span> dist = <span class=\"hljs-title class_\">BellmanFord</span>(graph, V, E, <span class=\"hljs-number\">0</span>, destination)\r\n  <span class=\"hljs-title function_\">expect</span>(dist).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-number\">1</span>)\r\n})\r\n<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;Test Case 3&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\r\n  <span class=\"hljs-keyword\">const</span> V = <span class=\"hljs-number\">4</span>\r\n  <span class=\"hljs-keyword\">const</span> E = <span class=\"hljs-number\">5</span>\r\n  <span class=\"hljs-keyword\">const</span> destination = <span class=\"hljs-number\">1</span>\r\n  <span class=\"hljs-keyword\">const</span> graph = [[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, -<span class=\"hljs-number\">1</span>], [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>],\r\n    [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>],\r\n    [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>]]\r\n  <span class=\"hljs-keyword\">const</span> dist = <span class=\"hljs-title class_\">BellmanFord</span>(graph, V, E, <span class=\"hljs-number\">0</span>, destination)\r\n  <span class=\"hljs-title function_\">expect</span>(dist).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-number\">0</span>)\r\n})\r\n"
    },
    "c-plus-plus": {
      "dir": "dynamic_programming\\bellman_ford.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/dynamic_programming\\bellman_ford.cpp",
      "code": "<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;limits.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n\r\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;\r\n\r\n<span class=\"hljs-comment\">// Wrapper class for storing an edge</span>\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Edge</span> {\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-type\">int</span> src, dst, weight;\r\n};\r\n\r\n<span class=\"hljs-comment\">// Wrapper class for storing a graph</span>\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span> {\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-type\">int</span> vertexNum, edgeNum;\r\n    Edge *edges;\r\n\r\n    <span class=\"hljs-comment\">// Constructs a graph with V vertices and E edges</span>\r\n    <span class=\"hljs-built_in\">Graph</span>(<span class=\"hljs-type\">int</span> V, <span class=\"hljs-type\">int</span> E) {\r\n        <span class=\"hljs-keyword\">this</span>-&gt;vertexNum = V;\r\n        <span class=\"hljs-keyword\">this</span>-&gt;edgeNum = E;\r\n        <span class=\"hljs-keyword\">this</span>-&gt;edges = (Edge *)<span class=\"hljs-built_in\">malloc</span>(E * <span class=\"hljs-built_in\">sizeof</span>(Edge));\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// Adds the given edge to the graph</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> src, <span class=\"hljs-type\">int</span> dst, <span class=\"hljs-type\">int</span> weight)</span> </span>{\r\n        <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> edgeInd = <span class=\"hljs-number\">0</span>;\r\n        <span class=\"hljs-keyword\">if</span> (edgeInd &lt; <span class=\"hljs-keyword\">this</span>-&gt;edgeNum) {\r\n            Edge newEdge;\r\n            newEdge.src = src;\r\n            newEdge.dst = dst;\r\n            newEdge.weight = weight;\r\n            <span class=\"hljs-keyword\">this</span>-&gt;edges[edgeInd++] = newEdge;\r\n        }\r\n    }\r\n};\r\n\r\n<span class=\"hljs-comment\">// Utility function to print distances</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> dist[], <span class=\"hljs-type\">int</span> V)</span> </span>{\r\n    cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nVertex  Distance&quot;</span> &lt;&lt; endl;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) {\r\n        <span class=\"hljs-keyword\">if</span> (dist[i] != INT_MAX)\r\n            cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot;\\t&quot;</span> &lt;&lt; dist[i] &lt;&lt; endl;\r\n        <span class=\"hljs-keyword\">else</span>\r\n            cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot;\\tINF&quot;</span> &lt;&lt; endl;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">// The main function that finds the shortest path from given source</span>\r\n<span class=\"hljs-comment\">// to all other vertices using Bellman-Ford.It also detects negative</span>\r\n<span class=\"hljs-comment\">// weight cycle</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">BellmanFord</span><span class=\"hljs-params\">(Graph graph, <span class=\"hljs-type\">int</span> src)</span> </span>{\r\n    <span class=\"hljs-type\">int</span> V = graph.vertexNum;\r\n    <span class=\"hljs-type\">int</span> E = graph.edgeNum;\r\n    <span class=\"hljs-type\">int</span> dist[V];\r\n\r\n    <span class=\"hljs-comment\">// Initialize distances array as INF for all except source</span>\r\n    <span class=\"hljs-comment\">// Intialize source as zero</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) dist[i] = INT_MAX;\r\n    dist[src] = <span class=\"hljs-number\">0</span>;\r\n\r\n    <span class=\"hljs-comment\">// Calculate shortest path distance from source to all edges</span>\r\n    <span class=\"hljs-comment\">// A path can contain maximum (|V|-1) edges</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= V - <span class=\"hljs-number\">1</span>; i++)\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; E; j++) {\r\n            <span class=\"hljs-type\">int</span> u = graph.edges[j].src;\r\n            <span class=\"hljs-type\">int</span> v = graph.edges[j].dst;\r\n            <span class=\"hljs-type\">int</span> w = graph.edges[j].weight;\r\n\r\n            <span class=\"hljs-keyword\">if</span> (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v])\r\n                dist[v] = dist[u] + w;\r\n        }\r\n\r\n    <span class=\"hljs-comment\">// Iterate inner loop once more to check for negative cycle</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; E; j++) {\r\n        <span class=\"hljs-type\">int</span> u = graph.edges[j].src;\r\n        <span class=\"hljs-type\">int</span> v = graph.edges[j].dst;\r\n        <span class=\"hljs-type\">int</span> w = graph.edges[j].weight;\r\n\r\n        <span class=\"hljs-keyword\">if</span> (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v]) {\r\n            cout &lt;&lt; <span class=\"hljs-string\">&quot;Graph contains negative weight cycle. Hence, shortest &quot;</span>\r\n                    <span class=\"hljs-string\">&quot;distance not guaranteed.&quot;</span>\r\n                 &lt;&lt; endl;\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-built_in\">print</span>(dist, V);\r\n\r\n    <span class=\"hljs-keyword\">return</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">// Driver Function</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-type\">int</span> V, E, gsrc;\r\n    <span class=\"hljs-type\">int</span> src, dst, weight;\r\n    cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter number of vertices: &quot;</span>;\r\n    cin &gt;&gt; V;\r\n    cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter number of edges: &quot;</span>;\r\n    cin &gt;&gt; E;\r\n    <span class=\"hljs-function\">Graph <span class=\"hljs-title\">G</span><span class=\"hljs-params\">(V, E)</span></span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; E; i++) {\r\n        cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nEdge &quot;</span> &lt;&lt; i + <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-string\">&quot;\\nEnter source: &quot;</span>;\r\n        cin &gt;&gt; src;\r\n        cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter destination: &quot;</span>;\r\n        cin &gt;&gt; dst;\r\n        cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter weight: &quot;</span>;\r\n        cin &gt;&gt; weight;\r\n        G.<span class=\"hljs-built_in\">addEdge</span>(src, dst, weight);\r\n    }\r\n    cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nEnter source: &quot;</span>;\r\n    cin &gt;&gt; gsrc;\r\n    <span class=\"hljs-built_in\">BellmanFord</span>(G, gsrc);\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    },
    "java": {
      "dir": "src\\main\\java\\com\\thealgorithms\\datastructures\\graphs\\BellmanFord.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src\\main\\java\\com\\thealgorithms\\datastructures\\graphs\\BellmanFord.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.datastructures.graphs;\r\n\r\n<span class=\"hljs-keyword\">import</span> java.util.*;\r\n\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BellmanFord</span> <span class=\"hljs-comment\">/*Implementation of Bellman ford to detect negative cycles. Graph accepts inputs in form of edges which have\r\nstart vertex, end vertex and weights. Vertices should be labelled with a number between 0 and total number of vertices-1,both inclusive*/</span> {\r\n\r\n    <span class=\"hljs-type\">int</span> vertex, edge;\r\n    <span class=\"hljs-keyword\">private</span> Edge edges[];\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">index</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\r\n\r\n    BellmanFord(<span class=\"hljs-type\">int</span> v, <span class=\"hljs-type\">int</span> e) {\r\n        vertex = v;\r\n        edge = e;\r\n        edges = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Edge</span>[e];\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Edge</span> {\r\n\r\n        <span class=\"hljs-type\">int</span> u, v;\r\n        <span class=\"hljs-type\">int</span> w;\r\n\r\n        <span class=\"hljs-comment\">/**\r\n         * <span class=\"hljs-doctag\">@param</span> u Source Vertex\r\n         * <span class=\"hljs-doctag\">@param</span> v End vertex\r\n         * <span class=\"hljs-doctag\">@param</span> c Weight\r\n         */</span>\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Edge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b, <span class=\"hljs-type\">int</span> c)</span> {\r\n            u = a;\r\n            v = b;\r\n            w = c;\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * <span class=\"hljs-doctag\">@param</span> p[] Parent array which shows updates in edges\r\n     * <span class=\"hljs-doctag\">@param</span> i Current vertex under consideration\r\n     */</span>\r\n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printPath</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> p[], <span class=\"hljs-type\">int</span> i)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (p[i] == -<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// Found the path back to parent</span>\r\n        {\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        printPath(p, p[i]);\r\n        System.out.print(i + <span class=\"hljs-string\">&quot; &quot;</span>);\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String args[])</span> {\r\n        <span class=\"hljs-type\">BellmanFord</span> <span class=\"hljs-variable\">obj</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BellmanFord</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// Dummy object to call nonstatic variables</span>\r\n        obj.go();\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span>\r\n            <span class=\"hljs-title function_\">go</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">// Interactive run for understanding the class first time. Assumes source vertex is 0 and</span>\r\n    <span class=\"hljs-comment\">// shows distance to all vertices</span>\r\n    {\r\n        <span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">sc</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in); <span class=\"hljs-comment\">// Grab scanner object for user input</span>\r\n        <span class=\"hljs-type\">int</span> i, v, e, u, ve, w, j, neg = <span class=\"hljs-number\">0</span>;\r\n        System.out.println(<span class=\"hljs-string\">&quot;Enter no. of vertices and edges please&quot;</span>);\r\n        v = sc.nextInt();\r\n        e = sc.nextInt();\r\n        Edge arr[] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Edge</span>[e]; <span class=\"hljs-comment\">// Array of edges</span>\r\n        System.out.println(<span class=\"hljs-string\">&quot;Input edges&quot;</span>);\r\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; e; i++) {\r\n            u = sc.nextInt();\r\n            ve = sc.nextInt();\r\n            w = sc.nextInt();\r\n            arr[i] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Edge</span>(u, ve, w);\r\n        }\r\n        <span class=\"hljs-type\">int</span> dist[]\r\n                = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[v]; <span class=\"hljs-comment\">// Distance array for holding the finalized shortest path distance between source</span>\r\n        <span class=\"hljs-comment\">// and all vertices</span>\r\n        <span class=\"hljs-type\">int</span> p[] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[v]; <span class=\"hljs-comment\">// Parent array for holding the paths</span>\r\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v; i++) {\r\n            dist[i] = Integer.MAX_VALUE; <span class=\"hljs-comment\">// Initializing distance values</span>\r\n        }\r\n        dist[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;\r\n        p[<span class=\"hljs-number\">0</span>] = -<span class=\"hljs-number\">1</span>;\r\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v - <span class=\"hljs-number\">1</span>; i++) {\r\n            <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; e; j++) {\r\n                <span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-type\">int</span>) dist[arr[j].u] != Integer.MAX_VALUE\r\n                        &amp;&amp; dist[arr[j].v] &gt; dist[arr[j].u] + arr[j].w) {\r\n                    dist[arr[j].v] = dist[arr[j].u] + arr[j].w; <span class=\"hljs-comment\">// Update</span>\r\n                    p[arr[j].v] = arr[j].u;\r\n                }\r\n            }\r\n        }\r\n        <span class=\"hljs-comment\">// Final cycle for negative checking</span>\r\n        <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; e; j++) {\r\n            <span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-type\">int</span>) dist[arr[j].u] != Integer.MAX_VALUE &amp;&amp; dist[arr[j].v] &gt; dist[arr[j].u] + arr[j].w) {\r\n                neg = <span class=\"hljs-number\">1</span>;\r\n                System.out.println(<span class=\"hljs-string\">&quot;Negative cycle&quot;</span>);\r\n                <span class=\"hljs-keyword\">break</span>;\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (neg == <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// Go ahead and show results of computation</span>\r\n        {\r\n            System.out.println(<span class=\"hljs-string\">&quot;Distances are: &quot;</span>);\r\n            <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v; i++) {\r\n                System.out.println(i + <span class=\"hljs-string\">&quot; &quot;</span> + dist[i]);\r\n            }\r\n            System.out.println(<span class=\"hljs-string\">&quot;Path followed:&quot;</span>);\r\n            <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v; i++) {\r\n                System.out.print(<span class=\"hljs-string\">&quot;0 &quot;</span>);\r\n                printPath(p, i);\r\n                System.out.println();\r\n            }\r\n        }\r\n        sc.close();\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * <span class=\"hljs-doctag\">@param</span> source Starting vertex\r\n     * <span class=\"hljs-doctag\">@param</span> end Ending vertex\r\n     * <span class=\"hljs-doctag\">@param</span> Edge Array of edges\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">show</span><span class=\"hljs-params\">(\r\n            <span class=\"hljs-type\">int</span> source,\r\n            <span class=\"hljs-type\">int</span> end,\r\n            Edge arr[])</span> <span class=\"hljs-comment\">// Just shows results of computation, if graph is passed to it. The graph should</span>\r\n    <span class=\"hljs-comment\">// be created by using addEdge() method and passed by calling getEdgeArray() method</span>\r\n    {\r\n        <span class=\"hljs-type\">int</span> i, j, v = vertex, e = edge, neg = <span class=\"hljs-number\">0</span>;\r\n        <span class=\"hljs-type\">double</span> dist[]\r\n                = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">double</span>[v]; <span class=\"hljs-comment\">// Distance array for holding the finalized shortest path distance between source</span>\r\n        <span class=\"hljs-comment\">// and all vertices</span>\r\n        <span class=\"hljs-type\">int</span> p[] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[v]; <span class=\"hljs-comment\">// Parent array for holding the paths</span>\r\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v; i++) {\r\n            dist[i] = Integer.MAX_VALUE; <span class=\"hljs-comment\">// Initializing distance values</span>\r\n        }\r\n        dist[source] = <span class=\"hljs-number\">0</span>;\r\n        p[source] = -<span class=\"hljs-number\">1</span>;\r\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v - <span class=\"hljs-number\">1</span>; i++) {\r\n            <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; e; j++) {\r\n                <span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-type\">int</span>) dist[arr[j].u] != Integer.MAX_VALUE\r\n                        &amp;&amp; dist[arr[j].v] &gt; dist[arr[j].u] + arr[j].w) {\r\n                    dist[arr[j].v] = dist[arr[j].u] + arr[j].w; <span class=\"hljs-comment\">// Update</span>\r\n                    p[arr[j].v] = arr[j].u;\r\n                }\r\n            }\r\n        }\r\n        <span class=\"hljs-comment\">// Final cycle for negative checking</span>\r\n        <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; e; j++) {\r\n            <span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-type\">int</span>) dist[arr[j].u] != Integer.MAX_VALUE &amp;&amp; dist[arr[j].v] &gt; dist[arr[j].u] + arr[j].w) {\r\n                neg = <span class=\"hljs-number\">1</span>;\r\n                System.out.println(<span class=\"hljs-string\">&quot;Negative cycle&quot;</span>);\r\n                <span class=\"hljs-keyword\">break</span>;\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (neg == <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// Go ahead and show results of computaion</span>\r\n        {\r\n            System.out.println(<span class=\"hljs-string\">&quot;Distance is: &quot;</span> + dist[end]);\r\n            System.out.println(<span class=\"hljs-string\">&quot;Path followed:&quot;</span>);\r\n            System.out.print(source + <span class=\"hljs-string\">&quot; &quot;</span>);\r\n            printPath(p, end);\r\n            System.out.println();\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * <span class=\"hljs-doctag\">@param</span> x Source Vertex\r\n     * <span class=\"hljs-doctag\">@param</span> y End vertex\r\n     * <span class=\"hljs-doctag\">@param</span> z Weight\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y, <span class=\"hljs-type\">int</span> z)</span> <span class=\"hljs-comment\">// Adds unidirectional edge</span>\r\n    {\r\n        edges[index++] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Edge</span>(x, y, z);\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">public</span> Edge[] getEdgeArray() {\r\n        <span class=\"hljs-keyword\">return</span> edges;\r\n    }\r\n}\r\n"
    },
    "c": {
      "dir": "data_structures\\graphs\\bellman_ford.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/data_structures\\graphs\\bellman_ford.c",
      "code": "<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;limits.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span></span>\r\n\r\n<span class=\"hljs-comment\">// Structure for storing edge</span>\r\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span>\r\n{</span>\r\n    <span class=\"hljs-type\">int</span> src, dst, weight;\r\n};\r\n\r\n<span class=\"hljs-comment\">// Structure for storing a graph</span>\r\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Graph</span>\r\n{</span>\r\n    <span class=\"hljs-type\">int</span> vertexNum;\r\n    <span class=\"hljs-type\">int</span> edgeNum;\r\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span> *<span class=\"hljs-title\">edges</span>;</span>\r\n};\r\n\r\n<span class=\"hljs-comment\">// Constructs a graph with V vertices and E edges</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">createGraph</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Graph *G, <span class=\"hljs-type\">int</span> V, <span class=\"hljs-type\">int</span> E)</span>\r\n{\r\n    G-&gt;vertexNum = V;\r\n    G-&gt;edgeNum = E;\r\n    G-&gt;edges = (<span class=\"hljs-keyword\">struct</span> Edge *)<span class=\"hljs-built_in\">malloc</span>(E * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> Edge));\r\n}\r\n\r\n<span class=\"hljs-comment\">// Adds the given edge to the graph</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Graph *G, <span class=\"hljs-type\">int</span> src, <span class=\"hljs-type\">int</span> dst, <span class=\"hljs-type\">int</span> weight)</span>\r\n{\r\n    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> ind;\r\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span> <span class=\"hljs-title\">newEdge</span>;</span>\r\n    newEdge.src = src;\r\n    newEdge.dst = dst;\r\n    newEdge.weight = weight;\r\n    G-&gt;edges[ind++] = newEdge;\r\n}\r\n\r\n<span class=\"hljs-comment\">// Utility function to find minimum distance vertex in mdist</span>\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">minDistance</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> mdist[], <span class=\"hljs-type\">int</span> vset[], <span class=\"hljs-type\">int</span> V)</span>\r\n{\r\n    <span class=\"hljs-type\">int</span> minVal = INT_MAX, minInd;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++)\r\n        <span class=\"hljs-keyword\">if</span> (vset[i] == <span class=\"hljs-number\">0</span> &amp;&amp; mdist[i] &lt; minVal)\r\n        {\r\n            minVal = mdist[i];\r\n            minInd = i;\r\n        }\r\n\r\n    <span class=\"hljs-keyword\">return</span> minInd;\r\n}\r\n\r\n<span class=\"hljs-comment\">// Utility function to print distances</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">print</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> dist[], <span class=\"hljs-type\">int</span> V)</span>\r\n{\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\nVertex  Distance\\n&quot;</span>);\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++)\r\n    {\r\n        <span class=\"hljs-keyword\">if</span> (dist[i] != INT_MAX)\r\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\t%d\\n&quot;</span>, i, dist[i]);\r\n        <span class=\"hljs-keyword\">else</span>\r\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\tINF&quot;</span>, i);\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">// The main function that finds the shortest path from given source</span>\r\n<span class=\"hljs-comment\">// to all other vertices using Bellman-Ford.It also detects negative</span>\r\n<span class=\"hljs-comment\">// weight cycle</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">BellmanFord</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Graph *graph, <span class=\"hljs-type\">int</span> src)</span>\r\n{\r\n    <span class=\"hljs-type\">int</span> V = graph-&gt;vertexNum;\r\n    <span class=\"hljs-type\">int</span> E = graph-&gt;edgeNum;\r\n    <span class=\"hljs-type\">int</span> dist[V];\r\n\r\n    <span class=\"hljs-comment\">// Initialize distances array as INF for all except source</span>\r\n    <span class=\"hljs-comment\">// Intialize source as zero</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) dist[i] = INT_MAX;\r\n    dist[src] = <span class=\"hljs-number\">0</span>;\r\n\r\n    <span class=\"hljs-comment\">// Calculate shortest path distance from source to all edges</span>\r\n    <span class=\"hljs-comment\">// A path can contain maximum (|V|-1) edges</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= V - <span class=\"hljs-number\">1</span>; i++)\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; E; j++)\r\n        {\r\n            <span class=\"hljs-type\">int</span> u = graph-&gt;edges[j].src;\r\n            <span class=\"hljs-type\">int</span> v = graph-&gt;edges[j].dst;\r\n            <span class=\"hljs-type\">int</span> w = graph-&gt;edges[j].weight;\r\n\r\n            <span class=\"hljs-keyword\">if</span> (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v])\r\n                dist[v] = dist[u] + w;\r\n        }\r\n\r\n    <span class=\"hljs-comment\">// Iterate inner loop once more to check for negative cycle</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; E; j++)\r\n    {\r\n        <span class=\"hljs-type\">int</span> u = graph-&gt;edges[j].src;\r\n        <span class=\"hljs-type\">int</span> v = graph-&gt;edges[j].dst;\r\n        <span class=\"hljs-type\">int</span> w = graph-&gt;edges[j].weight;\r\n\r\n        <span class=\"hljs-keyword\">if</span> (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v])\r\n        {\r\n            <span class=\"hljs-built_in\">printf</span>(\r\n                <span class=\"hljs-string\">&quot;Graph contains negative weight cycle. Hence, shortest &quot;</span>\r\n                <span class=\"hljs-string\">&quot;distance not guaranteed.&quot;</span>);\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n    }\r\n\r\n    print(dist, V);\r\n\r\n    <span class=\"hljs-keyword\">return</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">// Driver Function</span>\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>\r\n{\r\n    <span class=\"hljs-type\">int</span> V, E, gsrc;\r\n    <span class=\"hljs-type\">int</span> src, dst, weight;\r\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Graph</span> <span class=\"hljs-title\">G</span>;</span>\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter number of vertices: &quot;</span>);\r\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;V);\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter number of edges: &quot;</span>);\r\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;E);\r\n    createGraph(&amp;G, V, E);\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; E; i++)\r\n    {\r\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\nEdge %d \\nEnter source: &quot;</span>, i + <span class=\"hljs-number\">1</span>);\r\n        <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;src);\r\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter destination: &quot;</span>);\r\n        <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;dst);\r\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter weight: &quot;</span>);\r\n        <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;weight);\r\n        addEdge(&amp;G, src, dst, weight);\r\n    }\r\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\nEnter source:&quot;</span>);\r\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;gsrc);\r\n    BellmanFord(&amp;G, gsrc);\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    },
    "go": {
      "dir": "graph\\bellmanford.go",
      "url": "https://github.com/TheAlgorithms/go/tree/master/graph\\bellmanford.go",
      "code": "<span class=\"hljs-comment\">// The Bellman–Ford algorithm is an algorithm that computes shortest paths from a</span>\r\n<span class=\"hljs-comment\">// single source vertex to all of the other vertices in a weighted durected graph.</span>\r\n<span class=\"hljs-comment\">// It is slower than Dijkstra but capable of handling negative edge weights.</span>\r\n<span class=\"hljs-comment\">// https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm</span>\r\n<span class=\"hljs-comment\">// Implementation is based on the book &#x27;Introduction to Algorithms&#x27; (CLRS)</span>\r\n\r\n<span class=\"hljs-keyword\">package</span> graph\r\n\r\n<span class=\"hljs-keyword\">import</span> (\r\n\t<span class=\"hljs-string\">&quot;errors&quot;</span>\r\n\t<span class=\"hljs-string\">&quot;math&quot;</span>\r\n)\r\n\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(g *Graph)</span></span> BellmanFord(start, end <span class=\"hljs-type\">int</span>) (isReachable <span class=\"hljs-type\">bool</span>, distance <span class=\"hljs-type\">int</span>, err <span class=\"hljs-type\">error</span>) {\r\n\tINF := math.Inf(<span class=\"hljs-number\">1</span>)\r\n\tdistances := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">float64</span>, g.vertices)\r\n\r\n\t<span class=\"hljs-comment\">// Set all vertices to unreachable, initialize source</span>\r\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; g.vertices; i++ {\r\n\t\tdistances[i] = INF\r\n\t}\r\n\tdistances[start] = <span class=\"hljs-number\">0</span>\r\n\r\n\t<span class=\"hljs-comment\">// Making iterations equal to #vertices</span>\r\n\t<span class=\"hljs-keyword\">for</span> n := <span class=\"hljs-number\">0</span>; n &lt; g.vertices; n++ {\r\n\r\n\t\t<span class=\"hljs-comment\">// Looping over all edges</span>\r\n\t\t<span class=\"hljs-keyword\">for</span> u, adjacents := <span class=\"hljs-keyword\">range</span> g.edges {\r\n\t\t\t<span class=\"hljs-keyword\">for</span> v, weightUV := <span class=\"hljs-keyword\">range</span> adjacents {\r\n\r\n\t\t\t\t<span class=\"hljs-comment\">// If new shorter distance is found, update distance value (relaxation step)</span>\r\n\t\t\t\t<span class=\"hljs-keyword\">if</span> newDistance := distances[u] + <span class=\"hljs-type\">float64</span>(weightUV); distances[v] &gt; newDistance {\r\n\t\t\t\t\tdistances[v] = newDistance\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t<span class=\"hljs-comment\">// Check for negative weight cycle</span>\r\n\t<span class=\"hljs-keyword\">for</span> u, adjacents := <span class=\"hljs-keyword\">range</span> g.edges {\r\n\t\t<span class=\"hljs-keyword\">for</span> v, weightUV := <span class=\"hljs-keyword\">range</span> adjacents {\r\n\t\t\t<span class=\"hljs-keyword\">if</span> newDistance := distances[u] + <span class=\"hljs-type\">float64</span>(weightUV); distances[v] &gt; newDistance {\r\n\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>, <span class=\"hljs-number\">-1</span>, errors.New(<span class=\"hljs-string\">&quot;negative weight cycle present&quot;</span>)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t<span class=\"hljs-keyword\">return</span> distances[end] != INF, <span class=\"hljs-type\">int</span>(distances[end]), <span class=\"hljs-literal\">nil</span>\r\n}\r\n"
    },
    "rust": {
      "dir": "src\\graph\\bellman_ford.rs",
      "url": "https://github.com/TheAlgorithms/rust/tree/master/src\\graph\\bellman_ford.rs",
      "code": "<span class=\"hljs-keyword\">use</span> std::collections::BTreeMap;\r\n<span class=\"hljs-keyword\">use</span> std::ops::Add;\r\n\r\n<span class=\"hljs-keyword\">use</span> std::ops::Neg;\r\n\r\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Graph</span>&lt;V, E&gt; = BTreeMap&lt;V, BTreeMap&lt;V, E&gt;&gt;;\r\n\r\n<span class=\"hljs-comment\">// performs the Bellman-Ford algorithm on the given graph from the given start</span>\r\n<span class=\"hljs-comment\">// the graph is an undirected graph</span>\r\n<span class=\"hljs-comment\">//</span>\r\n<span class=\"hljs-comment\">// if there is a negative weighted loop it returns None</span>\r\n<span class=\"hljs-comment\">// else it returns a map that for each reachable vertex associates the distance and the predecessor</span>\r\n<span class=\"hljs-comment\">// since the start has no predecessor but is reachable, map[start] will be None</span>\r\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">bellman_ford</span>&lt;\r\n    V: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span>,\r\n    E: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span> + Add&lt;Output = E&gt; + Neg&lt;Output = E&gt; + std::ops::Sub&lt;Output = E&gt;,\r\n&gt;(\r\n    graph: &amp;Graph&lt;V, E&gt;,\r\n    start: &amp;V,\r\n) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Option</span>&lt;BTreeMap&lt;V, <span class=\"hljs-type\">Option</span>&lt;(V, E)&gt;&gt;&gt; {\r\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">ans</span>: BTreeMap&lt;V, <span class=\"hljs-type\">Option</span>&lt;(V, E)&gt;&gt; = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n\r\n    ans.<span class=\"hljs-title function_ invoke__\">insert</span>(*start, <span class=\"hljs-literal\">None</span>);\r\n\r\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">_</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..(graph.<span class=\"hljs-title function_ invoke__\">len</span>()) {\r\n        <span class=\"hljs-title function_ invoke__\">for</span> (u, edges) <span class=\"hljs-keyword\">in</span> graph {\r\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">dist_u</span> = <span class=\"hljs-keyword\">match</span> ans.<span class=\"hljs-title function_ invoke__\">get</span>(u) {\r\n                <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-title function_ invoke__\">Some</span>((_, d))) =&gt; <span class=\"hljs-title function_ invoke__\">Some</span>(*d),\r\n                <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-literal\">None</span>) =&gt; <span class=\"hljs-literal\">None</span>,\r\n                <span class=\"hljs-literal\">None</span> =&gt; <span class=\"hljs-keyword\">continue</span>,\r\n            };\r\n\r\n            <span class=\"hljs-title function_ invoke__\">for</span> (v, d) <span class=\"hljs-keyword\">in</span> edges {\r\n                <span class=\"hljs-keyword\">match</span> ans.<span class=\"hljs-title function_ invoke__\">get</span>(v) {\r\n                    <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-title function_ invoke__\">Some</span>((_, dist)))\r\n                        <span class=\"hljs-comment\">// if this is a longer path, do nothing</span>\r\n                        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">match</span> dist_u {\r\n                            <span class=\"hljs-title function_ invoke__\">Some</span>(dist_u) =&gt; dist_u + *d &gt;= *dist,\r\n                            <span class=\"hljs-literal\">None</span> =&gt; d &gt;= dist,\r\n                        } =&gt; {}\r\n                    <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-literal\">None</span>) =&gt; {\r\n                        <span class=\"hljs-keyword\">match</span> dist_u {\r\n                            <span class=\"hljs-comment\">// if dist_u + d &lt; 0 there is a negative loop going by start</span>\r\n                            <span class=\"hljs-comment\">// else it&#x27;s just a longer path</span>\r\n                            <span class=\"hljs-title function_ invoke__\">Some</span>(dist_u) <span class=\"hljs-keyword\">if</span> dist_u &gt;= -*d =&gt; {}\r\n                            <span class=\"hljs-comment\">// negative self edge or negative loop</span>\r\n                            _ =&gt; {\r\n                                <span class=\"hljs-keyword\">if</span> *d &gt; *d + *d {\r\n                                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>;\r\n                                }\r\n                            }\r\n                        };\r\n                    }\r\n                    <span class=\"hljs-comment\">// it&#x27;s a shorter path: either dist_v was infinite or it was longer than dist_u + d</span>\r\n                    _ =&gt; {\r\n                        ans.<span class=\"hljs-title function_ invoke__\">insert</span>(\r\n                            *v,\r\n                            <span class=\"hljs-title function_ invoke__\">Some</span>((\r\n                                *u,\r\n                                <span class=\"hljs-keyword\">match</span> dist_u {\r\n                                    <span class=\"hljs-title function_ invoke__\">Some</span>(dist) =&gt; dist + *d,\r\n                                    <span class=\"hljs-literal\">None</span> =&gt; *d,\r\n                                },\r\n                            )),\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-title function_ invoke__\">for</span> (u, edges) <span class=\"hljs-keyword\">in</span> graph {\r\n        <span class=\"hljs-title function_ invoke__\">for</span> (v, d) <span class=\"hljs-keyword\">in</span> edges {\r\n            <span class=\"hljs-title function_ invoke__\">match</span> (ans.<span class=\"hljs-title function_ invoke__\">get</span>(u), ans.<span class=\"hljs-title function_ invoke__\">get</span>(v)) {\r\n                (<span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-literal\">None</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-literal\">None</span>)) <span class=\"hljs-keyword\">if</span> *d &gt; *d + *d =&gt; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>,\r\n                (<span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-literal\">None</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-title function_ invoke__\">Some</span>((_, dv)))) <span class=\"hljs-keyword\">if</span> d &lt; dv =&gt; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>,\r\n                (<span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-title function_ invoke__\">Some</span>((_, du))), <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-literal\">None</span>)) <span class=\"hljs-keyword\">if</span> *du &lt; -*d =&gt; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>,\r\n                (<span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-title function_ invoke__\">Some</span>((_, du))), <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-title function_ invoke__\">Some</span>((_, dv)))) <span class=\"hljs-keyword\">if</span> *du + *d &lt; *dv =&gt; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>,\r\n                (_, _) =&gt; {}\r\n            }\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-title function_ invoke__\">Some</span>(ans)\r\n}\r\n\r\n<span class=\"hljs-meta\">#[cfg(test)]</span>\r\n<span class=\"hljs-keyword\">mod</span> tests {\r\n    <span class=\"hljs-keyword\">use</span> super::{bellman_ford, Graph};\r\n    <span class=\"hljs-keyword\">use</span> std::collections::BTreeMap;\r\n\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">add_edge</span>&lt;V: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span>, E: <span class=\"hljs-built_in\">Ord</span>&gt;(graph: &amp;<span class=\"hljs-keyword\">mut</span> Graph&lt;V, E&gt;, v1: V, v2: V, c: E) {\r\n        graph.<span class=\"hljs-title function_ invoke__\">entry</span>(v1).<span class=\"hljs-title function_ invoke__\">or_insert_with</span>(BTreeMap::new).<span class=\"hljs-title function_ invoke__\">insert</span>(v2, c);\r\n        graph.<span class=\"hljs-title function_ invoke__\">entry</span>(v2).<span class=\"hljs-title function_ invoke__\">or_insert_with</span>(BTreeMap::new);\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">single_vertex</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span>: Graph&lt;<span class=\"hljs-type\">isize</span>, <span class=\"hljs-type\">isize</span>&gt; = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        graph.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>());\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        dists.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">None</span>);\r\n\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">0</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists));\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">single_edge</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_0</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        dists_0.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">None</span>);\r\n        dists_0.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>)));\r\n\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">0</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_0));\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_1</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        dists_1.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">None</span>);\r\n\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">1</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_1));\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">tree_1</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        dists.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">None</span>);\r\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..<span class=\"hljs-number\">100</span> {\r\n            <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, i, i * <span class=\"hljs-number\">2</span>, i * <span class=\"hljs-number\">2</span>);\r\n            <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, i, i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>, i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>);\r\n\r\n            <span class=\"hljs-keyword\">match</span> dists[&amp;i] {\r\n                <span class=\"hljs-title function_ invoke__\">Some</span>((_, d)) =&gt; {\r\n                    dists.<span class=\"hljs-title function_ invoke__\">insert</span>(i * <span class=\"hljs-number\">2</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((i, d + i * <span class=\"hljs-number\">2</span>)));\r\n                    dists.<span class=\"hljs-title function_ invoke__\">insert</span>(i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((i, d + i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>)));\r\n                }\r\n                <span class=\"hljs-literal\">None</span> =&gt; {\r\n                    dists.<span class=\"hljs-title function_ invoke__\">insert</span>(i * <span class=\"hljs-number\">2</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((i, i * <span class=\"hljs-number\">2</span>)));\r\n                    dists.<span class=\"hljs-title function_ invoke__\">insert</span>(i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((i, i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>)));\r\n                }\r\n            }\r\n        }\r\n\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">1</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists));\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">graph_1</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">12</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-number\">60</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">10</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">20</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-number\">32</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">7</span>);\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_a</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        dists_a.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-literal\">None</span>);\r\n        dists_a.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">12</span>)));\r\n        dists_a.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">44</span>)));\r\n        dists_a.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">32</span>)));\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-string\">&#x27;a&#x27;</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_a));\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_b</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        dists_b.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-literal\">None</span>);\r\n        dists_b.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">10</span>)));\r\n        dists_b.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">22</span>)));\r\n        dists_b.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">54</span>)));\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-string\">&#x27;b&#x27;</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_b));\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_c</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        dists_c.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-literal\">None</span>);\r\n        dists_c.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">20</span>)));\r\n        dists_c.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">32</span>)));\r\n        dists_c.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">30</span>)));\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-string\">&#x27;c&#x27;</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_c));\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_d</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        dists_d.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-literal\">None</span>);\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-string\">&#x27;d&#x27;</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_d));\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_e</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        dists_e.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-literal\">None</span>);\r\n        dists_e.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-number\">7</span>)));\r\n        dists_e.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">19</span>)));\r\n        dists_e.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">51</span>)));\r\n        dists_e.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">39</span>)));\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-string\">&#x27;e&#x27;</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_e));\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">graph_2</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">6</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">8</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, -<span class=\"hljs-number\">4</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">2</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">3</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">9</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>);\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_0</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        dists_0.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">None</span>);\r\n        dists_0.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>)));\r\n        dists_0.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)));\r\n        dists_0.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">7</span>)));\r\n        dists_0.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">2</span>)));\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">0</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_0));\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_1</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        dists_1.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">4</span>, -<span class=\"hljs-number\">1</span>)));\r\n        dists_1.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">None</span>);\r\n        dists_1.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>)));\r\n        dists_1.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">6</span>)));\r\n        dists_1.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">4</span>)));\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">1</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_1));\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_2</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        dists_2.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">4</span>, -<span class=\"hljs-number\">3</span>)));\r\n        dists_2.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">2</span>)));\r\n        dists_2.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">None</span>);\r\n        dists_2.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">4</span>)));\r\n        dists_2.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">6</span>)));\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">2</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_2));\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_3</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        dists_3.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">4</span>, -<span class=\"hljs-number\">6</span>)));\r\n        dists_3.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">5</span>)));\r\n        dists_3.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">3</span>, -<span class=\"hljs-number\">3</span>)));\r\n        dists_3.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-literal\">None</span>);\r\n        dists_3.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">9</span>)));\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">3</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_3));\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_4</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        dists_4.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>)));\r\n        dists_4.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>)));\r\n        dists_4.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">7</span>)));\r\n        dists_4.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>)));\r\n        dists_4.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-literal\">None</span>);\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">4</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_4));\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">graph_with_negative_loop</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">6</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">8</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, -<span class=\"hljs-number\">4</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">4</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">3</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">9</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>);\r\n\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">0</span>), <span class=\"hljs-literal\">None</span>);\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">1</span>), <span class=\"hljs-literal\">None</span>);\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">2</span>), <span class=\"hljs-literal\">None</span>);\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">3</span>), <span class=\"hljs-literal\">None</span>);\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">4</span>), <span class=\"hljs-literal\">None</span>);\r\n    }\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "PalAditya",
      "email": "adityapal.nghss@gmail.com",
      "commits": 1
    },
    {
      "name": "Pierre Gimalac",
      "email": "pierre.gimalac@gmail.com",
      "commits": 1
    },
    {
      "name": "Taj",
      "email": "tjgurwara99@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Tahmeed Tarek",
      "email": "tahmeedtarek@gmail.com",
      "commits": 1
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "hasan",
      "email": "hasanuli10@gmail.com",
      "commits": 1
    },
    {
      "name": "ParthS007",
      "email": "parth1989shandilya@gmail.com",
      "commits": 1
    },
    {
      "name": "Aitor Fidalgo Sánchez",
      "email": "64830228+aitorfi@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Nishant Chatterjee",
      "email": "52992695+nishantc1527@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Maria Lungeanu",
      "email": "Maria.Lungeanu@anritsu.com",
      "commits": 1
    },
    {
      "name": "John Law",
      "email": "johnlaw.po@gmail.com",
      "commits": 1
    },
    {
      "name": "matkosoric",
      "email": "soric.matko@gmail.com",
      "commits": 1
    },
    {
      "name": "JakobZhao",
      "email": "52325554+JakobMusik@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "cclauss",
      "email": "cclauss@bluewin.ch",
      "commits": 1
    },
    {
      "name": "ashu01",
      "email": "as01hu@gmail.com",
      "commits": 1
    },
    {
      "name": "AlexDvorak",
      "email": "opti.jawsome@gmail.com",
      "commits": 2
    },
    {
      "name": "Libin Yang",
      "email": "szuyanglb@outlook.com",
      "commits": 2
    },
    {
      "name": "Mayank Mamgain",
      "email": "56592363+Mayank17M@users.noreply.github.com",
      "commits": 2
    },
    {
      "name": "Hassan",
      "email": "hassan.elseoudy@gmail.com",
      "commits": 2
    },
    {
      "name": "Sameer Ahmed Khan",
      "email": "68906588+sameerahmedk@users.noreply.github.com",
      "commits": 3
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 5
    },
    {
      "name": "arpanjain97",
      "email": "arpanjain97@gmail.com",
      "commits": 5
    }
  ],
  "explanationUrl": {
    "en": "https://github.com/TheAlgorithms/Algorithms-Explanation/tree/master/en\\Data Structures\\Graph\\Bellman-Ford.md",
    "es": "https://github.com/TheAlgorithms/Algorithms-Explanation/tree/master/es\\Estructuras de datos\\Gráfico\\Bellman Ford.md"
  }
}