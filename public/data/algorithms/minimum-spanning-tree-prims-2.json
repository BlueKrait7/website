{
  "slug": "minimum-spanning-tree-prims-2",
  "name": "Minimum Spanning Tree Prims 2",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "graphs\\minimum_spanning_tree_prims2.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/graphs\\minimum_spanning_tree_prims2.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;\r\nPrim&#x27;s (also known as Jarn√≠k&#x27;s) algorithm is a greedy algorithm that finds a minimum\r\nspanning tree for a weighted undirected graph. This means it finds a subset of the\r\nedges that forms a tree that includes every vertex, where the total weight of all the\r\nedges in the tree is minimized. The algorithm operates by building this tree one vertex\r\nat a time, from an arbitrary starting vertex, at each step adding the cheapest possible\r\nconnection from the tree to another vertex.\r\n&quot;&quot;&quot;</span>\r\n<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\r\n\r\n<span class=\"hljs-keyword\">from</span> sys <span class=\"hljs-keyword\">import</span> maxsize\r\n<span class=\"hljs-keyword\">from</span> typing <span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">Generic</span>, TypeVar\r\n\r\nT = TypeVar(<span class=\"hljs-string\">&quot;T&quot;</span>)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_parent_position</span>(<span class=\"hljs-params\">position: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    heap helper function get the position of the parent of the current node\r\n\r\n    &gt;&gt;&gt; get_parent_position(1)\r\n    0\r\n    &gt;&gt;&gt; get_parent_position(2)\r\n    0\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-keyword\">return</span> (position - <span class=\"hljs-number\">1</span>) // <span class=\"hljs-number\">2</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_child_left_position</span>(<span class=\"hljs-params\">position: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    heap helper function get the position of the left child of the current node\r\n\r\n    &gt;&gt;&gt; get_child_left_position(0)\r\n    1\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">2</span> * position) + <span class=\"hljs-number\">1</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_child_right_position</span>(<span class=\"hljs-params\">position: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    heap helper function get the position of the right child of the current node\r\n\r\n    &gt;&gt;&gt; get_child_right_position(0)\r\n    2\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">2</span> * position) + <span class=\"hljs-number\">2</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MinPriorityQueue</span>(<span class=\"hljs-type\">Generic</span>[T]):\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Minimum Priority Queue Class\r\n\r\n    Functions:\r\n    is_empty: function to check if the priority queue is empty\r\n    push: function to add an element with given priority to the queue\r\n    extract_min: function to remove and return the element with lowest weight (highest\r\n                 priority)\r\n    update_key: function to update the weight of the given key\r\n    _bubble_up: helper function to place a node at the proper position (upward\r\n                movement)\r\n    _bubble_down: helper function to place a node at the proper position (downward\r\n                movement)\r\n    _swap_nodes: helper function to swap the nodes at the given positions\r\n\r\n    &gt;&gt;&gt; queue = MinPriorityQueue()\r\n\r\n    &gt;&gt;&gt; queue.push(1, 1000)\r\n    &gt;&gt;&gt; queue.push(2, 100)\r\n    &gt;&gt;&gt; queue.push(3, 4000)\r\n    &gt;&gt;&gt; queue.push(4, 3000)\r\n\r\n    &gt;&gt;&gt; print(queue.extract_min())\r\n    2\r\n\r\n    &gt;&gt;&gt; queue.update_key(4, 50)\r\n\r\n    &gt;&gt;&gt; print(queue.extract_min())\r\n    4\r\n    &gt;&gt;&gt; print(queue.extract_min())\r\n    1\r\n    &gt;&gt;&gt; print(queue.extract_min())\r\n    3\r\n    &quot;&quot;&quot;</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        self.heap: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">tuple</span>[T, <span class=\"hljs-built_in\">int</span>]] = []\r\n        self.position_map: <span class=\"hljs-built_in\">dict</span>[T, <span class=\"hljs-built_in\">int</span>] = {}\r\n        self.elements: <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">0</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__len__</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\r\n        <span class=\"hljs-keyword\">return</span> self.elements\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__repr__</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-built_in\">str</span>:\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">str</span>(self.heap)\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">is_empty</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\r\n        <span class=\"hljs-comment\"># Check if the priority queue is empty</span>\r\n        <span class=\"hljs-keyword\">return</span> self.elements == <span class=\"hljs-number\">0</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">push</span>(<span class=\"hljs-params\">self, elem: T, weight: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-comment\"># Add an element with given priority to the queue</span>\r\n        self.heap.append((elem, weight))\r\n        self.position_map[elem] = self.elements\r\n        self.elements += <span class=\"hljs-number\">1</span>\r\n        self._bubble_up(elem)\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">extract_min</span>(<span class=\"hljs-params\">self</span>) -&gt; T:\r\n        <span class=\"hljs-comment\"># Remove and return the element with lowest weight (highest priority)</span>\r\n        <span class=\"hljs-keyword\">if</span> self.elements &gt; <span class=\"hljs-number\">1</span>:\r\n            self._swap_nodes(<span class=\"hljs-number\">0</span>, self.elements - <span class=\"hljs-number\">1</span>)\r\n        elem, _ = self.heap.pop()\r\n        <span class=\"hljs-keyword\">del</span> self.position_map[elem]\r\n        self.elements -= <span class=\"hljs-number\">1</span>\r\n        <span class=\"hljs-keyword\">if</span> self.elements &gt; <span class=\"hljs-number\">0</span>:\r\n            bubble_down_elem, _ = self.heap[<span class=\"hljs-number\">0</span>]\r\n            self._bubble_down(bubble_down_elem)\r\n        <span class=\"hljs-keyword\">return</span> elem\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">update_key</span>(<span class=\"hljs-params\">self, elem: T, weight: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-comment\"># Update the weight of the given key</span>\r\n        position = self.position_map[elem]\r\n        self.heap[position] = (elem, weight)\r\n        <span class=\"hljs-keyword\">if</span> position &gt; <span class=\"hljs-number\">0</span>:\r\n            parent_position = get_parent_position(position)\r\n            _, parent_weight = self.heap[parent_position]\r\n            <span class=\"hljs-keyword\">if</span> parent_weight &gt; weight:\r\n                self._bubble_up(elem)\r\n            <span class=\"hljs-keyword\">else</span>:\r\n                self._bubble_down(elem)\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            self._bubble_down(elem)\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_bubble_up</span>(<span class=\"hljs-params\">self, elem: T</span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-comment\"># Place a node at the proper position (upward movement) [to be used internally</span>\r\n        <span class=\"hljs-comment\"># only]</span>\r\n        curr_pos = self.position_map[elem]\r\n        <span class=\"hljs-keyword\">if</span> curr_pos == <span class=\"hljs-number\">0</span>:\r\n            <span class=\"hljs-keyword\">return</span>\r\n        parent_position = get_parent_position(curr_pos)\r\n        _, weight = self.heap[curr_pos]\r\n        _, parent_weight = self.heap[parent_position]\r\n        <span class=\"hljs-keyword\">if</span> parent_weight &gt; weight:\r\n            self._swap_nodes(parent_position, curr_pos)\r\n            <span class=\"hljs-keyword\">return</span> self._bubble_up(elem)\r\n        <span class=\"hljs-keyword\">return</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_bubble_down</span>(<span class=\"hljs-params\">self, elem: T</span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-comment\"># Place a node at the proper position (downward movement) [to be used</span>\r\n        <span class=\"hljs-comment\"># internally only]</span>\r\n        curr_pos = self.position_map[elem]\r\n        _, weight = self.heap[curr_pos]\r\n        child_left_position = get_child_left_position(curr_pos)\r\n        child_right_position = get_child_right_position(curr_pos)\r\n        <span class=\"hljs-keyword\">if</span> child_left_position &lt; self.elements <span class=\"hljs-keyword\">and</span> child_right_position &lt; self.elements:\r\n            _, child_left_weight = self.heap[child_left_position]\r\n            _, child_right_weight = self.heap[child_right_position]\r\n            <span class=\"hljs-keyword\">if</span> child_right_weight &lt; child_left_weight:\r\n                <span class=\"hljs-keyword\">if</span> child_right_weight &lt; weight:\r\n                    self._swap_nodes(child_right_position, curr_pos)\r\n                    <span class=\"hljs-keyword\">return</span> self._bubble_down(elem)\r\n        <span class=\"hljs-keyword\">if</span> child_left_position &lt; self.elements:\r\n            _, child_left_weight = self.heap[child_left_position]\r\n            <span class=\"hljs-keyword\">if</span> child_left_weight &lt; weight:\r\n                self._swap_nodes(child_left_position, curr_pos)\r\n                <span class=\"hljs-keyword\">return</span> self._bubble_down(elem)\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            <span class=\"hljs-keyword\">return</span>\r\n        <span class=\"hljs-keyword\">if</span> child_right_position &lt; self.elements:\r\n            _, child_right_weight = self.heap[child_right_position]\r\n            <span class=\"hljs-keyword\">if</span> child_right_weight &lt; weight:\r\n                self._swap_nodes(child_right_position, curr_pos)\r\n                <span class=\"hljs-keyword\">return</span> self._bubble_down(elem)\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            <span class=\"hljs-keyword\">return</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_swap_nodes</span>(<span class=\"hljs-params\">self, node1_pos: <span class=\"hljs-built_in\">int</span>, node2_pos: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-comment\"># Swap the nodes at the given positions</span>\r\n        node1_elem = self.heap[node1_pos][<span class=\"hljs-number\">0</span>]\r\n        node2_elem = self.heap[node2_pos][<span class=\"hljs-number\">0</span>]\r\n        self.heap[node1_pos], self.heap[node2_pos] = (\r\n            self.heap[node2_pos],\r\n            self.heap[node1_pos],\r\n        )\r\n        self.position_map[node1_elem] = node2_pos\r\n        self.position_map[node2_elem] = node1_pos\r\n\r\n\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GraphUndirectedWeighted</span>(<span class=\"hljs-type\">Generic</span>[T]):\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Graph Undirected Weighted Class\r\n\r\n    Functions:\r\n    add_node: function to add a node in the graph\r\n    add_edge: function to add an edge between 2 nodes in the graph\r\n    &quot;&quot;&quot;</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        self.connections: <span class=\"hljs-built_in\">dict</span>[T, <span class=\"hljs-built_in\">dict</span>[T, <span class=\"hljs-built_in\">int</span>]] = {}\r\n        self.nodes: <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">0</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__repr__</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-built_in\">str</span>:\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">str</span>(self.connections)\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__len__</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\r\n        <span class=\"hljs-keyword\">return</span> self.nodes\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_node</span>(<span class=\"hljs-params\">self, node: T</span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-comment\"># Add a node in the graph if it is not in the graph</span>\r\n        <span class=\"hljs-keyword\">if</span> node <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> self.connections:\r\n            self.connections[node] = {}\r\n            self.nodes += <span class=\"hljs-number\">1</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_edge</span>(<span class=\"hljs-params\">self, node1: T, node2: T, weight: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-comment\"># Add an edge between 2 nodes in the graph</span>\r\n        self.add_node(node1)\r\n        self.add_node(node2)\r\n        self.connections[node1][node2] = weight\r\n        self.connections[node2][node1] = weight\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">prims_algo</span>(<span class=\"hljs-params\">\r\n    graph: GraphUndirectedWeighted[T],\r\n</span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">dict</span>[T, <span class=\"hljs-built_in\">int</span>], <span class=\"hljs-built_in\">dict</span>[T, T | <span class=\"hljs-literal\">None</span>]]:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    &gt;&gt;&gt; graph = GraphUndirectedWeighted()\r\n\r\n    &gt;&gt;&gt; graph.add_edge(&quot;a&quot;, &quot;b&quot;, 3)\r\n    &gt;&gt;&gt; graph.add_edge(&quot;b&quot;, &quot;c&quot;, 10)\r\n    &gt;&gt;&gt; graph.add_edge(&quot;c&quot;, &quot;d&quot;, 5)\r\n    &gt;&gt;&gt; graph.add_edge(&quot;a&quot;, &quot;c&quot;, 15)\r\n    &gt;&gt;&gt; graph.add_edge(&quot;b&quot;, &quot;d&quot;, 100)\r\n\r\n    &gt;&gt;&gt; dist, parent = prims_algo(graph)\r\n\r\n    &gt;&gt;&gt; abs(dist[&quot;a&quot;] - dist[&quot;b&quot;])\r\n    3\r\n    &gt;&gt;&gt; abs(dist[&quot;d&quot;] - dist[&quot;b&quot;])\r\n    15\r\n    &gt;&gt;&gt; abs(dist[&quot;a&quot;] - dist[&quot;c&quot;])\r\n    13\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-comment\"># prim&#x27;s algorithm for minimum spanning tree</span>\r\n    dist: <span class=\"hljs-built_in\">dict</span>[T, <span class=\"hljs-built_in\">int</span>] = {node: maxsize <span class=\"hljs-keyword\">for</span> node <span class=\"hljs-keyword\">in</span> graph.connections}\r\n    parent: <span class=\"hljs-built_in\">dict</span>[T, T | <span class=\"hljs-literal\">None</span>] = {node: <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">for</span> node <span class=\"hljs-keyword\">in</span> graph.connections}\r\n\r\n    priority_queue: MinPriorityQueue[T] = MinPriorityQueue()\r\n    <span class=\"hljs-keyword\">for</span> node, weight <span class=\"hljs-keyword\">in</span> dist.items():\r\n        priority_queue.push(node, weight)\r\n\r\n    <span class=\"hljs-keyword\">if</span> priority_queue.is_empty():\r\n        <span class=\"hljs-keyword\">return</span> dist, parent\r\n\r\n    <span class=\"hljs-comment\"># initialization</span>\r\n    node = priority_queue.extract_min()\r\n    dist[node] = <span class=\"hljs-number\">0</span>\r\n    <span class=\"hljs-keyword\">for</span> neighbour <span class=\"hljs-keyword\">in</span> graph.connections[node]:\r\n        <span class=\"hljs-keyword\">if</span> dist[neighbour] &gt; dist[node] + graph.connections[node][neighbour]:\r\n            dist[neighbour] = dist[node] + graph.connections[node][neighbour]\r\n            priority_queue.update_key(neighbour, dist[neighbour])\r\n            parent[neighbour] = node\r\n\r\n    <span class=\"hljs-comment\"># running prim&#x27;s algorithm</span>\r\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">not</span> priority_queue.is_empty():\r\n        node = priority_queue.extract_min()\r\n        <span class=\"hljs-keyword\">for</span> neighbour <span class=\"hljs-keyword\">in</span> graph.connections[node]:\r\n            <span class=\"hljs-keyword\">if</span> dist[neighbour] &gt; dist[node] + graph.connections[node][neighbour]:\r\n                dist[neighbour] = dist[node] + graph.connections[node][neighbour]\r\n                priority_queue.update_key(neighbour, dist[neighbour])\r\n                parent[neighbour] = node\r\n    <span class=\"hljs-keyword\">return</span> dist, parent\r\n"
    }
  },
  "contributors": [
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 1
    },
    {
      "name": "hasan",
      "email": "hasanuli10@gmail.com",
      "commits": 1
    },
    {
      "name": "Tapajyoti Bose",
      "email": "44058757+ruppysuppy@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}