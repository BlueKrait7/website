{
  "slug": "kmeans",
  "name": "Kmeans",
  "categories": [
    "general"
  ],
  "body": {},
  "implementations": {
    "rust": {
      "dir": "src\\general\\kmeans.rs",
      "url": "https://github.com/TheAlgorithms/rust/tree/master/src\\general\\kmeans.rs",
      "code": "<span class=\"hljs-comment\">// Macro to implement kmeans for both f64 and f32 without writing everything</span>\r\n<span class=\"hljs-comment\">// twice or importing the `num` crate</span>\r\n<span class=\"hljs-built_in\">macro_rules!</span> impl_kmeans {\r\n    ($kind: ty, $modname: ident) =&gt; {\r\n        <span class=\"hljs-comment\">// Since we can&#x27;t overload methods in rust, we have to use namespacing</span>\r\n        <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">mod</span> $modname {\r\n            <span class=\"hljs-keyword\">use</span> std::$modname::INFINITY;\r\n\r\n            <span class=\"hljs-comment\">/// computes sum of squared deviation between two identically sized vectors</span>\r\n            <span class=\"hljs-comment\">/// `x`, and `y`.</span>\r\n            <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">distance</span>(x: &amp;[$kind], y: &amp;[$kind]) <span class=\"hljs-punctuation\">-&gt;</span> $kind {\r\n                x.<span class=\"hljs-title function_ invoke__\">iter</span>()\r\n                    .<span class=\"hljs-title function_ invoke__\">zip</span>(y.<span class=\"hljs-title function_ invoke__\">iter</span>())\r\n                    .<span class=\"hljs-title function_ invoke__\">fold</span>(<span class=\"hljs-number\">0.0</span>, |dist, (&amp;xi, &amp;yi)| dist + (xi - yi).<span class=\"hljs-title function_ invoke__\">powi</span>(<span class=\"hljs-number\">2</span>))\r\n            }\r\n\r\n            <span class=\"hljs-comment\">/// Returns a vector containing the indices z&lt;sub&gt;i&lt;/sub&gt; in {0, ..., K-1} of</span>\r\n            <span class=\"hljs-comment\">/// the centroid nearest to each datum.</span>\r\n            <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">nearest_centroids</span>(xs: &amp;[<span class=\"hljs-type\">Vec</span>&lt;$kind&gt;], centroids: &amp;[<span class=\"hljs-type\">Vec</span>&lt;$kind&gt;]) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">usize</span>&gt; {\r\n                xs.<span class=\"hljs-title function_ invoke__\">iter</span>()\r\n                    .<span class=\"hljs-title function_ invoke__\">map</span>(|xi| {\r\n                        <span class=\"hljs-comment\">// Find the argmin by folding using a tuple containing the argmin</span>\r\n                        <span class=\"hljs-comment\">// and the minimum distance.</span>\r\n                        <span class=\"hljs-keyword\">let</span> (argmin, _) = centroids.<span class=\"hljs-title function_ invoke__\">iter</span>().<span class=\"hljs-title function_ invoke__\">enumerate</span>().<span class=\"hljs-title function_ invoke__\">fold</span>(\r\n                            (<span class=\"hljs-number\">0_usize</span>, INFINITY),\r\n                            |(min_ix, min_dist), (ix, ci)| {\r\n                                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">dist</span> = <span class=\"hljs-title function_ invoke__\">distance</span>(xi, ci);\r\n                                <span class=\"hljs-keyword\">if</span> dist &lt; min_dist {\r\n                                    (ix, dist)\r\n                                } <span class=\"hljs-keyword\">else</span> {\r\n                                    (min_ix, min_dist)\r\n                                }\r\n                            },\r\n                        );\r\n                        argmin\r\n                    })\r\n                    .<span class=\"hljs-title function_ invoke__\">collect</span>()\r\n            }\r\n\r\n            <span class=\"hljs-comment\">/// Recompute the centroids given the current clustering</span>\r\n            <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">recompute_centroids</span>(\r\n                xs: &amp;[<span class=\"hljs-type\">Vec</span>&lt;$kind&gt;],\r\n                clustering: &amp;[<span class=\"hljs-type\">usize</span>],\r\n                k: <span class=\"hljs-type\">usize</span>,\r\n            ) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">Vec</span>&lt;$kind&gt;&gt; {\r\n                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">ndims</span> = xs[<span class=\"hljs-number\">0</span>].<span class=\"hljs-title function_ invoke__\">len</span>();\r\n\r\n                <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">NOTE:</span> Kind of inefficient because we sweep all the data from each of the</span>\r\n                <span class=\"hljs-comment\">// k centroids.</span>\r\n                (<span class=\"hljs-number\">0</span>..k)\r\n                    .<span class=\"hljs-title function_ invoke__\">map</span>(|cluster_ix| {\r\n                        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">centroid</span>: <span class=\"hljs-type\">Vec</span>&lt;$kind&gt; = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0.0</span>; ndims];\r\n                        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">n_cluster</span>: $kind = <span class=\"hljs-number\">0.0</span>;\r\n                        xs.<span class=\"hljs-title function_ invoke__\">iter</span>().<span class=\"hljs-title function_ invoke__\">zip</span>(clustering.<span class=\"hljs-title function_ invoke__\">iter</span>()).<span class=\"hljs-title function_ invoke__\">for_each</span>(|(xi, &amp;zi)| {\r\n                            <span class=\"hljs-keyword\">if</span> zi == cluster_ix {\r\n                                n_cluster += <span class=\"hljs-number\">1.0</span>;\r\n                                xi.<span class=\"hljs-title function_ invoke__\">iter</span>().<span class=\"hljs-title function_ invoke__\">enumerate</span>().<span class=\"hljs-title function_ invoke__\">for_each</span>(|(j, &amp;x_ij)| {\r\n                                    centroid[j] += x_ij;\r\n                                });\r\n                            }\r\n                        });\r\n                        centroid.<span class=\"hljs-title function_ invoke__\">iter</span>().<span class=\"hljs-title function_ invoke__\">map</span>(|&amp;c_j| c_j / n_cluster).<span class=\"hljs-title function_ invoke__\">collect</span>()\r\n                    })\r\n                    .<span class=\"hljs-title function_ invoke__\">collect</span>()\r\n            }\r\n\r\n            <span class=\"hljs-comment\">/// Assign the N D-dimensional data, `xs`, to `k` clusters using K-Means clustering</span>\r\n            <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">kmeans</span>(xs: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">Vec</span>&lt;$kind&gt;&gt;, k: <span class=\"hljs-type\">usize</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">usize</span>&gt; {\r\n                <span class=\"hljs-built_in\">assert!</span>(xs.<span class=\"hljs-title function_ invoke__\">len</span>() &gt;= k);\r\n\r\n                <span class=\"hljs-comment\">// Rather than pulling in a dependency to radomly select the staring</span>\r\n                <span class=\"hljs-comment\">// points for the centroids, we&#x27;re going to deterministally choose them by</span>\r\n                <span class=\"hljs-comment\">// slecting evenly spaced points in `xs`</span>\r\n                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">n_per_cluster</span>: <span class=\"hljs-type\">usize</span> = xs.<span class=\"hljs-title function_ invoke__\">len</span>() / k;\r\n                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">centroids</span>: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">Vec</span>&lt;$kind&gt;&gt; =\r\n                    (<span class=\"hljs-number\">0</span>..k).<span class=\"hljs-title function_ invoke__\">map</span>(|j| xs[j * n_per_cluster].<span class=\"hljs-title function_ invoke__\">clone</span>()).<span class=\"hljs-title function_ invoke__\">collect</span>();\r\n\r\n                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">clustering</span> = <span class=\"hljs-title function_ invoke__\">nearest_centroids</span>(&amp;xs, &amp;centroids);\r\n\r\n                <span class=\"hljs-keyword\">loop</span> {\r\n                    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">centroids</span> = <span class=\"hljs-title function_ invoke__\">recompute_centroids</span>(&amp;xs, &amp;clustering, k);\r\n                    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">new_clustering</span> = <span class=\"hljs-title function_ invoke__\">nearest_centroids</span>(&amp;xs, &amp;centroids);\r\n\r\n                    <span class=\"hljs-comment\">// loop until the clustering doesn&#x27;t change after the new centroids are computed</span>\r\n                    <span class=\"hljs-keyword\">if</span> new_clustering\r\n                        .<span class=\"hljs-title function_ invoke__\">iter</span>()\r\n                        .<span class=\"hljs-title function_ invoke__\">zip</span>(clustering.<span class=\"hljs-title function_ invoke__\">iter</span>())\r\n                        .<span class=\"hljs-title function_ invoke__\">all</span>(|(&amp;za, &amp;zb)| za == zb)\r\n                    {\r\n                        <span class=\"hljs-comment\">// We need to use `return` to break out of the `loop`</span>\r\n                        <span class=\"hljs-keyword\">return</span> clustering;\r\n                    } <span class=\"hljs-keyword\">else</span> {\r\n                        clustering = new_clustering;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n<span class=\"hljs-comment\">// generate code for kmeans for f32 and f64 data</span>\r\nimpl_kmeans!(<span class=\"hljs-type\">f64</span>, <span class=\"hljs-type\">f64</span>);\r\nimpl_kmeans!(<span class=\"hljs-type\">f32</span>, <span class=\"hljs-type\">f32</span>);\r\n\r\n<span class=\"hljs-meta\">#[cfg(test)]</span>\r\n<span class=\"hljs-keyword\">mod</span> test {\r\n    <span class=\"hljs-keyword\">use</span> self::super::f64::kmeans;\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">easy_univariate_clustering</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">xs</span>: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">f64</span>&gt;&gt; = <span class=\"hljs-built_in\">vec!</span>[\r\n            <span class=\"hljs-built_in\">vec!</span>[-<span class=\"hljs-number\">1.1</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[-<span class=\"hljs-number\">1.2</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[-<span class=\"hljs-number\">1.3</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[-<span class=\"hljs-number\">1.4</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.1</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.2</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.3</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.4</span>],\r\n        ];\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">clustering</span> = <span class=\"hljs-title function_ invoke__\">kmeans</span>(xs, <span class=\"hljs-number\">2</span>);\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(clustering, <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>]);\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">easy_univariate_clustering_odd_number_of_data</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">xs</span>: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">f64</span>&gt;&gt; = <span class=\"hljs-built_in\">vec!</span>[\r\n            <span class=\"hljs-built_in\">vec!</span>[-<span class=\"hljs-number\">1.1</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[-<span class=\"hljs-number\">1.2</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[-<span class=\"hljs-number\">1.3</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[-<span class=\"hljs-number\">1.4</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.1</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.2</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.3</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.4</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.5</span>],\r\n        ];\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">clustering</span> = <span class=\"hljs-title function_ invoke__\">kmeans</span>(xs, <span class=\"hljs-number\">2</span>);\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(clustering, <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>]);\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">easy_bivariate_clustering</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">xs</span>: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">f64</span>&gt;&gt; = <span class=\"hljs-built_in\">vec!</span>[\r\n            <span class=\"hljs-built_in\">vec!</span>[-<span class=\"hljs-number\">1.1</span>, <span class=\"hljs-number\">0.2</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[-<span class=\"hljs-number\">1.2</span>, <span class=\"hljs-number\">0.3</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[-<span class=\"hljs-number\">1.3</span>, <span class=\"hljs-number\">0.1</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[-<span class=\"hljs-number\">1.4</span>, <span class=\"hljs-number\">0.4</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.1</span>, -<span class=\"hljs-number\">1.1</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.2</span>, -<span class=\"hljs-number\">1.0</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.3</span>, -<span class=\"hljs-number\">1.2</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.4</span>, -<span class=\"hljs-number\">1.3</span>],\r\n        ];\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">clustering</span> = <span class=\"hljs-title function_ invoke__\">kmeans</span>(xs, <span class=\"hljs-number\">2</span>);\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(clustering, <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>]);\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">high_dims</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">xs</span>: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">f64</span>&gt;&gt; = <span class=\"hljs-built_in\">vec!</span>[\r\n            <span class=\"hljs-built_in\">vec!</span>[-<span class=\"hljs-number\">2.7825343</span>, -<span class=\"hljs-number\">1.7604825</span>, -<span class=\"hljs-number\">5.5550113</span>, -<span class=\"hljs-number\">2.9752946</span>, -<span class=\"hljs-number\">2.7874138</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[-<span class=\"hljs-number\">2.9847919</span>, -<span class=\"hljs-number\">3.8209332</span>, -<span class=\"hljs-number\">2.1531757</span>, -<span class=\"hljs-number\">2.2710119</span>, -<span class=\"hljs-number\">2.3582877</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[-<span class=\"hljs-number\">3.0109320</span>, -<span class=\"hljs-number\">2.2366132</span>, -<span class=\"hljs-number\">2.8048492</span>, -<span class=\"hljs-number\">1.2632331</span>, -<span class=\"hljs-number\">4.5755581</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[-<span class=\"hljs-number\">2.8432186</span>, -<span class=\"hljs-number\">1.0383805</span>, -<span class=\"hljs-number\">2.2022826</span>, -<span class=\"hljs-number\">2.7435962</span>, -<span class=\"hljs-number\">2.0013399</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[-<span class=\"hljs-number\">2.6638082</span>, -<span class=\"hljs-number\">3.5520086</span>, -<span class=\"hljs-number\">1.3684702</span>, -<span class=\"hljs-number\">2.1562444</span>, -<span class=\"hljs-number\">1.3186447</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.7409171</span>, <span class=\"hljs-number\">1.9687576</span>, <span class=\"hljs-number\">4.7162628</span>, <span class=\"hljs-number\">4.5743537</span>, <span class=\"hljs-number\">3.7905611</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">3.2932369</span>, <span class=\"hljs-number\">2.8508700</span>, <span class=\"hljs-number\">2.5580937</span>, <span class=\"hljs-number\">2.0437325</span>, <span class=\"hljs-number\">4.2192562</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">2.5843321</span>, <span class=\"hljs-number\">2.8329818</span>, <span class=\"hljs-number\">2.1329531</span>, <span class=\"hljs-number\">3.2562319</span>, <span class=\"hljs-number\">2.4878733</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">2.1859638</span>, <span class=\"hljs-number\">3.2880048</span>, <span class=\"hljs-number\">3.7018615</span>, <span class=\"hljs-number\">2.3641232</span>, <span class=\"hljs-number\">1.6281994</span>],\r\n            <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">2.6201773</span>, <span class=\"hljs-number\">0.9006588</span>, <span class=\"hljs-number\">2.6774097</span>, <span class=\"hljs-number\">1.8188620</span>, <span class=\"hljs-number\">1.6076493</span>],\r\n        ];\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">clustering</span> = <span class=\"hljs-title function_ invoke__\">kmeans</span>(xs, <span class=\"hljs-number\">2</span>);\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(clustering, <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>]);\r\n    }\r\n}\r\n"
    },
    "r": {
      "dir": "Clustering-Algorithms\\K-Means.R",
      "url": "https://github.com/TheAlgorithms/r/tree/master/Clustering-Algorithms\\K-Means.R",
      "code": "library<span class=\"hljs-punctuation\">(</span>cluster<span class=\"hljs-punctuation\">)</span>\r\nfit <span class=\"hljs-operator\">&lt;-</span> kmeans<span class=\"hljs-punctuation\">(</span>X<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-number\">3</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-comment\"># 5 cluster solution</span>\r\n"
    },
    "matlab-octave": {
      "dir": "algorithms\\machine_learning\\kmeans\\kmeans.m",
      "url": "https://github.com/TheAlgorithms/matlab-octave/tree/master/algorithms\\machine_learning\\kmeans\\kmeans.m",
      "code": "<span class=\"hljs-comment\">%% clearing the workspace</span>\r\nclc;close all;clear;\r\n\r\n<span class=\"hljs-comment\">%% What is K-Means?</span>\r\n<span class=\"hljs-comment\">% K-Means is a clustering algorithm that aims to parition n points</span>\r\n<span class=\"hljs-comment\">% into K clusters. </span>\r\n\r\n<span class=\"hljs-comment\">%% Lets load up a dataset</span>\r\n<span class=\"hljs-comment\">% We will use the iris dataset to demonstrate the power</span>\r\n<span class=\"hljs-comment\">% of the k-means algorithm. The data set consists of 50 samples </span>\r\n<span class=\"hljs-comment\">% from each of three species of Iris (Iris setosa, </span>\r\n<span class=\"hljs-comment\">% Iris virginica and Iris versicolor). </span>\r\n<span class=\"hljs-comment\">% It consists of four features the length and width of the sepals, petals</span>\r\n<span class=\"hljs-comment\">% in centimeters.We will just use the last two features in this script.</span>\r\n\r\n<span class=\"hljs-built_in\">disp</span>(<span class=\"hljs-string\">&quot;Loading Iris dataset&quot;</span>)\r\n\r\nload irisdataset\r\niris_data = meas(:,<span class=\"hljs-number\">3</span>:<span class=\"hljs-number\">4</span>);\r\n\r\n<span class=\"hljs-comment\">%% Visualizing the dataset</span>\r\n<span class=\"hljs-comment\">% lets plot the points</span>\r\n<span class=\"hljs-built_in\">disp</span>(<span class=\"hljs-string\">&quot;Visualizing data&quot;</span>)\r\n<span class=\"hljs-built_in\">figure</span>(<span class=\"hljs-number\">1</span>)\r\n<span class=\"hljs-built_in\">plot</span>(iris_data(:,<span class=\"hljs-number\">1</span>),iris_data(:,<span class=\"hljs-number\">2</span>),<span class=\"hljs-string\">&#x27;k*&#x27;</span>,<span class=\"hljs-string\">&#x27;MarkerSize&#x27;</span>,<span class=\"hljs-number\">5</span>);\r\ntitle <span class=\"hljs-string\">&#x27;Fisher&#x27;&#x27;s Iris Data&#x27;</span>;\r\nxlabel <span class=\"hljs-string\">&#x27;Petal Lengths (cm)&#x27;</span>; \r\nylabel <span class=\"hljs-string\">&#x27;Petal Widths (cm)&#x27;</span>;\r\n<span class=\"hljs-comment\">% close all;</span>\r\n<span class=\"hljs-comment\">%% K-Means implementation</span>\r\n\r\n<span class=\"hljs-comment\">% K is number of clusters</span>\r\nK = <span class=\"hljs-number\">3</span>;\r\n\r\n<span class=\"hljs-comment\">% First we randomly pick K centroids that will represent each cluster</span>\r\n<span class=\"hljs-comment\">% rand_centroid_idx = randi(length(meas),K,1);</span>\r\nrand_centroid_idx = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">55</span>,<span class=\"hljs-number\">125</span>];\r\ncentroids = iris_data(rand_centroid_idx,:);\r\n\r\nmax_iterations = <span class=\"hljs-number\">100</span>;\r\n\r\ncluster_assigned = <span class=\"hljs-built_in\">zeros</span>(<span class=\"hljs-built_in\">length</span>(iris_data),<span class=\"hljs-number\">1</span>);\r\n\r\n<span class=\"hljs-comment\">% Make zero vectors to keep track of the sum of each sample</span>\r\n<span class=\"hljs-comment\">% in the cluster.</span>\r\ncluster_sum = <span class=\"hljs-built_in\">zeros</span>(K,<span class=\"hljs-number\">2</span>);\r\ncluster_samples = <span class=\"hljs-built_in\">zeros</span>(K,<span class=\"hljs-number\">1</span>);\r\n     \r\n<span class=\"hljs-built_in\">disp</span>(<span class=\"hljs-string\">&quot;Running k-means!&quot;</span>)\r\n<span class=\"hljs-keyword\">for</span> iter = <span class=\"hljs-number\">1</span>:max_iterations\r\n    \r\n    <span class=\"hljs-comment\">%Assign each point to a cluster</span>\r\n    <span class=\"hljs-keyword\">for</span> num_sample = <span class=\"hljs-number\">1</span>:<span class=\"hljs-built_in\">length</span>(iris_data)\r\n        \r\n        <span class=\"hljs-comment\">%Find the eulidean distance between a sample and the centroids</span>\r\n        temp = iris_data(num_sample,:) - centroids;\r\n        euc_dist = vecnorm(temp,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">2</span>);\r\n        \r\n        <span class=\"hljs-comment\">% Get the index of centroid with the minimum distance.</span>\r\n        <span class=\"hljs-comment\">% That will be the cluster we assign the sample to.</span>\r\n        closest_cluster = <span class=\"hljs-built_in\">find</span>(euc_dist == <span class=\"hljs-built_in\">min</span>(euc_dist));\r\n        \r\n        <span class=\"hljs-comment\">% Assign the sample to the cluster.</span>\r\n        cluster_assigned(num_sample) = closest_cluster;\r\n        \r\n        <span class=\"hljs-comment\">% Add the samples that belong to the same cluster.</span>\r\n        cluster_sum(closest_cluster,:) = cluster_sum(closest_cluster,:) ...\r\n            + iris_data(num_sample,:);\r\n        \r\n        <span class=\"hljs-comment\">% Track the number of samples in the cluster.</span>\r\n        cluster_samples(closest_cluster) = cluster_samples(closest_cluster)+<span class=\"hljs-number\">1</span>;\r\n        \r\n    <span class=\"hljs-keyword\">end</span>\r\n    \r\n    <span class=\"hljs-comment\">% Update the centroids by the mean of all the points that belong to</span>\r\n    <span class=\"hljs-comment\">% that cluster.</span>\r\n    centroids =  cluster_sum ./ cluster_samples;\r\n    \r\n    <span class=\"hljs-comment\">% Reset to zeros for the next iteration</span>\r\n    cluster_sum = <span class=\"hljs-built_in\">zeros</span>(K,<span class=\"hljs-number\">2</span>);\r\n    cluster_samples = <span class=\"hljs-built_in\">zeros</span>(K,<span class=\"hljs-number\">1</span>);\r\n<span class=\"hljs-keyword\">end</span>\r\n<span class=\"hljs-built_in\">disp</span>(<span class=\"hljs-string\">&quot;Clustering finished!&quot;</span>)\r\n\r\n<span class=\"hljs-comment\">%% Lets see how well K-Means it did!</span>\r\n<span class=\"hljs-built_in\">disp</span>(<span class=\"hljs-string\">&quot;Displaying Clusters&quot;</span>)\r\n\r\n<span class=\"hljs-built_in\">figure</span>(<span class=\"hljs-number\">2</span>)\r\n<span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">i</span>=<span class=\"hljs-number\">1</span>:K    \r\n    pts = iris_data(cluster_assigned==<span class=\"hljs-built_in\">i</span>,:);\r\n    <span class=\"hljs-built_in\">plot</span>(pts(:,<span class=\"hljs-number\">1</span>),pts(:,<span class=\"hljs-number\">2</span>),<span class=\"hljs-string\">&#x27;.&#x27;</span>,<span class=\"hljs-string\">&#x27;color&#x27;</span>,<span class=\"hljs-built_in\">rand</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>),<span class=\"hljs-string\">&#x27;MarkerSize&#x27;</span>,<span class=\"hljs-number\">12</span>); <span class=\"hljs-built_in\">hold</span> on;\r\n<span class=\"hljs-keyword\">end</span>\r\n\r\n<span class=\"hljs-built_in\">plot</span>(centroids(:,<span class=\"hljs-number\">1</span>),centroids(:,<span class=\"hljs-number\">2</span>),<span class=\"hljs-string\">&#x27;r+&#x27;</span>,<span class=\"hljs-string\">&#x27;MarkerSize&#x27;</span>,<span class=\"hljs-number\">12</span>);\r\ntitle <span class=\"hljs-string\">&#x27;Fisher&#x27;&#x27;s Iris Data&#x27;</span>;\r\nxlabel <span class=\"hljs-string\">&#x27;Petal Lengths (cm)&#x27;</span>; \r\nylabel <span class=\"hljs-string\">&#x27;Petal Widths (cm)&#x27;</span>;\r\n<span class=\"hljs-built_in\">legend</span>(<span class=\"hljs-string\">&#x27;Cluster 1&#x27;</span>,<span class=\"hljs-string\">&#x27;Cluster 2&#x27;</span>,<span class=\"hljs-string\">&#x27;Cluster 3&#x27;</span>,<span class=\"hljs-string\">&#x27;Centroids&#x27;</span>,...\r\n       <span class=\"hljs-string\">&#x27;Location&#x27;</span>,<span class=\"hljs-string\">&#x27;northwest&#x27;</span>)\r\n\r\n"
    }
  },
  "contributors": [
    {
      "name": "Arnav Borborah",
      "email": "arnavborborah11@gmail.com",
      "commits": 1
    },
    {
      "name": "Anshul",
      "email": "malikanshul29@gmail.com",
      "commits": 1
    },
    {
      "name": "Baxter Eaves",
      "email": "baxyjr@gmail.com",
      "commits": 1
    },
    {
      "name": "cozek",
      "email": "kaushikamardas@gmail.com",
      "commits": 1
    },
    {
      "name": "Erez Shomron",
      "email": "48328872+eshom@users.noreply.github.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}