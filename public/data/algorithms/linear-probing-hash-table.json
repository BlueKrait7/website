{
  "slug": "linear-probing-hash-table",
  "name": "Linear Probing Hash Table",
  "categories": [
    "hashing"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "hashing\\linear_probing_hash_table.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/hashing\\linear_probing_hash_table.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @author [achance6](https://github.com/achance6)\r\n * @author [Krishna Vedala](https://github.com/kvedala)\r\n * @brief Storage mechanism using [linear probing\r\n * hash](https://en.wikipedia.org/wiki/Linear_probing) keys.\r\n * @note The implementation can be optimized by using OOP style.\r\n */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @addtogroup open_addressing Open Addressing\r\n * @{\r\n * @namespace linear_probing\r\n * @brief An implementation of hash table using [linear\r\n * probing](https://en.wikipedia.org/wiki/Linear_probing) algorithm.\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> linear_probing {\r\n<span class=\"hljs-comment\">// fwd declarations</span>\r\n<span class=\"hljs-keyword\">using</span> Entry = <span class=\"hljs-keyword\">struct</span> Entry;\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">putProber</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> Entry&amp; entry, <span class=\"hljs-type\">int</span> key)</span></span>;\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">searchingProber</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> Entry&amp; entry, <span class=\"hljs-type\">int</span> key)</span></span>;\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span></span>;\r\n\r\n<span class=\"hljs-comment\">// Undocumented globals</span>\r\n<span class=\"hljs-type\">int</span> notPresent;\r\nstd::vector&lt;Entry&gt; table;\r\n<span class=\"hljs-type\">int</span> totalSize;\r\n<span class=\"hljs-type\">int</span> tomb = <span class=\"hljs-number\">-1</span>;\r\n<span class=\"hljs-type\">int</span> size;\r\n<span class=\"hljs-type\">bool</span> rehashing;\r\n\r\n<span class=\"hljs-comment\">/** Node object that holds key */</span>\r\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Entry</span> {\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Entry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key = notPresent)</span> : key(key) {</span>}  <span class=\"hljs-comment\">///&lt; constructor</span>\r\n    <span class=\"hljs-type\">int</span> key;                                            <span class=\"hljs-comment\">///&lt; key value</span>\r\n};\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Hash a key. Uses the STL library&#x27;s `std::hash()` function.\r\n *\r\n * @param key value to hash\r\n * @return hash value of the key\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">hashFxn</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>{\r\n    std::hash&lt;<span class=\"hljs-type\">int</span>&gt; hash;\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">hash</span>(key);\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Performs linear probing to resolve collisions\r\n * @param key key value to hash\r\n * @return hash value of the key\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">linearProbe</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key, <span class=\"hljs-type\">bool</span> searching)</span> </span>{\r\n    <span class=\"hljs-type\">int</span> hash = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(<span class=\"hljs-built_in\">hashFxn</span>(key));\r\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\r\n    Entry entry;\r\n    <span class=\"hljs-keyword\">do</span> {\r\n        <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;((hash + i) % totalSize);\r\n        entry = table[index];\r\n        <span class=\"hljs-keyword\">if</span> (searching) {\r\n            <span class=\"hljs-keyword\">if</span> (entry.key == notPresent) {\r\n                <span class=\"hljs-keyword\">return</span> notPresent;\r\n            }\r\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">searchingProber</span>(entry, key)) {\r\n                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Found key!&quot;</span> &lt;&lt; std::endl;\r\n                <span class=\"hljs-keyword\">return</span> index;\r\n            }\r\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Found tombstone or equal hash, checking next&quot;</span>\r\n                      &lt;&lt; std::endl;\r\n            i++;\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">putProber</span>(entry, key)) {\r\n                <span class=\"hljs-keyword\">if</span> (!rehashing) {\r\n                    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Spot found!&quot;</span> &lt;&lt; std::endl;\r\n                }\r\n                <span class=\"hljs-keyword\">return</span> index;\r\n            }\r\n            <span class=\"hljs-keyword\">if</span> (!rehashing) {\r\n                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Spot taken, looking at next&quot;</span> &lt;&lt; std::endl;\r\n            }\r\n            i++;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (i == totalSize) {\r\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Linear probe failed&quot;</span> &lt;&lt; std::endl;\r\n            <span class=\"hljs-keyword\">return</span> notPresent;\r\n        }\r\n    } <span class=\"hljs-keyword\">while</span> (entry.key != notPresent);\r\n    <span class=\"hljs-keyword\">return</span> notPresent;\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Finds empty spot\r\n * @param entry instance to check in\r\n * @param key key value to hash\r\n * @return hash value of the key\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">putProber</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> Entry&amp; entry, <span class=\"hljs-type\">int</span> key)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (entry.key == notPresent || entry.key == tomb) {\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Looks for a matching key\r\n * @param entry instance to check in\r\n * @param key key value to hash\r\n * @return hash value of the key\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">searchingProber</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> Entry&amp; entry, <span class=\"hljs-type\">int</span> key)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (entry.key == key) {\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Function to displays the table\r\n * @returns none\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">display</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; totalSize; i++) {\r\n        <span class=\"hljs-keyword\">if</span> (table[i].key == notPresent) {\r\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot; Empty &quot;</span>;\r\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (table[i].key == tomb) {\r\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot; Tomb &quot;</span>;\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;\r\n            std::cout &lt;&lt; table[i].key;\r\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;\r\n        }\r\n    }\r\n    std::cout &lt;&lt; std::endl;\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Rehashes the table into a bigger table\r\n * @returns None\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rehash</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-comment\">// Necessary so wall of add info isn&#x27;t printed all at once</span>\r\n    rehashing = <span class=\"hljs-literal\">true</span>;\r\n    <span class=\"hljs-type\">int</span> oldSize = totalSize;\r\n    <span class=\"hljs-function\">std::vector&lt;Entry&gt; <span class=\"hljs-title\">oldTable</span><span class=\"hljs-params\">(table)</span></span>;\r\n    <span class=\"hljs-comment\">// Really this should use the next prime number greater than totalSize *</span>\r\n    <span class=\"hljs-comment\">// 2</span>\r\n    totalSize *= <span class=\"hljs-number\">2</span>;\r\n    table = std::<span class=\"hljs-built_in\">vector</span>&lt;Entry&gt;(totalSize);\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; oldSize; i++) {\r\n        <span class=\"hljs-keyword\">if</span> (oldTable[i].key != <span class=\"hljs-number\">-1</span> &amp;&amp; oldTable[i].key != notPresent) {\r\n            size--;  <span class=\"hljs-comment\">// Size stays the same (add increments size)</span>\r\n            <span class=\"hljs-built_in\">add</span>(oldTable[i].key);\r\n        }\r\n    }\r\n    <span class=\"hljs-comment\">// delete[] oldTable;</span>\r\n    rehashing = <span class=\"hljs-literal\">false</span>;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Table was rehashed, new size is: &quot;</span> &lt;&lt; totalSize &lt;&lt; std::endl;\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Adds entry using linear probing. Checks for load factor here\r\n * @param key key value to hash and add\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>{\r\n    <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">linearProbe</span>(key, <span class=\"hljs-literal\">false</span>);\r\n    table[index].key = key;\r\n    <span class=\"hljs-comment\">// Load factor greater than 0.5 causes resizing</span>\r\n    <span class=\"hljs-keyword\">if</span> (++size / <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(totalSize) &gt;= <span class=\"hljs-number\">0.5</span>) {\r\n        <span class=\"hljs-built_in\">rehash</span>();\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Removes key. Leaves tombstone upon removal.\r\n * @param key key value to hash and remove\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>{\r\n    <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">linearProbe</span>(key, <span class=\"hljs-literal\">true</span>);\r\n    <span class=\"hljs-keyword\">if</span> (index == notPresent) {\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;key not found&quot;</span> &lt;&lt; std::endl;\r\n    }\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Removal Successful, leaving tomb&quot;</span> &lt;&lt; std::endl;\r\n    table[index].key = tomb;\r\n    size--;\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Information about the adding process\r\n * @param key key value to hash and add\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addInfo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>{\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Initial table: &quot;</span>;\r\n    <span class=\"hljs-built_in\">display</span>();\r\n    std::cout &lt;&lt; std::endl;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;hash of &quot;</span> &lt;&lt; key &lt;&lt; <span class=\"hljs-string\">&quot; is &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">hashFxn</span>(key) &lt;&lt; <span class=\"hljs-string\">&quot; % &quot;</span>\r\n              &lt;&lt; totalSize &lt;&lt; <span class=\"hljs-string\">&quot; == &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">hashFxn</span>(key) % totalSize;\r\n    std::cout &lt;&lt; std::endl;\r\n    <span class=\"hljs-built_in\">add</span>(key);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;New table: &quot;</span>;\r\n    <span class=\"hljs-built_in\">display</span>();\r\n}\r\n\r\n<span class=\"hljs-comment\">/** Information about removal process\r\n * @param key key value to hash and remove\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">removalInfo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>{\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Initial table: &quot;</span>;\r\n    <span class=\"hljs-built_in\">display</span>();\r\n    std::cout &lt;&lt; std::endl;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;hash of &quot;</span> &lt;&lt; key &lt;&lt; <span class=\"hljs-string\">&quot; is &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">hashFxn</span>(key) &lt;&lt; <span class=\"hljs-string\">&quot; % &quot;</span>\r\n              &lt;&lt; totalSize &lt;&lt; <span class=\"hljs-string\">&quot; == &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">hashFxn</span>(key) % totalSize;\r\n    std::cout &lt;&lt; std::endl;\r\n    <span class=\"hljs-built_in\">remove</span>(key);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;New table: &quot;</span>;\r\n    <span class=\"hljs-built_in\">display</span>();\r\n}\r\n}  <span class=\"hljs-comment\">// namespace linear_probing</span>\r\n<span class=\"hljs-comment\">/**\r\n * @}\r\n */</span>\r\n\r\n<span class=\"hljs-keyword\">using</span> linear_probing::Entry;\r\n<span class=\"hljs-keyword\">using</span> linear_probing::table;\r\n<span class=\"hljs-keyword\">using</span> linear_probing::totalSize;\r\n\r\n<span class=\"hljs-comment\">/** Main function\r\n * @returns 0 on success\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-type\">int</span> cmd = <span class=\"hljs-number\">0</span>, hash = <span class=\"hljs-number\">0</span>, key = <span class=\"hljs-number\">0</span>;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the initial size of Hash Table. = &quot;</span>;\r\n    std::cin &gt;&gt; totalSize;\r\n    table = std::<span class=\"hljs-built_in\">vector</span>&lt;Entry&gt;(totalSize);\r\n    <span class=\"hljs-type\">bool</span> loop = <span class=\"hljs-literal\">true</span>;\r\n    <span class=\"hljs-keyword\">while</span> (loop) {\r\n        std::cout &lt;&lt; std::endl;\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;PLEASE CHOOSE -&quot;</span> &lt;&lt; std::endl;\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;1. Add key. (Numeric only)&quot;</span> &lt;&lt; std::endl;\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;2. Remove key.&quot;</span> &lt;&lt; std::endl;\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;3. Find key.&quot;</span> &lt;&lt; std::endl;\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;4. Generate Hash. (Numeric only)&quot;</span> &lt;&lt; std::endl;\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;5. Display Hash table.&quot;</span> &lt;&lt; std::endl;\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;6. Exit.&quot;</span> &lt;&lt; std::endl;\r\n        std::cin &gt;&gt; cmd;\r\n        <span class=\"hljs-keyword\">switch</span> (cmd) {\r\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:\r\n                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter key to add = &quot;</span>;\r\n                std::cin &gt;&gt; key;\r\n                linear_probing::<span class=\"hljs-built_in\">addInfo</span>(key);\r\n                <span class=\"hljs-keyword\">break</span>;\r\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>:\r\n                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter key to remove = &quot;</span>;\r\n                std::cin &gt;&gt; key;\r\n                linear_probing::<span class=\"hljs-built_in\">removalInfo</span>(key);\r\n                <span class=\"hljs-keyword\">break</span>;\r\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">3</span>: {\r\n                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter key to search = &quot;</span>;\r\n                std::cin &gt;&gt; key;\r\n                Entry entry = table[linear_probing::<span class=\"hljs-built_in\">linearProbe</span>(key, <span class=\"hljs-literal\">true</span>)];\r\n                <span class=\"hljs-keyword\">if</span> (entry.key == linear_probing::notPresent) {\r\n                    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Key not present&quot;</span>;\r\n                }\r\n                <span class=\"hljs-keyword\">break</span>;\r\n            }\r\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">4</span>:\r\n                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter element to generate hash = &quot;</span>;\r\n                std::cin &gt;&gt; key;\r\n                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Hash of &quot;</span> &lt;&lt; key\r\n                          &lt;&lt; <span class=\"hljs-string\">&quot; is = &quot;</span> &lt;&lt; linear_probing::<span class=\"hljs-built_in\">hashFxn</span>(key);\r\n                <span class=\"hljs-keyword\">break</span>;\r\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">5</span>:\r\n                linear_probing::<span class=\"hljs-built_in\">display</span>();\r\n                <span class=\"hljs-keyword\">break</span>;\r\n            <span class=\"hljs-keyword\">default</span>:\r\n                loop = <span class=\"hljs-literal\">false</span>;\r\n                <span class=\"hljs-keyword\">break</span>;\r\n                <span class=\"hljs-comment\">// delete[] table;</span>\r\n        }\r\n        std::cout &lt;&lt; std::endl;\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "achance6",
      "email": "45263295+achance6@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 8
    }
  ],
  "explanationUrl": {}
}