{
  "slug": "basic-graphs",
  "name": "Basic Graphs",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "graphs\\basic_graphs.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/graphs\\basic_graphs.py",
      "code": "<span class=\"hljs-keyword\">from</span> collections <span class=\"hljs-keyword\">import</span> deque\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_input</span>(<span class=\"hljs-params\">message</span>):\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">input</span>(message).strip().split(<span class=\"hljs-string\">&quot; &quot;</span>)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">initialize_unweighted_directed_graph</span>(<span class=\"hljs-params\">\r\n    node_count: <span class=\"hljs-built_in\">int</span>, edge_count: <span class=\"hljs-built_in\">int</span>\r\n</span>) -&gt; <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]]:\r\n    graph: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]] = {}\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(node_count):\r\n        graph[i + <span class=\"hljs-number\">1</span>] = []\r\n\r\n    <span class=\"hljs-keyword\">for</span> e <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(edge_count):\r\n        x, y = (<span class=\"hljs-built_in\">int</span>(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> _<span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">f&quot;Edge <span class=\"hljs-subst\">{e + <span class=\"hljs-number\">1</span>}</span>: &lt;node1&gt; &lt;node2&gt; &quot;</span>))\r\n        graph[x].append(y)\r\n    <span class=\"hljs-keyword\">return</span> graph\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">initialize_unweighted_undirected_graph</span>(<span class=\"hljs-params\">\r\n    node_count: <span class=\"hljs-built_in\">int</span>, edge_count: <span class=\"hljs-built_in\">int</span>\r\n</span>) -&gt; <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]]:\r\n    graph: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]] = {}\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(node_count):\r\n        graph[i + <span class=\"hljs-number\">1</span>] = []\r\n\r\n    <span class=\"hljs-keyword\">for</span> e <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(edge_count):\r\n        x, y = (<span class=\"hljs-built_in\">int</span>(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> _<span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">f&quot;Edge <span class=\"hljs-subst\">{e + <span class=\"hljs-number\">1</span>}</span>: &lt;node1&gt; &lt;node2&gt; &quot;</span>))\r\n        graph[x].append(y)\r\n        graph[y].append(x)\r\n    <span class=\"hljs-keyword\">return</span> graph\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">initialize_weighted_undirected_graph</span>(<span class=\"hljs-params\">\r\n    node_count: <span class=\"hljs-built_in\">int</span>, edge_count: <span class=\"hljs-built_in\">int</span>\r\n</span>) -&gt; <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>]]]:\r\n    graph: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>]]] = {}\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(node_count):\r\n        graph[i + <span class=\"hljs-number\">1</span>] = []\r\n\r\n    <span class=\"hljs-keyword\">for</span> e <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(edge_count):\r\n        x, y, w = (<span class=\"hljs-built_in\">int</span>(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> _<span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">f&quot;Edge <span class=\"hljs-subst\">{e + <span class=\"hljs-number\">1</span>}</span>: &lt;node1&gt; &lt;node2&gt; &lt;weight&gt; &quot;</span>))\r\n        graph[x].append((y, w))\r\n        graph[y].append((x, w))\r\n    <span class=\"hljs-keyword\">return</span> graph\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    n, m = (<span class=\"hljs-built_in\">int</span>(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> _<span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&quot;Number of nodes and edges: &quot;</span>))\r\n\r\n    graph_choice = <span class=\"hljs-built_in\">int</span>(\r\n        _<span class=\"hljs-built_in\">input</span>(\r\n            <span class=\"hljs-string\">&quot;Press 1 or 2 or 3 \\n&quot;</span>\r\n            <span class=\"hljs-string\">&quot;1. Unweighted directed \\n&quot;</span>\r\n            <span class=\"hljs-string\">&quot;2. Unweighted undirected \\n&quot;</span>\r\n            <span class=\"hljs-string\">&quot;3. Weighted undirected \\n&quot;</span>\r\n        )[<span class=\"hljs-number\">0</span>]\r\n    )\r\n\r\n    g = {\r\n        <span class=\"hljs-number\">1</span>: initialize_unweighted_directed_graph,\r\n        <span class=\"hljs-number\">2</span>: initialize_unweighted_undirected_graph,\r\n        <span class=\"hljs-number\">3</span>: initialize_weighted_undirected_graph,\r\n    }[graph_choice](n, m)\r\n\r\n\r\n<span class=\"hljs-string\">&quot;&quot;&quot;\r\n--------------------------------------------------------------------------------\r\n    Depth First Search.\r\n        Args :  G - Dictionary of edges\r\n                s - Starting Node\r\n        Vars :  vis - Set of visited nodes\r\n                S - Traversal Stack\r\n--------------------------------------------------------------------------------\r\n&quot;&quot;&quot;</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">dfs</span>(<span class=\"hljs-params\">G, s</span>):\r\n    vis, S = {s}, [s]\r\n    <span class=\"hljs-built_in\">print</span>(s)\r\n    <span class=\"hljs-keyword\">while</span> S:\r\n        flag = <span class=\"hljs-number\">0</span>\r\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> G[S[-<span class=\"hljs-number\">1</span>]]:\r\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> vis:\r\n                S.append(i)\r\n                vis.add(i)\r\n                flag = <span class=\"hljs-number\">1</span>\r\n                <span class=\"hljs-built_in\">print</span>(i)\r\n                <span class=\"hljs-keyword\">break</span>\r\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> flag:\r\n            S.pop()\r\n\r\n\r\n<span class=\"hljs-string\">&quot;&quot;&quot;\r\n--------------------------------------------------------------------------------\r\n    Breadth First Search.\r\n        Args :  G - Dictionary of edges\r\n                s - Starting Node\r\n        Vars :  vis - Set of visited nodes\r\n                Q - Traversal Stack\r\n--------------------------------------------------------------------------------\r\n&quot;&quot;&quot;</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">bfs</span>(<span class=\"hljs-params\">G, s</span>):\r\n    vis, Q = {s}, deque([s])\r\n    <span class=\"hljs-built_in\">print</span>(s)\r\n    <span class=\"hljs-keyword\">while</span> Q:\r\n        u = Q.popleft()\r\n        <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> G[u]:\r\n            <span class=\"hljs-keyword\">if</span> v <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> vis:\r\n                vis.add(v)\r\n                Q.append(v)\r\n                <span class=\"hljs-built_in\">print</span>(v)\r\n\r\n\r\n<span class=\"hljs-string\">&quot;&quot;&quot;\r\n--------------------------------------------------------------------------------\r\n    Dijkstra&#x27;s shortest path Algorithm\r\n        Args :  G - Dictionary of edges\r\n                s - Starting Node\r\n        Vars :  dist - Dictionary storing shortest distance from s to every other node\r\n                known - Set of knows nodes\r\n                path - Preceding node in path\r\n--------------------------------------------------------------------------------\r\n&quot;&quot;&quot;</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">dijk</span>(<span class=\"hljs-params\">G, s</span>):\r\n    dist, known, path = {s: <span class=\"hljs-number\">0</span>}, <span class=\"hljs-built_in\">set</span>(), {s: <span class=\"hljs-number\">0</span>}\r\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\r\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(known) == <span class=\"hljs-built_in\">len</span>(G) - <span class=\"hljs-number\">1</span>:\r\n            <span class=\"hljs-keyword\">break</span>\r\n        mini = <span class=\"hljs-number\">100000</span>\r\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> dist:\r\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> known <span class=\"hljs-keyword\">and</span> dist[i] &lt; mini:\r\n                mini = dist[i]\r\n                u = i\r\n        known.add(u)\r\n        <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> G[u]:\r\n            <span class=\"hljs-keyword\">if</span> v[<span class=\"hljs-number\">0</span>] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> known:\r\n                <span class=\"hljs-keyword\">if</span> dist[u] + v[<span class=\"hljs-number\">1</span>] &lt; dist.get(v[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">100000</span>):\r\n                    dist[v[<span class=\"hljs-number\">0</span>]] = dist[u] + v[<span class=\"hljs-number\">1</span>]\r\n                    path[v[<span class=\"hljs-number\">0</span>]] = u\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> dist:\r\n        <span class=\"hljs-keyword\">if</span> i != s:\r\n            <span class=\"hljs-built_in\">print</span>(dist[i])\r\n\r\n\r\n<span class=\"hljs-string\">&quot;&quot;&quot;\r\n--------------------------------------------------------------------------------\r\n    Topological Sort\r\n--------------------------------------------------------------------------------\r\n&quot;&quot;&quot;</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">topo</span>(<span class=\"hljs-params\">G, ind=<span class=\"hljs-literal\">None</span>, Q=<span class=\"hljs-literal\">None</span></span>):\r\n    <span class=\"hljs-keyword\">if</span> Q <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\r\n        Q = [<span class=\"hljs-number\">1</span>]\r\n    <span class=\"hljs-keyword\">if</span> ind <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\r\n        ind = [<span class=\"hljs-number\">0</span>] * (<span class=\"hljs-built_in\">len</span>(G) + <span class=\"hljs-number\">1</span>)  <span class=\"hljs-comment\"># SInce oth Index is ignored</span>\r\n        <span class=\"hljs-keyword\">for</span> u <span class=\"hljs-keyword\">in</span> G:\r\n            <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> G[u]:\r\n                ind[v] += <span class=\"hljs-number\">1</span>\r\n        Q = deque()\r\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> G:\r\n            <span class=\"hljs-keyword\">if</span> ind[i] == <span class=\"hljs-number\">0</span>:\r\n                Q.append(i)\r\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(Q) == <span class=\"hljs-number\">0</span>:\r\n        <span class=\"hljs-keyword\">return</span>\r\n    v = Q.popleft()\r\n    <span class=\"hljs-built_in\">print</span>(v)\r\n    <span class=\"hljs-keyword\">for</span> w <span class=\"hljs-keyword\">in</span> G[v]:\r\n        ind[w] -= <span class=\"hljs-number\">1</span>\r\n        <span class=\"hljs-keyword\">if</span> ind[w] == <span class=\"hljs-number\">0</span>:\r\n            Q.append(w)\r\n    topo(G, ind, Q)\r\n\r\n\r\n<span class=\"hljs-string\">&quot;&quot;&quot;\r\n--------------------------------------------------------------------------------\r\n    Reading an Adjacency matrix\r\n--------------------------------------------------------------------------------\r\n&quot;&quot;&quot;</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">adjm</span>():\r\n    n = <span class=\"hljs-built_in\">input</span>().strip()\r\n    a = []\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):\r\n        a.append(<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">input</span>().strip().split()))\r\n    <span class=\"hljs-keyword\">return</span> a, n\r\n\r\n\r\n<span class=\"hljs-string\">&quot;&quot;&quot;\r\n--------------------------------------------------------------------------------\r\n    Floyd Warshall&#x27;s algorithm\r\n        Args :  G - Dictionary of edges\r\n                s - Starting Node\r\n        Vars :  dist - Dictionary storing shortest distance from s to every other node\r\n                known - Set of knows nodes\r\n                path - Preceding node in path\r\n\r\n--------------------------------------------------------------------------------\r\n&quot;&quot;&quot;</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">floy</span>(<span class=\"hljs-params\">A_and_n</span>):\r\n    (A, n) = A_and_n\r\n    dist = <span class=\"hljs-built_in\">list</span>(A)\r\n    path = [[<span class=\"hljs-number\">0</span>] * n <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n)]\r\n    <span class=\"hljs-keyword\">for</span> k <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):\r\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):\r\n            <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):\r\n                <span class=\"hljs-keyword\">if</span> dist[i][j] &gt; dist[i][k] + dist[k][j]:\r\n                    dist[i][j] = dist[i][k] + dist[k][j]\r\n                    path[i][k] = k\r\n    <span class=\"hljs-built_in\">print</span>(dist)\r\n\r\n\r\n<span class=\"hljs-string\">&quot;&quot;&quot;\r\n--------------------------------------------------------------------------------\r\n    Prim&#x27;s MST Algorithm\r\n        Args :  G - Dictionary of edges\r\n                s - Starting Node\r\n        Vars :  dist - Dictionary storing shortest distance from s to nearest node\r\n                known - Set of knows nodes\r\n                path - Preceding node in path\r\n--------------------------------------------------------------------------------\r\n&quot;&quot;&quot;</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">prim</span>(<span class=\"hljs-params\">G, s</span>):\r\n    dist, known, path = {s: <span class=\"hljs-number\">0</span>}, <span class=\"hljs-built_in\">set</span>(), {s: <span class=\"hljs-number\">0</span>}\r\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\r\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(known) == <span class=\"hljs-built_in\">len</span>(G) - <span class=\"hljs-number\">1</span>:\r\n            <span class=\"hljs-keyword\">break</span>\r\n        mini = <span class=\"hljs-number\">100000</span>\r\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> dist:\r\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> known <span class=\"hljs-keyword\">and</span> dist[i] &lt; mini:\r\n                mini = dist[i]\r\n                u = i\r\n        known.add(u)\r\n        <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> G[u]:\r\n            <span class=\"hljs-keyword\">if</span> v[<span class=\"hljs-number\">0</span>] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> known:\r\n                <span class=\"hljs-keyword\">if</span> v[<span class=\"hljs-number\">1</span>] &lt; dist.get(v[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">100000</span>):\r\n                    dist[v[<span class=\"hljs-number\">0</span>]] = v[<span class=\"hljs-number\">1</span>]\r\n                    path[v[<span class=\"hljs-number\">0</span>]] = u\r\n    <span class=\"hljs-keyword\">return</span> dist\r\n\r\n\r\n<span class=\"hljs-string\">&quot;&quot;&quot;\r\n--------------------------------------------------------------------------------\r\n    Accepting Edge list\r\n        Vars :  n - Number of nodes\r\n                m - Number of edges\r\n        Returns : l - Edge list\r\n                n - Number of Nodes\r\n--------------------------------------------------------------------------------\r\n&quot;&quot;&quot;</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">edglist</span>():\r\n    n, m = <span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">input</span>().split(<span class=\"hljs-string\">&quot; &quot;</span>))\r\n    edges = []\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(m):\r\n        edges.append(<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">input</span>().split(<span class=\"hljs-string\">&quot; &quot;</span>)))\r\n    <span class=\"hljs-keyword\">return</span> edges, n\r\n\r\n\r\n<span class=\"hljs-string\">&quot;&quot;&quot;\r\n--------------------------------------------------------------------------------\r\n    Kruskal&#x27;s MST Algorithm\r\n        Args :  E - Edge list\r\n                n - Number of Nodes\r\n        Vars :  s - Set of all nodes as unique disjoint sets (initially)\r\n--------------------------------------------------------------------------------\r\n&quot;&quot;&quot;</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">krusk</span>(<span class=\"hljs-params\">E_and_n</span>):\r\n    <span class=\"hljs-comment\"># Sort edges on the basis of distance</span>\r\n    (E, n) = E_and_n\r\n    E.sort(reverse=<span class=\"hljs-literal\">True</span>, key=<span class=\"hljs-keyword\">lambda</span> x: x[<span class=\"hljs-number\">2</span>])\r\n    s = [{i} <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, n + <span class=\"hljs-number\">1</span>)]\r\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\r\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(s) == <span class=\"hljs-number\">1</span>:\r\n            <span class=\"hljs-keyword\">break</span>\r\n        <span class=\"hljs-built_in\">print</span>(s)\r\n        x = E.pop()\r\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(s)):\r\n            <span class=\"hljs-keyword\">if</span> x[<span class=\"hljs-number\">0</span>] <span class=\"hljs-keyword\">in</span> s[i]:\r\n                <span class=\"hljs-keyword\">break</span>\r\n        <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(s)):\r\n            <span class=\"hljs-keyword\">if</span> x[<span class=\"hljs-number\">1</span>] <span class=\"hljs-keyword\">in</span> s[j]:\r\n                <span class=\"hljs-keyword\">if</span> i == j:\r\n                    <span class=\"hljs-keyword\">break</span>\r\n                s[j].update(s[i])\r\n                s.pop(i)\r\n                <span class=\"hljs-keyword\">break</span>\r\n\r\n\r\n<span class=\"hljs-comment\"># find the isolated node in the graph</span>\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">find_isolated_nodes</span>(<span class=\"hljs-params\">graph</span>):\r\n    isolated = []\r\n    <span class=\"hljs-keyword\">for</span> node <span class=\"hljs-keyword\">in</span> graph:\r\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> graph[node]:\r\n            isolated.append(node)\r\n    <span class=\"hljs-keyword\">return</span> isolated\r\n"
    }
  },
  "contributors": [
    {
      "name": "AlexDvorak",
      "email": "opti.jawsome@gmail.com",
      "commits": 1
    },
    {
      "name": "hasan",
      "email": "hasanuli10@gmail.com",
      "commits": 1
    },
    {
      "name": "Hector S",
      "email": "hfsam88@gmail.com",
      "commits": 1
    },
    {
      "name": "KARTHIKEYAN ANBARASU",
      "email": "53579498+karthikeyansa@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Shivam Arora",
      "email": "shivam.arora@inficold.com",
      "commits": 1
    },
    {
      "name": "97arushisharma",
      "email": "97arushisharma@gmail.com",
      "commits": 1
    },
    {
      "name": "Vishal Gupta",
      "email": "vishalg8897@gmail.com",
      "commits": 1
    },
    {
      "name": "ParthS007",
      "email": "parth1989shandilya@gmail.com",
      "commits": 2
    },
    {
      "name": "cclauss",
      "email": "cclauss@bluewin.ch",
      "commits": 2
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 7
    }
  ],
  "explanationUrl": {}
}