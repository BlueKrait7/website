{
  "slug": "heavy-light-decomposition",
  "name": "Heavy Light Decomposition",
  "categories": [
    "rangequeries"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "range_queries\\heavy_light_decomposition.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/range_queries\\heavy_light_decomposition.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @brief [Heavy Light\r\n * Decomposition](https://en.wikipedia.org/wiki/Heavy_path_decomposition)\r\n * implementation\r\n * @author [Aniruthan R](https://github.com/aneee004)\r\n *\r\n * @details\r\n * Heavy-Light Decomposition is a technique on trees, that supports the\r\n * following:\r\n * 1. Update node s, with a value v\r\n * 2. Return the (sum) of all node values on the simple path from a to b\r\n * (sum) can also be replced with XOR, OR, AND, min, or max\r\n *\r\n * The update is done in O(log n) time, and\r\n * the query is done in O(log^2 n) time with HLD\r\n * where, n is the number of nodes\r\n *\r\n * The template type is the data type of the value stored in the nodes.\r\n * If a non-primitive data-type is used as a template,\r\n * the coressponding operators must be overloaded.\r\n *\r\n * An HLD object can only be created with a constant number of nodes, and\r\n * it cannot be changed later. Creaty an empty instance is not supported.\r\n *\r\n * To start answering updates and queries,\r\n * 1. Create an instance of HLD&lt;X&gt; object (obj), with the required data type.\r\n * 2. Read in the edge/parent information and update it with obj.add_edge().\r\n * Note: The edges addes must be 0 indexed.\r\n * 3. Create a vector with initial node values, and call set_node_val() with it.\r\n * 4. Call obj.init() to populate the required information for supporting\r\n * operations.\r\n * 5. Call obj.update(node, new_val), to update the value at index &#x27;node&#x27; to the\r\n * new value. Note: node must be 0 indexed\r\n * 6. Call obj.query(a, b) to get the (sum) of node values in the simple path\r\n * from a to b. Note: a and b, must be 0 indexed.\r\n *\r\n * Sample I/O at the bottom.\r\n * @todo Support edge weight queries, by storing the edge weight value in it&#x27;s\r\n * child algorithm verified by testing in CSES path queries:\r\n * https://cses.fi/problemset/task/1138\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;numeric&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace range_queries\r\n * @brief Algorithms and Data Structures that support range queries and updates.\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> range_queries {\r\n<span class=\"hljs-comment\">/**\r\n * @namespace heavy_light_decomposition\r\n * @brief Heavy light decomposition algorithm\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> heavy_light_decomposition {\r\n<span class=\"hljs-comment\">/**\r\n * @brief A Basic Tree, which supports binary lifting\r\n * @tparam the data type of the values stored in the tree nodes\r\n * @details Deleting the default constructor\r\n * An instance can only be created with the number of nodes\r\n * Defaults:\r\n * t_node indexing are zero based\r\n * t_root is 0\r\n * depth of root_node is 0\r\n * Supports:\r\n * lift :- lift a node k units up the tree\r\n * kth_ancestor :- returns the kth ancestor\r\n * lca :- returns the least common ancestor\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> X&gt; <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Tree</span> {\r\n  <span class=\"hljs-comment\">//</span>\r\n\r\n<span class=\"hljs-keyword\">private</span>:\r\n  std::vector&lt;std::list&lt;<span class=\"hljs-type\">int</span>&gt;&gt;\r\n      t_adj;         <span class=\"hljs-comment\">///&lt; an adjacency list to stores the tree edges</span>\r\n  <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> t_nodes, <span class=\"hljs-comment\">///&lt; number of nodes</span>\r\n      t_maxlift;     <span class=\"hljs-comment\">///&lt; maximum possible height of the tree</span>\r\n  std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt;\r\n      t_par;                <span class=\"hljs-comment\">///&lt; a matrix to store every node&#x27;s 2^kth parent</span>\r\n  std::vector&lt;<span class=\"hljs-type\">int</span>&gt; t_depth, <span class=\"hljs-comment\">///&lt; a vector to store the depth of a node,</span>\r\n      t_size; <span class=\"hljs-comment\">///&lt; a vector to store the subtree size rooted at node</span>\r\n\r\n  <span class=\"hljs-type\">int</span> t_root;           <span class=\"hljs-comment\">///&lt; the root of the tree</span>\r\n  std::vector&lt;X&gt; t_val; <span class=\"hljs-comment\">///&lt; values of nodes</span>\r\n  <span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt; <span class=\"hljs-keyword\">friend</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HLD</span>;\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief Utility function to compute sub-tree sizes\r\n   * @param u current dfs node\r\n   * @param p the parent of node @param u\r\n   * @returns void\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs_size</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> p = <span class=\"hljs-number\">-1</span>)</span> </span>{\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> &amp;v : t_adj[u]) {\r\n      <span class=\"hljs-keyword\">if</span> (v ^ p) {\r\n        <span class=\"hljs-built_in\">dfs_size</span>(v, u);\r\n        t_size[u] += t_size[v];\r\n      }\r\n    }\r\n  }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief Utility function to populate the t_par vector\r\n   * @param u current dfs node\r\n   * @param p the parent of node u\r\n   * @returns void\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs_lca</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> p = <span class=\"hljs-number\">-1</span>)</span> </span>{\r\n    t_par[u][<span class=\"hljs-number\">0</span>] = p;\r\n    <span class=\"hljs-keyword\">if</span> (p != <span class=\"hljs-number\">-1</span>) {\r\n      t_depth[u] = <span class=\"hljs-number\">1</span> + t_depth[p];\r\n    }\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">1</span>; k &lt; t_maxlift; k++) {\r\n      <span class=\"hljs-keyword\">if</span> (t_par[u][k - <span class=\"hljs-number\">1</span>] != <span class=\"hljs-number\">-1</span>) {\r\n        t_par[u][k] = t_par[t_par[u][k - <span class=\"hljs-number\">1</span>]][k - <span class=\"hljs-number\">1</span>];\r\n      }\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> &amp;v : t_adj[u]) {\r\n      <span class=\"hljs-keyword\">if</span> (v ^ p) {\r\n        <span class=\"hljs-built_in\">dfs_lca</span>(v, u);\r\n      }\r\n    }\r\n  }\r\n\r\n<span class=\"hljs-keyword\">public</span>:\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief Class parameterized constructor, resizes the and initializes the\r\n   * data members\r\n   * @param nodes the total number of nodes in the tree\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Tree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> nodes)</span>\r\n      : t_nodes(nodes), t_maxlift(static_cast&lt;int&gt;(floor(log2(nodes))) + <span class=\"hljs-number\">1</span>) {</span>\r\n    <span class=\"hljs-comment\">/* Initialize and resize all the vectors */</span>\r\n    t_root = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">/* Default */</span>\r\n    t_adj.<span class=\"hljs-built_in\">resize</span>(t_nodes);\r\n    t_par.<span class=\"hljs-built_in\">assign</span>(t_nodes, std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(t_maxlift, <span class=\"hljs-number\">-1</span>));\r\n    t_depth.<span class=\"hljs-built_in\">assign</span>(t_nodes, <span class=\"hljs-number\">0</span>);\r\n    t_size.<span class=\"hljs-built_in\">assign</span>(t_nodes, <span class=\"hljs-number\">1</span>);\r\n    t_val.<span class=\"hljs-built_in\">resize</span>(t_nodes);\r\n  }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief Adds an undirected edge from node u to node v in the tree\r\n   * @param u the node where the edge is from\r\n   * @param v the node where the edge is to\r\n   * @returns void\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">add_edge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> v)</span> </span>{\r\n    t_adj[u].<span class=\"hljs-built_in\">push_back</span>(v);\r\n    t_adj[v].<span class=\"hljs-built_in\">push_back</span>(u);\r\n  }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief Set the root for the tree\r\n   * @param new_root the new root\r\n   * @returns void\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">change_root</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> new_root)</span> </span>{ t_root = new_root; }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief Set the values for all the nodes\r\n   * @param node_val a vector of size n, with all the node values where, n is\r\n   * the number of nodes\r\n   * @returns void\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_node_val</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::vector&lt;X&gt; &amp;node_val)</span> </span>{\r\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(node_val.<span class=\"hljs-built_in\">size</span>()) == t_nodes);\r\n    t_val = node_val;\r\n  }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief This function must be called after the tree adjacency list and node\r\n   * values are populated The function initializes the required parameters, and\r\n   * populates the segment tree\r\n   * @returns void\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-built_in\">assert</span>(t_nodes &gt; <span class=\"hljs-number\">0</span>);\r\n    <span class=\"hljs-built_in\">dfs_size</span>(t_root);\r\n    <span class=\"hljs-built_in\">dfs_lca</span>(t_root);\r\n  }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief The function lifts a node, k units up the tree.\r\n   * The lifting is done in place, and the result is stored in the address\r\n   * pointed by p.\r\n   * @param p a pointer to the variable that stores the node id\r\n   * @param dist the distance to move up the tree\r\n   * @returns void\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">lift</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> *<span class=\"hljs-type\">const</span> p, <span class=\"hljs-type\">int</span> dist)</span> </span>{\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; t_maxlift; k++) {\r\n      <span class=\"hljs-keyword\">if</span> (*p == <span class=\"hljs-number\">-1</span>) {\r\n        <span class=\"hljs-keyword\">return</span>;\r\n      }\r\n      <span class=\"hljs-keyword\">if</span> (dist &amp; <span class=\"hljs-number\">1</span>) {\r\n        *p = t_par[*p][k];\r\n      }\r\n      dist &gt;&gt;= <span class=\"hljs-number\">1</span>;\r\n    }\r\n  }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief The function returns the kth ancestor of a node\r\n   * @param p the node id whose kth ancestor is to be found\r\n   * @param dist the distance to move up the tree\r\n   * @returns the kth ancestor of node\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">kth_ancestor</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> p, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> &amp;dist)</span> </span>{\r\n    <span class=\"hljs-built_in\">lift</span>(&amp;p, dist);\r\n    <span class=\"hljs-keyword\">return</span> p;\r\n  }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief The function returns the least common ancestor of two nodes\r\n   * @param a node id_1\r\n   * @param b node id_2\r\n   * @returns the least common ancestor of node a, and node b\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">lca</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>{\r\n    <span class=\"hljs-built_in\">assert</span>(a &gt;= <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> b &gt;= <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> a &lt; t_nodes <span class=\"hljs-keyword\">and</span> b &lt; t_nodes);\r\n    <span class=\"hljs-keyword\">if</span> (t_depth[a] &gt; t_depth[b]) {\r\n      <span class=\"hljs-built_in\">lift</span>(&amp;a, t_depth[a] - t_depth[b]);\r\n    }\r\n    <span class=\"hljs-keyword\">if</span> (t_depth[b] &gt; t_depth[a]) {\r\n      <span class=\"hljs-built_in\">lift</span>(&amp;b, t_depth[b] - t_depth[a]);\r\n    }\r\n    <span class=\"hljs-keyword\">if</span> (a == b) {\r\n      <span class=\"hljs-keyword\">return</span> a;\r\n    }\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = t_maxlift - <span class=\"hljs-number\">1</span>; k &gt;= <span class=\"hljs-number\">0</span>; k--) {\r\n      <span class=\"hljs-keyword\">if</span> (t_par[a][k] != t_par[b][k]) {\r\n        a = t_par[a][k];\r\n        b = t_par[b][k];\r\n      }\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> t_par[a][<span class=\"hljs-number\">0</span>];\r\n  }\r\n};\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Segment Tree, to store heavy chains\r\n * @tparam the data type of the values stored in the tree nodes\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> X&gt; <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SG</span> {\r\n<span class=\"hljs-keyword\">private</span>:\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief Everything here is private,\r\n   * and can only be accessed through the methods,\r\n   * in the derived class (HLD)\r\n   */</span>\r\n\r\n  std::vector&lt;X&gt; s_tree; <span class=\"hljs-comment\">///&lt; the segment tree, stored as a vector</span>\r\n  <span class=\"hljs-type\">int</span> s_size;            <span class=\"hljs-comment\">///&lt; number of leaves in the segment tree</span>\r\n  X sret_init = <span class=\"hljs-number\">0</span>;       <span class=\"hljs-comment\">///&lt; inital query return value</span>\r\n  <span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt; <span class=\"hljs-keyword\">friend</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HLD</span>;\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief Function that specifies the type of operation involved when segments\r\n   * are combined\r\n   * @param lhs the left segment\r\n   * @param rhs the right segment\r\n   * @returns the combined result\r\n   */</span>\r\n  <span class=\"hljs-function\">X <span class=\"hljs-title\">combine</span><span class=\"hljs-params\">(X lhs, X rhs)</span> </span>{ <span class=\"hljs-keyword\">return</span> lhs + rhs; }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief Class parameterized constructor. Resizes the and initilizes the data\r\n   * members.\r\n   * @param nodes the total number of nodes in the tree\r\n   * @returns void\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">SG</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> size)</span> </span>{\r\n    s_size = size;\r\n    s_tree.<span class=\"hljs-built_in\">assign</span>(<span class=\"hljs-number\">2</span> * s_size, <span class=\"hljs-number\">0ll</span>);\r\n  }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief Update the value at a node\r\n   * @param p the node to be udpated\r\n   * @param v the update value\r\n   * @returns void\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> p, X v)</span> </span>{\r\n    <span class=\"hljs-keyword\">for</span> (p += s_size; p &gt; <span class=\"hljs-number\">0</span>; p &gt;&gt;= <span class=\"hljs-number\">1</span>) {\r\n      s_tree[p] += v;\r\n    }\r\n  }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief Make a range query from node label l to node label r\r\n   * @param l node label where the path starts\r\n   * @param r node label where the path ends\r\n   * @returns void\r\n   */</span>\r\n  <span class=\"hljs-function\">X <span class=\"hljs-title\">query</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> l, <span class=\"hljs-type\">int</span> r)</span> </span>{\r\n    X lhs = sret_init, rhs = sret_init;\r\n    <span class=\"hljs-keyword\">for</span> (l += s_size, r += s_size + <span class=\"hljs-number\">1</span>; l &lt; r; l &gt;&gt;= <span class=\"hljs-number\">1</span>, r &gt;&gt;= <span class=\"hljs-number\">1</span>) {\r\n      <span class=\"hljs-keyword\">if</span> (l &amp; <span class=\"hljs-number\">1</span>) {\r\n        lhs = <span class=\"hljs-built_in\">combine</span>(lhs, s_tree[l++]);\r\n      }\r\n      <span class=\"hljs-keyword\">if</span> (r &amp; <span class=\"hljs-number\">1</span>) {\r\n        rhs = <span class=\"hljs-built_in\">combine</span>(s_tree[--r], rhs);\r\n      }\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">combine</span>(lhs, rhs);\r\n  }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief Set the initialization for the query data type, based on requirement\r\n   *\r\n   * @details\r\n   * Change the sret_init, based on requirement:\r\n   * * Sum Query: 0 (Default)\r\n   * * XOR Query: 0 (Default)\r\n   * * Min Query: Infinity\r\n   * * Max Query: -Infinity\r\n   * @param new_sret_init the new init\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_sret_init</span><span class=\"hljs-params\">(X new_sret_init)</span> </span>{ sret_init = new_sret_init; }\r\n};\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief The Heavy-Light Decomposition class\r\n * @tparam the data type of the values stored in the tree nodes\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> X&gt; <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HLD</span> : <span class=\"hljs-keyword\">public</span> Tree&lt;X&gt;, <span class=\"hljs-keyword\">public</span> SG&lt;X&gt; {\r\n<span class=\"hljs-keyword\">private</span>:\r\n  <span class=\"hljs-type\">int</span> label;                <span class=\"hljs-comment\">///&lt; utility member to assign labels in dfs_labels()</span>\r\n  std::vector&lt;<span class=\"hljs-type\">int</span>&gt; h_label, <span class=\"hljs-comment\">///&lt; stores the label of a node</span>\r\n      h_heavychlid,         <span class=\"hljs-comment\">///&lt; stores the heavy child of a node</span>\r\n      h_parent;             <span class=\"hljs-comment\">///&lt; stores the top of the heavy chain from a node</span>\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief Utility function to assign heavy child to each node (-1 for a leaf\r\n   * node)\r\n   * @param u current dfs node\r\n   * @param p the parent of node u\r\n   * @returns void\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs_hc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> p = <span class=\"hljs-number\">-1</span>)</span> </span>{\r\n    <span class=\"hljs-type\">int</span> hc_size = <span class=\"hljs-number\">-1</span>, hc_id = <span class=\"hljs-number\">-1</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> &amp;v : Tree&lt;X&gt;::t_adj[u]) {\r\n      <span class=\"hljs-keyword\">if</span> (v ^ p) {\r\n        <span class=\"hljs-built_in\">dfs_hc</span>(v, u);\r\n        <span class=\"hljs-keyword\">if</span> (Tree&lt;X&gt;::t_size[v] &gt; hc_size) {\r\n          hc_size = Tree&lt;X&gt;::t_size[v];\r\n          hc_id = v;\r\n        }\r\n      }\r\n    }\r\n    h_heavychlid[u] = hc_id;\r\n  }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief Utility function to assign highest parent that can be reached though\r\n   * heavy chains\r\n   * @param u current dfs node\r\n   * @param p the parent of node u\r\n   * @returns void\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs_par</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> p = <span class=\"hljs-number\">-1</span>)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (h_heavychlid[u] != <span class=\"hljs-number\">-1</span>) {\r\n      h_parent[h_heavychlid[u]] = h_parent[u];\r\n      <span class=\"hljs-built_in\">dfs_par</span>(h_heavychlid[u], u);\r\n    }\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> &amp;v : Tree&lt;X&gt;::t_adj[u]) {\r\n      <span class=\"hljs-keyword\">if</span> (v ^ p <span class=\"hljs-keyword\">and</span> v ^ h_heavychlid[u]) {\r\n        <span class=\"hljs-built_in\">dfs_par</span>(v, u);\r\n      }\r\n    }\r\n  }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief Utility function to lable the nodes so that heavy chains have a\r\n   * contigous lable\r\n   * @param u current dfs node\r\n   * @param p the parent of node u\r\n   * @returns void\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs_labels</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> p = <span class=\"hljs-number\">-1</span>)</span> </span>{\r\n    h_label[u] = label++;\r\n    <span class=\"hljs-keyword\">if</span> (h_heavychlid[u] != <span class=\"hljs-number\">-1</span>) {\r\n      <span class=\"hljs-built_in\">dfs_labels</span>(h_heavychlid[u], u);\r\n    }\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> &amp;v : Tree&lt;X&gt;::t_adj[u]) {\r\n      <span class=\"hljs-keyword\">if</span> (v ^ p <span class=\"hljs-keyword\">and</span> v ^ h_heavychlid[u]) {\r\n        <span class=\"hljs-built_in\">dfs_labels</span>(v, u);\r\n      }\r\n    }\r\n  }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief Utility function to break down a path query into two chain queries\r\n   * @param a node where the path starts\r\n   * @param b node where the path ends\r\n   * a and b must belong to a single root to leaf chain\r\n   * @returns the sum of ndoe values in the simple path from a to b\r\n   */</span>\r\n  <span class=\"hljs-function\">X <span class=\"hljs-title\">chain_query</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>{\r\n    X ret = SG&lt;X&gt;::sret_init;\r\n    <span class=\"hljs-keyword\">if</span> (Tree&lt;X&gt;::t_depth[a] &lt; Tree&lt;X&gt;::t_depth[b]) {\r\n      std::<span class=\"hljs-built_in\">swap</span>(a, b);\r\n    }\r\n    <span class=\"hljs-keyword\">while</span> (Tree&lt;X&gt;::t_depth[a] &gt;= Tree&lt;X&gt;::t_depth[b]) {\r\n      <span class=\"hljs-type\">int</span> l = h_label[h_parent[a]];\r\n      <span class=\"hljs-type\">int</span> r = h_label[a];\r\n      <span class=\"hljs-keyword\">if</span> (Tree&lt;X&gt;::t_depth[h_parent[a]] &lt; Tree&lt;X&gt;::t_depth[b]) {\r\n        l += Tree&lt;X&gt;::t_depth[b] - Tree&lt;X&gt;::t_depth[h_parent[a]];\r\n      }\r\n      ret = SG&lt;X&gt;::<span class=\"hljs-built_in\">combine</span>(ret, SG&lt;X&gt;::<span class=\"hljs-built_in\">query</span>(l, r));\r\n      a = Tree&lt;X&gt;::t_par[h_parent[a]][<span class=\"hljs-number\">0</span>];\r\n      <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-number\">-1</span>) {\r\n        <span class=\"hljs-keyword\">break</span>;\r\n      }\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> ret;\r\n  }\r\n\r\n<span class=\"hljs-keyword\">public</span>:\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief Class parameterized constructor. Resizes the and initilizes the data\r\n   * members.\r\n   * @param nodes the total number of nodes in the tree\r\n   */</span>\r\n  <span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-built_in\">HLD</span>&lt;X&gt;(<span class=\"hljs-type\">int</span> nodes) : <span class=\"hljs-built_in\">Tree</span>&lt;X&gt;(nodes), <span class=\"hljs-built_in\">SG</span>&lt;X&gt;(nodes) {\r\n    <span class=\"hljs-comment\">/* Initialization and resize vectors */</span>\r\n    label = <span class=\"hljs-number\">0</span>;\r\n    h_label.<span class=\"hljs-built_in\">assign</span>(Tree&lt;X&gt;::t_nodes, <span class=\"hljs-number\">-1</span>);\r\n    h_heavychlid.<span class=\"hljs-built_in\">assign</span>(Tree&lt;X&gt;::t_nodes, <span class=\"hljs-number\">-1</span>);\r\n    h_parent.<span class=\"hljs-built_in\">resize</span>(Tree&lt;X&gt;::t_nodes);\r\n    <span class=\"hljs-built_in\">iota</span>(h_parent.<span class=\"hljs-built_in\">begin</span>(), h_parent.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-number\">0</span>);\r\n  }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief This function must be called after the tree adjacency list and node\r\n   * values are populated The function initializes the required parametes, and\r\n   * populates the segment tree\r\n   * @returns void\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">()</span> </span>{\r\n    Tree&lt;X&gt;::<span class=\"hljs-built_in\">init</span>();\r\n\r\n    <span class=\"hljs-comment\">// Fill the heavy child, greatest parent, and labels</span>\r\n    label = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-built_in\">dfs_hc</span>(Tree&lt;X&gt;::t_root);\r\n    <span class=\"hljs-built_in\">dfs_par</span>(Tree&lt;X&gt;::t_root);\r\n    <span class=\"hljs-built_in\">dfs_labels</span>(Tree&lt;X&gt;::t_root);\r\n\r\n    <span class=\"hljs-comment\">// Segment Tree Initialization</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; Tree&lt;X&gt;::t_nodes; i++) {\r\n      SG&lt;X&gt;::s_tree[h_label[i] + Tree&lt;X&gt;::t_nodes] = Tree&lt;X&gt;::t_val[i];\r\n    }\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = Tree&lt;X&gt;::t_nodes - <span class=\"hljs-number\">1</span>; i &gt; <span class=\"hljs-number\">0</span>; i--) {\r\n      SG&lt;X&gt;::s_tree[i] =\r\n          SG&lt;X&gt;::<span class=\"hljs-built_in\">combine</span>(SG&lt;X&gt;::s_tree[i &lt;&lt; <span class=\"hljs-number\">1</span>], SG&lt;X&gt;::s_tree[i &lt;&lt; <span class=\"hljs-number\">1</span> | <span class=\"hljs-number\">1</span>]);\r\n    }\r\n  }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief This function updates the value at node with val\r\n   * @param node the node where the update is done\r\n   * @param val the value that is being updated\r\n   * @returns void\r\n   */</span>\r\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> node, X val)</span> </span>{\r\n    X diff = val - Tree&lt;X&gt;::t_val[node];\r\n    SG&lt;X&gt;::<span class=\"hljs-built_in\">update</span>(h_label[node], diff);\r\n    Tree&lt;X&gt;::t_val[node] = val;\r\n  }\r\n\r\n  <span class=\"hljs-comment\">/**\r\n   * @brief This function returns the sum of node values in the simple path from\r\n   * from node_1 to node_2\r\n   * @param a the node where the simple path starts\r\n   * @param b the node where the simple path ends\r\n   * (parameters are interchangeable, i.e., the function is commutative)\r\n   * @returns the sum of node values in the simple path from a to b\r\n   */</span>\r\n  <span class=\"hljs-function\">X <span class=\"hljs-title\">query</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>{\r\n    <span class=\"hljs-type\">int</span> lc = Tree&lt;X&gt;::<span class=\"hljs-built_in\">lca</span>(a, b);\r\n    X ret = SG&lt;X&gt;::sret_init;\r\n    <span class=\"hljs-built_in\">assert</span>(lc != <span class=\"hljs-number\">-1</span>);\r\n    ret += <span class=\"hljs-built_in\">chain_query</span>(a, lc);\r\n    ret += <span class=\"hljs-built_in\">chain_query</span>(b, lc);\r\n    <span class=\"hljs-keyword\">return</span> ret - Tree&lt;X&gt;::t_val[lc];\r\n  }\r\n};\r\n} <span class=\"hljs-comment\">// namespace heavy_light_decomposition</span>\r\n} <span class=\"hljs-comment\">// namespace range_queries</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Test implementations\r\n * @returns none\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_1</span><span class=\"hljs-params\">()</span> </span>{\r\n  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1:\\n&quot;</span>;\r\n\r\n  <span class=\"hljs-comment\">// Test details</span>\r\n  <span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">5</span>;\r\n  std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; node_values = {<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>};\r\n  std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; edges = {{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>}, {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>}};\r\n  std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; queries = {\r\n      {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>},\r\n      {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>},\r\n      {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>},\r\n  };\r\n  std::vector&lt;<span class=\"hljs-type\">int</span>&gt; expected_result = {<span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">8</span>};\r\n  std::vector&lt;<span class=\"hljs-type\">int</span>&gt; code_result;\r\n\r\n  range_queries::<span class=\"hljs-function\">heavy_light_decomposition::HLD&lt;<span class=\"hljs-type\">int64_t</span>&gt; <span class=\"hljs-title\">hld</span><span class=\"hljs-params\">(n)</span></span>;\r\n  hld.<span class=\"hljs-built_in\">set_node_val</span>(node_values);\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n - <span class=\"hljs-number\">1</span>; i++) {\r\n    <span class=\"hljs-type\">int</span> u = edges[i][<span class=\"hljs-number\">0</span>], v = edges[i][<span class=\"hljs-number\">1</span>];\r\n    hld.<span class=\"hljs-built_in\">add_edge</span>(u - <span class=\"hljs-number\">1</span>, v - <span class=\"hljs-number\">1</span>);\r\n  }\r\n  hld.<span class=\"hljs-built_in\">init</span>();\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;q : queries) {\r\n    <span class=\"hljs-type\">int</span> type = q[<span class=\"hljs-number\">0</span>];\r\n    <span class=\"hljs-keyword\">if</span> (type == <span class=\"hljs-number\">1</span>) {\r\n      <span class=\"hljs-type\">int</span> p = q[<span class=\"hljs-number\">1</span>], x = q[<span class=\"hljs-number\">2</span>];\r\n      hld.<span class=\"hljs-built_in\">update</span>(p - <span class=\"hljs-number\">1</span>, x);\r\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (type == <span class=\"hljs-number\">2</span>) {\r\n      <span class=\"hljs-type\">int</span> a = q[<span class=\"hljs-number\">1</span>], b = q[<span class=\"hljs-number\">2</span>];\r\n      code_result.<span class=\"hljs-built_in\">push_back</span>(hld.<span class=\"hljs-built_in\">query</span>(a - <span class=\"hljs-number\">1</span>, b - <span class=\"hljs-number\">1</span>));\r\n    } <span class=\"hljs-keyword\">else</span> {\r\n      <span class=\"hljs-keyword\">continue</span>;\r\n    }\r\n  }\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(expected_result.<span class=\"hljs-built_in\">size</span>()); i++) {\r\n    <span class=\"hljs-built_in\">assert</span>(expected_result[i] == code_result[i]);\r\n  }\r\n  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nTest 1 passed!\\n&quot;</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Second test implementations\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_2</span><span class=\"hljs-params\">()</span> </span>{\r\n  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2:\\n&quot;</span>;\r\n\r\n  <span class=\"hljs-comment\">// Test details (Bamboo)</span>\r\n  <span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">10</span>;\r\n  std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; node_values = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>};\r\n  std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; edges = {\r\n      {<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">5</span>}, {<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>}, {<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">7</span>}, {<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>}, {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">9</span>}, {<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">3</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">7</span>}};\r\n  std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; queries = {\r\n      {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">6</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">9</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>},\r\n      {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>},  {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">8</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>}};\r\n  std::vector&lt;<span class=\"hljs-type\">int</span>&gt; expected_result = {<span class=\"hljs-number\">27</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">45</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">34</span>};\r\n  std::vector&lt;<span class=\"hljs-type\">int</span>&gt; code_result;\r\n\r\n  range_queries::<span class=\"hljs-function\">heavy_light_decomposition::HLD&lt;<span class=\"hljs-type\">int64_t</span>&gt; <span class=\"hljs-title\">hld</span><span class=\"hljs-params\">(n)</span></span>;\r\n  hld.<span class=\"hljs-built_in\">set_node_val</span>(node_values);\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n - <span class=\"hljs-number\">1</span>; i++) {\r\n    <span class=\"hljs-type\">int</span> u = edges[i][<span class=\"hljs-number\">0</span>], v = edges[i][<span class=\"hljs-number\">1</span>];\r\n    hld.<span class=\"hljs-built_in\">add_edge</span>(u - <span class=\"hljs-number\">1</span>, v - <span class=\"hljs-number\">1</span>);\r\n  }\r\n  hld.<span class=\"hljs-built_in\">init</span>();\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;q : queries) {\r\n    <span class=\"hljs-type\">int</span> type = q[<span class=\"hljs-number\">0</span>];\r\n    <span class=\"hljs-keyword\">if</span> (type == <span class=\"hljs-number\">1</span>) {\r\n      <span class=\"hljs-type\">int</span> p = q[<span class=\"hljs-number\">1</span>], x = q[<span class=\"hljs-number\">2</span>];\r\n      hld.<span class=\"hljs-built_in\">update</span>(p - <span class=\"hljs-number\">1</span>, x);\r\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (type == <span class=\"hljs-number\">2</span>) {\r\n      <span class=\"hljs-type\">int</span> a = q[<span class=\"hljs-number\">1</span>], b = q[<span class=\"hljs-number\">2</span>];\r\n      code_result.<span class=\"hljs-built_in\">push_back</span>(hld.<span class=\"hljs-built_in\">query</span>(a - <span class=\"hljs-number\">1</span>, b - <span class=\"hljs-number\">1</span>));\r\n    } <span class=\"hljs-keyword\">else</span> {\r\n      <span class=\"hljs-keyword\">continue</span>;\r\n    }\r\n  }\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(expected_result.<span class=\"hljs-built_in\">size</span>()); i++) {\r\n    <span class=\"hljs-built_in\">assert</span>(expected_result[i] == code_result[i]);\r\n  }\r\n  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nTest2 passed!\\n&quot;</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Third test implementations\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_3</span><span class=\"hljs-params\">()</span> </span>{\r\n  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 3:\\n&quot;</span>;\r\n\r\n  <span class=\"hljs-comment\">// Test details</span>\r\n  <span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">8</span>;\r\n  std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; node_values = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">2</span>};\r\n  std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; edges = {{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}, {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>},\r\n                                         {<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">3</span>}, {<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">5</span>}, {<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">7</span>}};\r\n  std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; queries = {\r\n      {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>},\r\n      {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>}};\r\n  std::vector&lt;<span class=\"hljs-type\">int</span>&gt; expected_result = {<span class=\"hljs-number\">34</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">10</span>};\r\n  std::vector&lt;<span class=\"hljs-type\">int</span>&gt; code_result;\r\n\r\n  range_queries::<span class=\"hljs-function\">heavy_light_decomposition::HLD&lt;<span class=\"hljs-type\">int64_t</span>&gt; <span class=\"hljs-title\">hld</span><span class=\"hljs-params\">(n)</span></span>;\r\n  hld.<span class=\"hljs-built_in\">set_node_val</span>(node_values);\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n - <span class=\"hljs-number\">1</span>; i++) {\r\n    <span class=\"hljs-type\">int</span> u = edges[i][<span class=\"hljs-number\">0</span>], v = edges[i][<span class=\"hljs-number\">1</span>];\r\n    hld.<span class=\"hljs-built_in\">add_edge</span>(u - <span class=\"hljs-number\">1</span>, v - <span class=\"hljs-number\">1</span>);\r\n  }\r\n  hld.<span class=\"hljs-built_in\">init</span>();\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;q : queries) {\r\n    <span class=\"hljs-type\">int</span> type = q[<span class=\"hljs-number\">0</span>];\r\n    <span class=\"hljs-keyword\">if</span> (type == <span class=\"hljs-number\">1</span>) {\r\n      <span class=\"hljs-type\">int</span> p = q[<span class=\"hljs-number\">1</span>], x = q[<span class=\"hljs-number\">2</span>];\r\n      hld.<span class=\"hljs-built_in\">update</span>(p - <span class=\"hljs-number\">1</span>, x);\r\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (type == <span class=\"hljs-number\">2</span>) {\r\n      <span class=\"hljs-type\">int</span> a = q[<span class=\"hljs-number\">1</span>], b = q[<span class=\"hljs-number\">2</span>];\r\n      code_result.<span class=\"hljs-built_in\">push_back</span>(hld.<span class=\"hljs-built_in\">query</span>(a - <span class=\"hljs-number\">1</span>, b - <span class=\"hljs-number\">1</span>));\r\n    } <span class=\"hljs-keyword\">else</span> {\r\n      <span class=\"hljs-keyword\">continue</span>;\r\n    }\r\n  }\r\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(expected_result.<span class=\"hljs-built_in\">size</span>()); i++) {\r\n    <span class=\"hljs-built_in\">assert</span>(expected_result[i] == code_result[i]);\r\n  }\r\n  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nTest3 passed!\\n&quot;</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * Main function\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n  <span class=\"hljs-built_in\">test_1</span>();\r\n  <span class=\"hljs-built_in\">test_2</span>();\r\n  <span class=\"hljs-built_in\">test_3</span>();\r\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Aniruthan R",
      "email": "67466816+aneee004@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}