{
  "slug": "binary-tree",
  "name": "Binary Tree",
  "categories": [
    "datastructures",
    "tree"
  ],
  "body": {},
  "implementations": {
    "java": {
      "dir": "src\\main\\java\\com\\thealgorithms\\datastructures\\trees\\BinaryTree.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src\\main\\java\\com\\thealgorithms\\datastructures\\trees\\BinaryTree.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.datastructures.trees;\r\n\r\n<span class=\"hljs-keyword\">import</span> java.util.Queue;\r\n<span class=\"hljs-keyword\">import</span> java.util.LinkedList;\r\n\r\n<span class=\"hljs-comment\">/**\r\n * This entire class is used to build a Binary Tree data structure. There is the\r\n * Node Class and the Tree Class, both explained below.\r\n */</span>\r\n<span class=\"hljs-comment\">/**\r\n * A binary tree is a data structure in which an element has two\r\n * successors(children). The left child is usually smaller than the parent, and\r\n * the right child is usually bigger.\r\n *\r\n * <span class=\"hljs-doctag\">@author</span> Unknown\r\n */</span>\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BinaryTree</span> {\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * This class implements the nodes that will go on the Binary Tree. They\r\n     * consist of the data in them, the node to the left, the node to the right,\r\n     * and the parent from which they came from.\r\n     *\r\n     * <span class=\"hljs-doctag\">@author</span> Unknown\r\n     */</span>\r\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span> {\r\n\r\n        <span class=\"hljs-comment\">/**\r\n         * Data for the node\r\n         */</span>\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> data;\r\n        <span class=\"hljs-comment\">/**\r\n         * The Node to the left of this one\r\n         */</span>\r\n        <span class=\"hljs-keyword\">public</span> Node left;\r\n        <span class=\"hljs-comment\">/**\r\n         * The Node to the right of this one\r\n         */</span>\r\n        <span class=\"hljs-keyword\">public</span> Node right;\r\n        <span class=\"hljs-comment\">/**\r\n         * The parent of this node\r\n         */</span>\r\n        <span class=\"hljs-keyword\">public</span> Node parent;\r\n\r\n        <span class=\"hljs-comment\">/**\r\n         * Constructor of Node\r\n         *\r\n         * <span class=\"hljs-doctag\">@param</span> value Value to put in the node\r\n         */</span>\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Node</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> value)</span> {\r\n            data = value;\r\n            left = <span class=\"hljs-literal\">null</span>;\r\n            right = <span class=\"hljs-literal\">null</span>;\r\n            parent = <span class=\"hljs-literal\">null</span>;\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * The root of the Binary Tree\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> Node root;\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Constructor\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">BinaryTree</span><span class=\"hljs-params\">()</span> {\r\n        root = <span class=\"hljs-literal\">null</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Parameterized Constructor\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">BinaryTree</span><span class=\"hljs-params\">(Node root)</span> {\r\n        <span class=\"hljs-built_in\">this</span>.root = root;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Method to find a Node with a certain value\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> key Value being looked for\r\n     * <span class=\"hljs-doctag\">@return</span> The node if it finds it, otherwise returns the parent\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> Node <span class=\"hljs-title function_\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> {\r\n        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">current</span> <span class=\"hljs-operator\">=</span> root;\r\n        <span class=\"hljs-keyword\">while</span> (current != <span class=\"hljs-literal\">null</span>) {\r\n            <span class=\"hljs-keyword\">if</span> (key &lt; current.data) {\r\n                <span class=\"hljs-keyword\">if</span> (current.left == <span class=\"hljs-literal\">null</span>) {\r\n                    <span class=\"hljs-keyword\">return</span> current; <span class=\"hljs-comment\">// The key isn&#x27;t exist, returns the parent</span>\r\n                }\r\n                current = current.left;\r\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (key &gt; current.data) {\r\n                <span class=\"hljs-keyword\">if</span> (current.right == <span class=\"hljs-literal\">null</span>) {\r\n                    <span class=\"hljs-keyword\">return</span> current;\r\n                }\r\n                current = current.right;\r\n            } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-comment\">// If you find the value return it</span>\r\n                <span class=\"hljs-keyword\">return</span> current;\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Inserts certain value into the Binary Tree\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> value Value to be inserted\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">put</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> value)</span> {\r\n        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">newNode</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(value);\r\n        <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">null</span>) {\r\n            root = newNode;\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            <span class=\"hljs-comment\">// This will return the soon to be parent of the value you&#x27;re inserting</span>\r\n            <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">parent</span> <span class=\"hljs-operator\">=</span> find(value);\r\n\r\n            <span class=\"hljs-comment\">// This if/else assigns the new node to be either the left or right child of the parent</span>\r\n            <span class=\"hljs-keyword\">if</span> (value &lt; parent.data) {\r\n                parent.left = newNode;\r\n                parent.left.parent = parent;\r\n                <span class=\"hljs-keyword\">return</span>;\r\n            } <span class=\"hljs-keyword\">else</span> {\r\n                parent.right = newNode;\r\n                parent.right.parent = parent;\r\n                <span class=\"hljs-keyword\">return</span>;\r\n            }\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Deletes a given value from the Binary Tree\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> value Value to be deleted\r\n     * <span class=\"hljs-doctag\">@return</span> If the value was deleted\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> value)</span> {\r\n        <span class=\"hljs-comment\">// temp is the node to be deleted</span>\r\n        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> find(value);\r\n\r\n        <span class=\"hljs-comment\">// If the value doesn&#x27;t exist</span>\r\n        <span class=\"hljs-keyword\">if</span> (temp.data != value) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n        }\r\n\r\n        <span class=\"hljs-comment\">// No children</span>\r\n        <span class=\"hljs-keyword\">if</span> (temp.right == <span class=\"hljs-literal\">null</span> &amp;&amp; temp.left == <span class=\"hljs-literal\">null</span>) {\r\n            <span class=\"hljs-keyword\">if</span> (temp == root) {\r\n                root = <span class=\"hljs-literal\">null</span>;\r\n            } <span class=\"hljs-comment\">// This if/else assigns the new node to be either the left or right child of the parent</span>\r\n            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (temp.parent.data &lt; temp.data) {\r\n                temp.parent.right = <span class=\"hljs-literal\">null</span>;\r\n            } <span class=\"hljs-keyword\">else</span> {\r\n                temp.parent.left = <span class=\"hljs-literal\">null</span>;\r\n            }\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n        } <span class=\"hljs-comment\">// Two children</span>\r\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (temp.left != <span class=\"hljs-literal\">null</span> &amp;&amp; temp.right != <span class=\"hljs-literal\">null</span>) {\r\n            <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">successor</span> <span class=\"hljs-operator\">=</span> findSuccessor(temp);\r\n\r\n            <span class=\"hljs-comment\">// The left tree of temp is made the left tree of the successor</span>\r\n            successor.left = temp.left;\r\n            successor.left.parent = successor;\r\n\r\n            <span class=\"hljs-comment\">// If the successor has a right child, the child&#x27;s grandparent is it&#x27;s new parent</span>\r\n            <span class=\"hljs-keyword\">if</span> (successor.parent != temp) {\r\n                <span class=\"hljs-keyword\">if</span> (successor.right != <span class=\"hljs-literal\">null</span>) {\r\n                    successor.right.parent = successor.parent;\r\n                    successor.parent.left = successor.right;\r\n                    successor.right = temp.right;\r\n                    successor.right.parent = successor;\r\n                } <span class=\"hljs-keyword\">else</span> {\r\n                    successor.parent.left = <span class=\"hljs-literal\">null</span>;\r\n                    successor.right = temp.right;\r\n                    successor.right.parent = successor;\r\n                }\r\n            }\r\n\r\n            <span class=\"hljs-keyword\">if</span> (temp == root) {\r\n                successor.parent = <span class=\"hljs-literal\">null</span>;\r\n                root = successor;\r\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n            } <span class=\"hljs-comment\">// If you&#x27;re not deleting the root</span>\r\n            <span class=\"hljs-keyword\">else</span> {\r\n                successor.parent = temp.parent;\r\n\r\n                <span class=\"hljs-comment\">// This if/else assigns the new node to be either the left or right child of the parent</span>\r\n                <span class=\"hljs-keyword\">if</span> (temp.parent.data &lt; temp.data) {\r\n                    temp.parent.right = successor;\r\n                } <span class=\"hljs-keyword\">else</span> {\r\n                    temp.parent.left = successor;\r\n                }\r\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n            }\r\n        } <span class=\"hljs-comment\">// One child</span>\r\n        <span class=\"hljs-keyword\">else</span> {\r\n            <span class=\"hljs-comment\">// If it has a right child</span>\r\n            <span class=\"hljs-keyword\">if</span> (temp.right != <span class=\"hljs-literal\">null</span>) {\r\n                <span class=\"hljs-keyword\">if</span> (temp == root) {\r\n                    root = temp.right;\r\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n                }\r\n\r\n                temp.right.parent = temp.parent;\r\n\r\n                <span class=\"hljs-comment\">// Assigns temp to left or right child</span>\r\n                <span class=\"hljs-keyword\">if</span> (temp.data &lt; temp.parent.data) {\r\n                    temp.parent.left = temp.right;\r\n                } <span class=\"hljs-keyword\">else</span> {\r\n                    temp.parent.right = temp.right;\r\n                }\r\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n            } <span class=\"hljs-comment\">// If it has a left child</span>\r\n            <span class=\"hljs-keyword\">else</span> {\r\n                <span class=\"hljs-keyword\">if</span> (temp == root) {\r\n                    root = temp.left;\r\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n                }\r\n\r\n                temp.left.parent = temp.parent;\r\n\r\n                <span class=\"hljs-comment\">// Assigns temp to left or right side</span>\r\n                <span class=\"hljs-keyword\">if</span> (temp.data &lt; temp.parent.data) {\r\n                    temp.parent.left = temp.left;\r\n                } <span class=\"hljs-keyword\">else</span> {\r\n                    temp.parent.right = temp.left;\r\n                }\r\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n            }\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * This method finds the Successor to the Node given. Move right once and go\r\n     * left down the tree as far as you can\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> n Node that you want to find the Successor of\r\n     * <span class=\"hljs-doctag\">@return</span> The Successor of the node\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> Node <span class=\"hljs-title function_\">findSuccessor</span><span class=\"hljs-params\">(Node n)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (n.right == <span class=\"hljs-literal\">null</span>) {\r\n            <span class=\"hljs-keyword\">return</span> n;\r\n        }\r\n        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">current</span> <span class=\"hljs-operator\">=</span> n.right;\r\n        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">parent</span> <span class=\"hljs-operator\">=</span> n.right;\r\n        <span class=\"hljs-keyword\">while</span> (current != <span class=\"hljs-literal\">null</span>) {\r\n            parent = current;\r\n            current = current.left;\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> parent;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Returns the root of the Binary Tree\r\n     *\r\n     * <span class=\"hljs-doctag\">@return</span> the root of the Binary Tree\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> Node <span class=\"hljs-title function_\">getRoot</span><span class=\"hljs-params\">()</span> {\r\n        <span class=\"hljs-keyword\">return</span> root;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Prints leftChild - root - rightChild This is the equivalent of a depth\r\n     * first search\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> localRoot The local root of the binary tree\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">inOrder</span><span class=\"hljs-params\">(Node localRoot)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (localRoot != <span class=\"hljs-literal\">null</span>) {\r\n            inOrder(localRoot.left);\r\n            System.out.print(localRoot.data + <span class=\"hljs-string\">&quot; &quot;</span>);\r\n            inOrder(localRoot.right);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Prints root - leftChild - rightChild\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> localRoot The local root of the binary tree\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">preOrder</span><span class=\"hljs-params\">(Node localRoot)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (localRoot != <span class=\"hljs-literal\">null</span>) {\r\n            System.out.print(localRoot.data + <span class=\"hljs-string\">&quot; &quot;</span>);\r\n            preOrder(localRoot.left);\r\n            preOrder(localRoot.right);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Prints rightChild - leftChild - root\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> localRoot The local root of the binary tree\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">postOrder</span><span class=\"hljs-params\">(Node localRoot)</span> {\r\n        <span class=\"hljs-keyword\">if</span> (localRoot != <span class=\"hljs-literal\">null</span>) {\r\n            postOrder(localRoot.left);\r\n            postOrder(localRoot.right);\r\n            System.out.print(localRoot.data + <span class=\"hljs-string\">&quot; &quot;</span>);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * Prints the tree in a breadth first search order This is similar to\r\n     * pre-order traversal, but instead of being implemented with a stack (or\r\n     * recursion), it is implemented with a queue\r\n     *\r\n     * <span class=\"hljs-doctag\">@param</span> localRoot The local root of the binary tree\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">bfs</span><span class=\"hljs-params\">(Node localRoot)</span> {\r\n        <span class=\"hljs-comment\">// Create a queue for the order of the nodes</span>\r\n        Queue&lt;Node&gt; queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;Node&gt;();\r\n\r\n        <span class=\"hljs-comment\">// If the give root is null, then we don&#x27;t add to the queue</span>\r\n        <span class=\"hljs-comment\">// and won&#x27;t do anything</span>\r\n        <span class=\"hljs-keyword\">if</span> (localRoot != <span class=\"hljs-literal\">null</span>) {\r\n            queue.add(localRoot);\r\n        }\r\n\r\n        <span class=\"hljs-comment\">// Continue until the queue is empty</span>\r\n        <span class=\"hljs-keyword\">while</span> (!queue.isEmpty()) {\r\n            <span class=\"hljs-comment\">// Get the next node on the queue to visit</span>\r\n            localRoot = queue.remove();\r\n\r\n            <span class=\"hljs-comment\">// Print the data from the node we are visiting</span>\r\n            System.out.print(localRoot.data + <span class=\"hljs-string\">&quot; &quot;</span>);\r\n\r\n            <span class=\"hljs-comment\">// Add the children to the queue if not null</span>\r\n            <span class=\"hljs-keyword\">if</span> (localRoot.right != <span class=\"hljs-literal\">null</span>) {\r\n                queue.add(localRoot.right);\r\n            }\r\n            <span class=\"hljs-keyword\">if</span> (localRoot.left != <span class=\"hljs-literal\">null</span>) {\r\n                queue.add(localRoot.left);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "haskell": {
      "dir": "src\\BinaryTree\\BinaryTree.hs",
      "url": "https://github.com/TheAlgorithms/haskell/tree/master/src\\BinaryTree\\BinaryTree.hs",
      "code": "<span class=\"hljs-keyword\">module</span> BinaryTree.BinaryTree <span class=\"hljs-keyword\">where</span>\r\n\r\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">qualified</span> Data.List <span class=\"hljs-keyword\">as</span> L\r\n\r\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> <span class=\"hljs-type\">BTree</span> a = <span class=\"hljs-type\">Empty</span> | <span class=\"hljs-type\">Node</span> a (<span class=\"hljs-type\">BTree</span> <span class=\"hljs-title\">a</span>) (<span class=\"hljs-type\">BTree</span> <span class=\"hljs-title\">a</span>) <span class=\"hljs-keyword\">deriving</span> (<span class=\"hljs-type\">Show</span>)</span>\r\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> <span class=\"hljs-type\">Side</span> = <span class=\"hljs-type\">LeftSide</span> | <span class=\"hljs-type\">RightSide</span> <span class=\"hljs-keyword\">deriving</span> (<span class=\"hljs-type\">Eq</span>, <span class=\"hljs-type\">Show</span>)</span>\r\n\r\n<span class=\"hljs-comment\">-- Get subtree on specified side</span>\r\n<span class=\"hljs-title\">getSubTree</span> :: <span class=\"hljs-type\">Side</span> -&gt; <span class=\"hljs-type\">BTree</span> a -&gt; <span class=\"hljs-type\">BTree</span> a\r\n<span class=\"hljs-title\">getSubTree</span> _ <span class=\"hljs-type\">Empty</span> = <span class=\"hljs-type\">Empty</span>\r\n<span class=\"hljs-title\">getSubTree</span> s (<span class=\"hljs-type\">Node</span> _ l r) = <span class=\"hljs-keyword\">if</span> s == <span class=\"hljs-type\">LeftSide</span> <span class=\"hljs-keyword\">then</span> l <span class=\"hljs-keyword\">else</span> r\r\n\r\n<span class=\"hljs-comment\">-- Get Left Subtree</span>\r\n<span class=\"hljs-title\">getLeftTree</span> :: <span class=\"hljs-type\">BTree</span> a -&gt; <span class=\"hljs-type\">BTree</span> a\r\n<span class=\"hljs-title\">getLeftTree</span> <span class=\"hljs-type\">Empty</span> = <span class=\"hljs-type\">Empty</span>\r\n<span class=\"hljs-title\">getLeftTree</span> (<span class=\"hljs-type\">Node</span> _ l _) = l\r\n\r\n<span class=\"hljs-comment\">-- Get Right Subtree</span>\r\n<span class=\"hljs-title\">getRightTree</span> :: <span class=\"hljs-type\">BTree</span> a -&gt; <span class=\"hljs-type\">BTree</span> a\r\n<span class=\"hljs-title\">getRightTree</span> <span class=\"hljs-type\">Empty</span> = <span class=\"hljs-type\">Empty</span>\r\n<span class=\"hljs-title\">getRightTree</span> (<span class=\"hljs-type\">Node</span> _ _ r) = r\r\n\r\n<span class=\"hljs-comment\">-- Get string representation of node Data</span>\r\n<span class=\"hljs-title\">nodeShow</span> :: (<span class=\"hljs-type\">Show</span> a) =&gt; <span class=\"hljs-type\">BTree</span> a -&gt; <span class=\"hljs-type\">String</span>\r\n<span class=\"hljs-title\">nodeShow</span> <span class=\"hljs-type\">Empty</span> = <span class=\"hljs-string\">&quot;&quot;</span>\r\n<span class=\"hljs-title\">nodeShow</span> (<span class=\"hljs-type\">Node</span> val _ _) = show val\r\n\r\n<span class=\"hljs-comment\">-- Depth first traversal</span>\r\n<span class=\"hljs-title\">dfsList</span> :: <span class=\"hljs-type\">BTree</span> a -&gt; [a]\r\n<span class=\"hljs-title\">dfsList</span> <span class=\"hljs-type\">Empty</span> = []\r\n<span class=\"hljs-title\">dfsList</span> (<span class=\"hljs-type\">Node</span> n l r) = [n] ++ (dfsList l) ++ (dfsList r)\r\n\r\n<span class=\"hljs-comment\">-- Breadth first traversal.</span>\r\n<span class=\"hljs-title\">bfsList</span> :: <span class=\"hljs-type\">BTree</span> a -&gt; [a]\r\n<span class=\"hljs-title\">bfsList</span> <span class=\"hljs-type\">Empty</span> = []\r\n<span class=\"hljs-title\">bfsList</span> t = concat $ takeWhile (\\l -&gt; (length l) &gt; <span class=\"hljs-number\">0</span>) [getLevel i <span class=\"hljs-number\">0</span> t | i &lt;- [<span class=\"hljs-number\">0</span>..]]\r\n\r\n<span class=\"hljs-comment\">-- Get all nodes from a single level in the tree.</span>\r\n<span class=\"hljs-title\">getLevel</span> :: (<span class=\"hljs-type\">Num</span> b, <span class=\"hljs-type\">Enum</span> b, <span class=\"hljs-type\">Eq</span> b) =&gt; b -&gt; b -&gt; <span class=\"hljs-type\">BTree</span> a -&gt; [a]\r\n<span class=\"hljs-title\">getLevel</span> _ _ <span class=\"hljs-type\">Empty</span> = []\r\n<span class=\"hljs-title\">getLevel</span> <span class=\"hljs-number\">0</span> _ (<span class=\"hljs-type\">Node</span> n l r) = [n]\r\n<span class=\"hljs-title\">getLevel</span> level i (<span class=\"hljs-type\">Node</span> n l r)\r\n    | i == level = [n]\r\n    | otherwise = (getLevel level (i+<span class=\"hljs-number\">1</span>) l) ++ (getLevel level (i+<span class=\"hljs-number\">1</span>) r)\r\n\r\n<span class=\"hljs-comment\">-- Get a list of lists of nodes in each level</span>\r\n<span class=\"hljs-title\">getLevels</span> :: <span class=\"hljs-type\">BTree</span> a -&gt; [[a]]\r\n<span class=\"hljs-title\">getLevels</span> t = takeWhile (\\l -&gt; (length l) &gt; <span class=\"hljs-number\">0</span>) [getLevel i <span class=\"hljs-number\">0</span> t | i &lt;- [<span class=\"hljs-number\">0</span>..]]\r\n\r\n<span class=\"hljs-comment\">-- Get the depth of the tree</span>\r\n<span class=\"hljs-title\">getDepth</span> :: <span class=\"hljs-type\">BTree</span> a -&gt; <span class=\"hljs-type\">Int</span>\r\n<span class=\"hljs-title\">getDepth</span> t = length $ getLevels t\r\n\r\n<span class=\"hljs-comment\">-- Generate a Binary Tree from a list of values.</span>\r\n<span class=\"hljs-comment\">-- Assume list is in breadth first order.</span>\r\n<span class=\"hljs-title\">fromList</span> :: [a] -&gt; <span class=\"hljs-type\">BTree</span> a\r\n<span class=\"hljs-title\">fromList</span> lst = fromListInt <span class=\"hljs-number\">0</span> lst\r\n<span class=\"hljs-comment\">-- Internal function to convert list to tree.</span>\r\n<span class=\"hljs-title\">fromListInt</span> :: <span class=\"hljs-type\">Int</span> -&gt; [a] -&gt; <span class=\"hljs-type\">BTree</span> a\r\n<span class=\"hljs-title\">fromListInt</span> _ [] = <span class=\"hljs-type\">Empty</span>\r\n<span class=\"hljs-title\">fromListInt</span> i lst@(x:xs) = <span class=\"hljs-type\">Node</span> x (fromListInt (<span class=\"hljs-number\">2</span>*i + <span class=\"hljs-number\">1</span>) (drop (i+<span class=\"hljs-number\">1</span>) lst)) \r\n                                  (fromListInt (<span class=\"hljs-number\">2</span>*i + <span class=\"hljs-number\">2</span>) (drop (i+<span class=\"hljs-number\">2</span>) lst))\r\n\r\n<span class=\"hljs-comment\">-- Count number of nodes in the tree.</span>\r\n<span class=\"hljs-title\">numNodes</span> :: <span class=\"hljs-type\">BTree</span> a -&gt; <span class=\"hljs-type\">Int</span>\r\n<span class=\"hljs-title\">numNodes</span> t = length $ bfsList t\r\n\r\n<span class=\"hljs-comment\">-- Pretty Print a Binary Tree</span>\r\n<span class=\"hljs-title\">simplePrint</span> :: (<span class=\"hljs-type\">Show</span> a) =&gt; <span class=\"hljs-type\">BTree</span> a -&gt; <span class=\"hljs-type\">String</span>\r\n<span class=\"hljs-title\">simplePrint</span> <span class=\"hljs-type\">Empty</span> = <span class=\"hljs-string\">&quot;&quot;</span>\r\n<span class=\"hljs-title\">simplePrint</span> t = (nodeShow t) ++ <span class=\"hljs-string\">&quot; &quot;</span> ++ (simplePrint $ getLeftTree t) ++ (simplePrint $ getRightTree t)"
    }
  },
  "contributors": [
    {
      "name": "Stepfen Shawn",
      "email": "m18824909883@163.com",
      "commits": 1
    },
    {
      "name": "Artur Parowicz",
      "email": "arturparowicz@gmail,com",
      "commits": 1
    },
    {
      "name": "Taj",
      "email": "tjgurwara99@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Rak Laptudirm",
      "email": "raklaptudirm@gmail.com",
      "commits": 1
    },
    {
      "name": "liyl",
      "email": "30368453+yaolin-Li@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "babybug",
      "email": "bugbinbo@outlook.com",
      "commits": 1
    },
    {
      "name": "Himanshu Shekhar",
      "email": "himanshushekharb16@gmail.com",
      "commits": 1
    },
    {
      "name": "Aitor Fidalgo Sánchez",
      "email": "64830228+aitorfi@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Ian Cowan",
      "email": "38896380+iccowan@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Amit Kumar",
      "email": "kumanoit@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "1700022814",
      "email": "512620936@qq.com",
      "commits": 1
    },
    {
      "name": "khalil2535",
      "email": "khalil2535@localhost",
      "commits": 1
    },
    {
      "name": "Miki Pokryvailo",
      "email": "mpokryva@gmail.com",
      "commits": 1
    },
    {
      "name": "zacharyjones123",
      "email": "zrjones@ncsu.edu",
      "commits": 1
    },
    {
      "name": "Rian Gallagher",
      "email": "rianogallagher@gmail.com",
      "commits": 1
    },
    {
      "name": "Libin Yang",
      "email": "szuyanglb@outlook.com",
      "commits": 2
    },
    {
      "name": "Ashwin Narayan",
      "email": "ashwinnarayan1994@gmail.com",
      "commits": 5
    }
  ],
  "explanationUrl": {}
}