{
  "slug": "prim",
  "name": "Prim",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "graphs\\prim.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/graphs\\prim.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;Prim&#x27;s Algorithm.\r\n\r\n    Determines the minimum spanning tree(MST) of a graph using the Prim&#x27;s Algorithm.\r\n\r\n    Details: https://en.wikipedia.org/wiki/Prim%27s_algorithm\r\n&quot;&quot;&quot;</span>\r\n\r\n<span class=\"hljs-keyword\">import</span> heapq <span class=\"hljs-keyword\">as</span> hq\r\n<span class=\"hljs-keyword\">import</span> math\r\n<span class=\"hljs-keyword\">from</span> typing <span class=\"hljs-keyword\">import</span> Iterator\r\n\r\n\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Vertex</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;Class Vertex.&quot;&quot;&quot;</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, <span class=\"hljs-built_in\">id</span></span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Arguments:\r\n            id - input an id to identify the vertex\r\n        Attributes:\r\n            neighbors - a list of the vertices it is linked to\r\n            edges     - a dict to store the edges&#x27;s weight\r\n        &quot;&quot;&quot;</span>\r\n        self.<span class=\"hljs-built_in\">id</span> = <span class=\"hljs-built_in\">str</span>(<span class=\"hljs-built_in\">id</span>)\r\n        self.key = <span class=\"hljs-literal\">None</span>\r\n        self.pi = <span class=\"hljs-literal\">None</span>\r\n        self.neighbors = []\r\n        self.edges = {}  <span class=\"hljs-comment\"># {vertex:distance}</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__lt__</span>(<span class=\"hljs-params\">self, other</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;Comparison rule to &lt; operator.&quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">return</span> self.key &lt; other.key\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__repr__</span>(<span class=\"hljs-params\">self</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;Return the vertex id.&quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">return</span> self.<span class=\"hljs-built_in\">id</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_neighbor</span>(<span class=\"hljs-params\">self, vertex</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;Add a pointer to a vertex at neighbor&#x27;s list.&quot;&quot;&quot;</span>\r\n        self.neighbors.append(vertex)\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_edge</span>(<span class=\"hljs-params\">self, vertex, weight</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;Destination vertex and weight.&quot;&quot;&quot;</span>\r\n        self.edges[vertex.<span class=\"hljs-built_in\">id</span>] = weight\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">connect</span>(<span class=\"hljs-params\">graph, a, b, edge</span>):\r\n    <span class=\"hljs-comment\"># add the neighbors:</span>\r\n    graph[a - <span class=\"hljs-number\">1</span>].add_neighbor(graph[b - <span class=\"hljs-number\">1</span>])\r\n    graph[b - <span class=\"hljs-number\">1</span>].add_neighbor(graph[a - <span class=\"hljs-number\">1</span>])\r\n    <span class=\"hljs-comment\"># add the edges:</span>\r\n    graph[a - <span class=\"hljs-number\">1</span>].add_edge(graph[b - <span class=\"hljs-number\">1</span>], edge)\r\n    graph[b - <span class=\"hljs-number\">1</span>].add_edge(graph[a - <span class=\"hljs-number\">1</span>], edge)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">prim</span>(<span class=\"hljs-params\">graph: <span class=\"hljs-built_in\">list</span>, root: Vertex</span>) -&gt; <span class=\"hljs-built_in\">list</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;Prim&#x27;s Algorithm.\r\n\r\n    Runtime:\r\n        O(mn) with `m` edges and `n` vertices\r\n\r\n    Return:\r\n        List with the edges of a Minimum Spanning Tree\r\n\r\n    Usage:\r\n        prim(graph, graph[0])\r\n    &quot;&quot;&quot;</span>\r\n    a = []\r\n    <span class=\"hljs-keyword\">for</span> u <span class=\"hljs-keyword\">in</span> graph:\r\n        u.key = math.inf\r\n        u.pi = <span class=\"hljs-literal\">None</span>\r\n    root.key = <span class=\"hljs-number\">0</span>\r\n    q = graph[:]\r\n    <span class=\"hljs-keyword\">while</span> q:\r\n        u = <span class=\"hljs-built_in\">min</span>(q)\r\n        q.remove(u)\r\n        <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> u.neighbors:\r\n            <span class=\"hljs-keyword\">if</span> (v <span class=\"hljs-keyword\">in</span> q) <span class=\"hljs-keyword\">and</span> (u.edges[v.<span class=\"hljs-built_in\">id</span>] &lt; v.key):\r\n                v.pi = u\r\n                v.key = u.edges[v.<span class=\"hljs-built_in\">id</span>]\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">len</span>(graph)):\r\n        a.append((<span class=\"hljs-built_in\">int</span>(graph[i].<span class=\"hljs-built_in\">id</span>) + <span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">int</span>(graph[i].pi.<span class=\"hljs-built_in\">id</span>) + <span class=\"hljs-number\">1</span>))\r\n    <span class=\"hljs-keyword\">return</span> a\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">prim_heap</span>(<span class=\"hljs-params\">graph: <span class=\"hljs-built_in\">list</span>, root: Vertex</span>) -&gt; Iterator[<span class=\"hljs-built_in\">tuple</span>]:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;Prim&#x27;s Algorithm with min heap.\r\n\r\n    Runtime:\r\n        O((m + n)log n) with `m` edges and `n` vertices\r\n\r\n    Yield:\r\n        Edges of a Minimum Spanning Tree\r\n\r\n    Usage:\r\n        prim(graph, graph[0])\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-keyword\">for</span> u <span class=\"hljs-keyword\">in</span> graph:\r\n        u.key = math.inf\r\n        u.pi = <span class=\"hljs-literal\">None</span>\r\n    root.key = <span class=\"hljs-number\">0</span>\r\n\r\n    h = <span class=\"hljs-built_in\">list</span>(graph)\r\n    hq.heapify(h)\r\n\r\n    <span class=\"hljs-keyword\">while</span> h:\r\n        u = hq.heappop(h)\r\n        <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> u.neighbors:\r\n            <span class=\"hljs-keyword\">if</span> (v <span class=\"hljs-keyword\">in</span> h) <span class=\"hljs-keyword\">and</span> (u.edges[v.<span class=\"hljs-built_in\">id</span>] &lt; v.key):\r\n                v.pi = u\r\n                v.key = u.edges[v.<span class=\"hljs-built_in\">id</span>]\r\n                hq.heapify(h)\r\n\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">len</span>(graph)):\r\n        <span class=\"hljs-keyword\">yield</span> (<span class=\"hljs-built_in\">int</span>(graph[i].<span class=\"hljs-built_in\">id</span>) + <span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">int</span>(graph[i].pi.<span class=\"hljs-built_in\">id</span>) + <span class=\"hljs-number\">1</span>)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">test_vector</span>() -&gt; <span class=\"hljs-literal\">None</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    # Creates a list to store x vertices.\r\n    &gt;&gt;&gt; x = 5\r\n    &gt;&gt;&gt; G = [Vertex(n) for n in range(x)]\r\n\r\n    &gt;&gt;&gt; connect(G, 1, 2, 15)\r\n    &gt;&gt;&gt; connect(G, 1, 3, 12)\r\n    &gt;&gt;&gt; connect(G, 2, 4, 13)\r\n    &gt;&gt;&gt; connect(G, 2, 5, 5)\r\n    &gt;&gt;&gt; connect(G, 3, 2, 6)\r\n    &gt;&gt;&gt; connect(G, 3, 4, 6)\r\n    &gt;&gt;&gt; connect(G, 0, 0, 0)  # Generate the minimum spanning tree:\r\n    &gt;&gt;&gt; G_heap = G[:]\r\n    &gt;&gt;&gt; MST = prim(G, G[0])\r\n    &gt;&gt;&gt; MST_heap = prim_heap(G, G[0])\r\n    &gt;&gt;&gt; for i in MST:\r\n    ...     print(i)\r\n    (2, 3)\r\n    (3, 1)\r\n    (4, 3)\r\n    (5, 2)\r\n    &gt;&gt;&gt; for i in MST_heap:\r\n    ...     print(i)\r\n    (2, 3)\r\n    (3, 1)\r\n    (4, 3)\r\n    (5, 2)\r\n    &quot;&quot;&quot;</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    <span class=\"hljs-keyword\">import</span> doctest\r\n\r\n    doctest.testmod()\r\n"
    },
    "c-plus-plus": {
      "dir": "graph\\prim.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph\\prim.cpp",
      "code": "<span class=\"hljs-comment\">// C++ program to implement Prim&#x27;s Algorithm</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\r\n\r\n<span class=\"hljs-keyword\">using</span> PII = std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;;\r\n\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">prim</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;PII&gt; &gt; &amp;graph)</span> </span>{\r\n    <span class=\"hljs-comment\">// priority queue to maintain edges with respect to weights</span>\r\n    std::priority_queue&lt;PII, std::vector&lt;PII&gt;, std::greater&lt;PII&gt; &gt; Q;\r\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-title\">marked</span><span class=\"hljs-params\">(graph.size(), <span class=\"hljs-literal\">false</span>)</span></span>;\r\n    <span class=\"hljs-type\">int</span> minimum_cost = <span class=\"hljs-number\">0</span>;\r\n\r\n    Q.<span class=\"hljs-built_in\">push</span>(std::<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">0</span>, x));\r\n    <span class=\"hljs-keyword\">while</span> (!Q.<span class=\"hljs-built_in\">empty</span>()) {\r\n        <span class=\"hljs-comment\">// Select the edge with minimum weight</span>\r\n        PII p = Q.<span class=\"hljs-built_in\">top</span>();\r\n        Q.<span class=\"hljs-built_in\">pop</span>();\r\n        x = p.second;\r\n        <span class=\"hljs-comment\">// Checking for cycle</span>\r\n        <span class=\"hljs-keyword\">if</span> (marked[x] == <span class=\"hljs-literal\">true</span>) {\r\n            <span class=\"hljs-keyword\">continue</span>;\r\n        }\r\n        minimum_cost += p.first;\r\n        marked[x] = <span class=\"hljs-literal\">true</span>;\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> PII &amp;neighbor : graph[x]) {\r\n            <span class=\"hljs-type\">int</span> y = neighbor.second;\r\n            <span class=\"hljs-keyword\">if</span> (marked[y] == <span class=\"hljs-literal\">false</span>) {\r\n                Q.<span class=\"hljs-built_in\">push</span>(neighbor);\r\n            }\r\n        }\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> minimum_cost;\r\n}\r\n\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-type\">int</span> nodes = <span class=\"hljs-number\">0</span>, edges = <span class=\"hljs-number\">0</span>;\r\n    std::cin &gt;&gt; nodes &gt;&gt; edges;  <span class=\"hljs-comment\">// number of nodes &amp; edges in graph</span>\r\n    <span class=\"hljs-keyword\">if</span> (nodes == <span class=\"hljs-number\">0</span> || edges == <span class=\"hljs-number\">0</span>) {\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n    }\r\n\r\n    std::vector&lt;std::vector&lt;PII&gt; &gt; <span class=\"hljs-built_in\">graph</span>(nodes);\r\n\r\n    <span class=\"hljs-comment\">// Edges with their nodes &amp; weight</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; edges; ++i) {\r\n        <span class=\"hljs-type\">int</span> x = <span class=\"hljs-number\">0</span>, y = <span class=\"hljs-number\">0</span>, weight = <span class=\"hljs-number\">0</span>;\r\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; weight;\r\n        graph[x].<span class=\"hljs-built_in\">push_back</span>(std::<span class=\"hljs-built_in\">make_pair</span>(weight, y));\r\n        graph[y].<span class=\"hljs-built_in\">push_back</span>(std::<span class=\"hljs-built_in\">make_pair</span>(weight, x));\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// Selecting 1 as the starting node</span>\r\n    <span class=\"hljs-type\">int</span> minimum_cost = <span class=\"hljs-built_in\">prim</span>(<span class=\"hljs-number\">1</span>, graph);\r\n    std::cout &lt;&lt; minimum_cost &lt;&lt; std::endl;\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    },
    "c": {
      "dir": "greedy_approach\\prim.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/greedy_approach\\prim.c",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @author [Timothy Maloney](https://github.com/sl1mb0)\r\n * @brief [Prim&#x27;s algorithm](https://en.wikipedia.org/wiki/Prim%27s_algorithm)\r\n * implementation in C to find the MST of a weighted, connected graph.\r\n * @details Prim&#x27;s algorithm uses a greedy approach to generate the MST of a weighted connected graph.\r\n * The algorithm begins at an arbitrary vertex v, and selects a next vertex u, \r\n * where v and u are connected by a weighted edge whose weight is the minimum of all edges connected to v. \r\n * @references Page 319 &quot;Introduction to the Design and Analysis of Algorithms&quot; - Anany Levitin\r\n *\r\n * To test - run &#x27;./prim -test&#x27;\r\n * prim() will find the MST of the following adj. matrix:\r\n *\t  \r\n *\t  0  1  2  3\r\n *        1  0  4  6\r\n *        2  4  0  5\r\n *        3  6  5  0\r\n * \r\n * The minimum spanning tree for the above weighted connected graph is given by the following adj matrix:\r\n *\t   \r\n *\t  0  1  2  3\r\n *\t  1  0  0  0\r\n *\t  2  0  0  0\r\n *\t  3  0  0  0\r\n *\r\n *\r\n * The following [link](https://visualgo.net/en/mst) provides a visual representation of graphs that can be used to test/verify the algorithm for different adj\r\n * matrices and their weighted, connected graphs.\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span>        <span class=\"hljs-comment\">/// for IO operations</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span>      <span class=\"hljs-comment\">/// for string comparison</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span>     <span class=\"hljs-comment\">/// for assert()</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;inttypes.h&gt;</span>  <span class=\"hljs-comment\">/// for uint16_t</span></span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> MAX 20</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> INF 999</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Finds index of minimum element in edge list for an arbitrary vertex\r\n * @param arr graph row\r\n * @param N number of elements in arr\r\n * @returns index of minimum element in arr\r\n */</span>\r\n<span class=\"hljs-type\">uint16_t</span> <span class=\"hljs-title function_\">minimum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint16_t</span> arr[], <span class=\"hljs-type\">uint16_t</span> N)</span>\r\n{\r\n    <span class=\"hljs-type\">uint16_t</span> index = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-type\">uint16_t</span> min = INF;\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint16_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\r\n    {\r\n        <span class=\"hljs-keyword\">if</span> (arr[i] &lt; min)\r\n        {\r\n            min = arr[i];\r\n            index = i;\r\n        }\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> index;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Used to find MST of user-generated adj matrix G\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">prim</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint16_t</span> G[][MAX], <span class=\"hljs-type\">uint16_t</span> MST[][MAX], <span class=\"hljs-type\">uint16_t</span> V)</span>\r\n{\r\n    <span class=\"hljs-type\">uint16_t</span> u, v;\r\n    <span class=\"hljs-type\">uint16_t</span> E_t[MAX], path[MAX];\r\n    <span class=\"hljs-type\">uint16_t</span> V_t[MAX], no_of_edges;\r\n\r\n    E_t[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// edges for current vertex</span>\r\n    V_t[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">// list of visited vertices</span>\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint16_t</span> i = <span class=\"hljs-number\">1</span>; i &lt; V; i++)\r\n    {\r\n        E_t[i] = G[i][<span class=\"hljs-number\">0</span>];\r\n        path[i] = <span class=\"hljs-number\">0</span>;\r\n        V_t[i] = <span class=\"hljs-number\">0</span>;\r\n    }\r\n\r\n    no_of_edges = V - <span class=\"hljs-number\">1</span>;\r\n\r\n    <span class=\"hljs-keyword\">while</span> (no_of_edges &gt; <span class=\"hljs-number\">0</span>)\r\n    {\r\n        u = minimum(E_t, V);\r\n        <span class=\"hljs-keyword\">while</span> (V_t[u] == <span class=\"hljs-number\">1</span>)\r\n        {\r\n            E_t[u] = INF;\r\n            u = minimum(E_t, V);\r\n        }\r\n\r\n        v = path[u];\r\n        MST[v][u] = E_t[u];\r\n        MST[u][v] = E_t[u];\r\n        no_of_edges--;\r\n        V_t[u] = <span class=\"hljs-number\">1</span>;\r\n\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint16_t</span> i = <span class=\"hljs-number\">1</span>; i &lt; V; i++)\r\n        {\r\n            <span class=\"hljs-keyword\">if</span> (V_t[i] == <span class=\"hljs-number\">0</span> &amp;&amp; G[u][i] &lt; E_t[i])\r\n            {\r\n                E_t[i] = G[u][i];\r\n                path[i] = v;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Self-test implementations\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint16_t</span> G[][MAX], <span class=\"hljs-type\">uint16_t</span> MST[][MAX], <span class=\"hljs-type\">uint16_t</span> V)</span>\r\n{\r\n \r\n  <span class=\"hljs-type\">uint16_t</span> test[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>] = {{<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>},{<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">6</span>},{<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">5</span>},{<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">0</span>}};\r\n  <span class=\"hljs-type\">uint16_t</span> solution[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>] = {{<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>},{<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>},{<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>},{<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>}};\r\n\r\n  V = <span class=\"hljs-number\">4</span>;\r\n\r\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">uint16_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; ++i)\r\n  {\r\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">uint16_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; V; ++j)\r\n    {\r\n      G[i][j] = test[i][j];\r\n    }\r\n  }\r\n\r\n  prim(&amp;(*G),&amp;(*MST),V);\r\n\r\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">uint16_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; ++i)\r\n  {\r\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">uint16_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; V; ++j)\r\n    {\r\n      assert(MST[i][j] == solution[i][j]);\r\n    }\r\n  }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function user_graph();\r\n * gets user input adj. matrix and finds MST of that graph\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">user_graph</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint16_t</span> G[][MAX], <span class=\"hljs-type\">uint16_t</span> MST[][MAX], <span class=\"hljs-type\">uint16_t</span> V)</span>\r\n{\r\n      <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter the number of vertices: &quot;</span>);\r\n      <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot; %hd&quot;</span>, &amp;V);\r\n\r\n      assert(V &lt;= MAX);\r\n\r\n      <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter the adj matrix\\n&quot;</span>);\r\n      <span class=\"hljs-type\">uint16_t</span> i, j;\r\n      <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; V; ++i)\r\n      {\r\n          <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; V; ++j)\r\n          {\r\n              <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;G[%d][%d]: &quot;</span>, i, j);\r\n              <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot; %hd&quot;</span>, &amp;G[i][j]);\r\n              <span class=\"hljs-keyword\">if</span> (G[i][j] == <span class=\"hljs-number\">0</span>)\r\n                  G[i][j] = INF;\r\n          }\r\n      }\r\n\r\n      prim(&amp;(*G),&amp;(*MST),V);\r\n\r\n      <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;minimum spanning tree:\\n&quot;</span>);\r\n      <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; V; ++i)\r\n      {\r\n          <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);\r\n          <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; V; ++j)\r\n          {\r\n              <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\t&quot;</span>, MST[i][j]);\r\n          }\r\n      }\r\n}\r\n\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @param argc commandline argument count (ignored)\r\n * @param argv commandline array of arguments (ignored)\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> <span class=\"hljs-type\">const</span> *argv[])</span>\r\n{   \r\n\r\n    <span class=\"hljs-type\">uint16_t</span> G[MAX][MAX];    <span class=\"hljs-comment\">///&lt; weighted, connected graph G</span>\r\n    <span class=\"hljs-type\">uint16_t</span> MST[MAX][MAX];  <span class=\"hljs-comment\">///&lt; adj matrix to hold minimum spanning tree of G</span>\r\n    <span class=\"hljs-type\">uint16_t</span> V;              <span class=\"hljs-comment\">///&lt; number of vertices in V in G</span>\r\n\r\n\r\n    <span class=\"hljs-keyword\">if</span>(argc == <span class=\"hljs-number\">2</span> &amp;&amp; <span class=\"hljs-built_in\">strcmp</span>(argv[<span class=\"hljs-number\">1</span>],<span class=\"hljs-string\">&quot;-test&quot;</span>) == <span class=\"hljs-number\">0</span>)\r\n    {\r\n      test(&amp;(*G),&amp;(*MST),V);\r\n    }\r\n    <span class=\"hljs-keyword\">else</span>\r\n    {\r\n      user_graph(&amp;(*G),&amp;(*MST),V);\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    },
    "rust": {
      "dir": "src\\graph\\prim.rs",
      "url": "https://github.com/TheAlgorithms/rust/tree/master/src\\graph\\prim.rs",
      "code": "<span class=\"hljs-keyword\">use</span> std::cmp::Reverse;\r\n<span class=\"hljs-keyword\">use</span> std::collections::{BTreeMap, BinaryHeap};\r\n<span class=\"hljs-keyword\">use</span> std::ops::Add;\r\n\r\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Graph</span>&lt;V, E&gt; = BTreeMap&lt;V, BTreeMap&lt;V, E&gt;&gt;;\r\n\r\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">add_edge</span>&lt;V: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span>, E: <span class=\"hljs-built_in\">Ord</span> + Add + <span class=\"hljs-built_in\">Copy</span>&gt;(graph: &amp;<span class=\"hljs-keyword\">mut</span> Graph&lt;V, E&gt;, v1: V, v2: V, c: E) {\r\n    graph.<span class=\"hljs-title function_ invoke__\">entry</span>(v1).<span class=\"hljs-title function_ invoke__\">or_insert_with</span>(BTreeMap::new).<span class=\"hljs-title function_ invoke__\">insert</span>(v2, c);\r\n    graph.<span class=\"hljs-title function_ invoke__\">entry</span>(v2).<span class=\"hljs-title function_ invoke__\">or_insert_with</span>(BTreeMap::new).<span class=\"hljs-title function_ invoke__\">insert</span>(v1, c);\r\n}\r\n\r\n<span class=\"hljs-comment\">// selects a start and run the algorithm from it</span>\r\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">prim</span>&lt;V: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span> + std::fmt::<span class=\"hljs-built_in\">Debug</span>, E: <span class=\"hljs-built_in\">Ord</span> + Add + <span class=\"hljs-built_in\">Copy</span> + std::fmt::<span class=\"hljs-built_in\">Debug</span>&gt;(\r\n    graph: &amp;Graph&lt;V, E&gt;,\r\n) <span class=\"hljs-punctuation\">-&gt;</span> Graph&lt;V, E&gt; {\r\n    <span class=\"hljs-keyword\">match</span> graph.<span class=\"hljs-title function_ invoke__\">keys</span>().<span class=\"hljs-title function_ invoke__\">next</span>() {\r\n        <span class=\"hljs-title function_ invoke__\">Some</span>(v) =&gt; <span class=\"hljs-title function_ invoke__\">prim_with_start</span>(graph, *v),\r\n        <span class=\"hljs-literal\">None</span> =&gt; BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>(),\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">// only works for a connected graph</span>\r\n<span class=\"hljs-comment\">// if the given graph is not connected it will return the MST of the connected subgraph</span>\r\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">prim_with_start</span>&lt;V: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span>, E: <span class=\"hljs-built_in\">Ord</span> + Add + <span class=\"hljs-built_in\">Copy</span>&gt;(\r\n    graph: &amp;Graph&lt;V, E&gt;,\r\n    start: V,\r\n) <span class=\"hljs-punctuation\">-&gt;</span> Graph&lt;V, E&gt; {\r\n    <span class=\"hljs-comment\">// will contain the MST</span>\r\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">mst</span>: Graph&lt;V, E&gt; = Graph::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n    <span class=\"hljs-comment\">// a priority queue based on a binary heap, used to get the cheapest edge</span>\r\n    <span class=\"hljs-comment\">// the elements are an edge: the cost, destination and source</span>\r\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">prio</span> = BinaryHeap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n\r\n    mst.<span class=\"hljs-title function_ invoke__\">insert</span>(start, BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>());\r\n\r\n    <span class=\"hljs-title function_ invoke__\">for</span> (v, c) <span class=\"hljs-keyword\">in</span> &amp;graph[&amp;start] {\r\n        <span class=\"hljs-comment\">// the heap is a max heap, we have to use Reverse when adding to simulate a min heap</span>\r\n        prio.<span class=\"hljs-title function_ invoke__\">push</span>(<span class=\"hljs-title function_ invoke__\">Reverse</span>((*c, v, start)));\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">Some</span>(<span class=\"hljs-title function_ invoke__\">Reverse</span>((dist, t, prev))) = prio.<span class=\"hljs-title function_ invoke__\">pop</span>() {\r\n        <span class=\"hljs-comment\">// the destination of the edge has already been seen</span>\r\n        <span class=\"hljs-keyword\">if</span> mst.<span class=\"hljs-title function_ invoke__\">contains_key</span>(t) {\r\n            <span class=\"hljs-keyword\">continue</span>;\r\n        }\r\n\r\n        <span class=\"hljs-comment\">// the destination is a new vertex</span>\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> mst, prev, *t, dist);\r\n\r\n        <span class=\"hljs-title function_ invoke__\">for</span> (v, c) <span class=\"hljs-keyword\">in</span> &amp;graph[t] {\r\n            <span class=\"hljs-keyword\">if</span> !mst.<span class=\"hljs-title function_ invoke__\">contains_key</span>(v) {\r\n                prio.<span class=\"hljs-title function_ invoke__\">push</span>(<span class=\"hljs-title function_ invoke__\">Reverse</span>((*c, v, *t)));\r\n            }\r\n        }\r\n    }\r\n\r\n    mst\r\n}\r\n\r\n<span class=\"hljs-meta\">#[cfg(test)]</span>\r\n<span class=\"hljs-keyword\">mod</span> tests {\r\n    <span class=\"hljs-keyword\">use</span> super::{add_edge, prim, Graph};\r\n    <span class=\"hljs-keyword\">use</span> std::collections::BTreeMap;\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">empty</span>() {\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(prim::&lt;<span class=\"hljs-type\">usize</span>, <span class=\"hljs-type\">usize</span>&gt;(&amp;BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>()), BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>());\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">single_vertex</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span>: Graph&lt;<span class=\"hljs-type\">usize</span>, <span class=\"hljs-type\">usize</span>&gt; = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        graph.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">42</span>, BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>());\r\n\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">prim</span>(&amp;graph), graph);\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">single_edge</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">42</span>, <span class=\"hljs-number\">666</span>, <span class=\"hljs-number\">12</span>);\r\n\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">prim</span>(&amp;graph), graph);\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">tree_1</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">11</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">12</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">13</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">14</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">15</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">16</span>);\r\n\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">prim</span>(&amp;graph), graph);\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">tree_2</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">11</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">12</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">13</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">14</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">15</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">16</span>);\r\n\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">prim</span>(&amp;graph), graph);\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">tree_3</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n\r\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..<span class=\"hljs-number\">100</span> {\r\n            <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, i, <span class=\"hljs-number\">2</span> * i, i);\r\n            <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, i, <span class=\"hljs-number\">2</span> * i + <span class=\"hljs-number\">1</span>, -i);\r\n        }\r\n\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">prim</span>(&amp;graph), graph);\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">graph_1</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">6</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">7</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-number\">2</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;f&#x27;</span>, <span class=\"hljs-number\">3</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">5</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-number\">5</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-number\">4</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-string\">&#x27;f&#x27;</span>, <span class=\"hljs-number\">1</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-string\">&#x27;f&#x27;</span>, <span class=\"hljs-number\">2</span>);\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">ans</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> ans, <span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-string\">&#x27;f&#x27;</span>, <span class=\"hljs-number\">1</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> ans, <span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-string\">&#x27;f&#x27;</span>, <span class=\"hljs-number\">2</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> ans, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-number\">2</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> ans, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">5</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> ans, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-number\">5</span>);\r\n\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">prim</span>(&amp;graph), ans);\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">graph_2</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">6</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">4</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">6</span>);\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">ans</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> ans, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> ans, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> ans, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> ans, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> ans, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">4</span>);\r\n\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">prim</span>(&amp;graph), ans);\r\n    }\r\n\r\n    <span class=\"hljs-meta\">#[test]</span>\r\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">graph_3</span>() {\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&quot;v1&quot;</span>, <span class=\"hljs-string\">&quot;v2&quot;</span>, <span class=\"hljs-number\">1</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&quot;v1&quot;</span>, <span class=\"hljs-string\">&quot;v3&quot;</span>, <span class=\"hljs-number\">3</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&quot;v1&quot;</span>, <span class=\"hljs-string\">&quot;v5&quot;</span>, <span class=\"hljs-number\">6</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&quot;v2&quot;</span>, <span class=\"hljs-string\">&quot;v3&quot;</span>, <span class=\"hljs-number\">2</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&quot;v2&quot;</span>, <span class=\"hljs-string\">&quot;v4&quot;</span>, <span class=\"hljs-number\">3</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&quot;v2&quot;</span>, <span class=\"hljs-string\">&quot;v5&quot;</span>, <span class=\"hljs-number\">5</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&quot;v3&quot;</span>, <span class=\"hljs-string\">&quot;v4&quot;</span>, <span class=\"hljs-number\">5</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&quot;v3&quot;</span>, <span class=\"hljs-string\">&quot;v6&quot;</span>, <span class=\"hljs-number\">2</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&quot;v4&quot;</span>, <span class=\"hljs-string\">&quot;v5&quot;</span>, <span class=\"hljs-number\">2</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&quot;v4&quot;</span>, <span class=\"hljs-string\">&quot;v6&quot;</span>, <span class=\"hljs-number\">4</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&quot;v5&quot;</span>, <span class=\"hljs-string\">&quot;v6&quot;</span>, <span class=\"hljs-number\">1</span>);\r\n\r\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">ans</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> ans, <span class=\"hljs-string\">&quot;v1&quot;</span>, <span class=\"hljs-string\">&quot;v2&quot;</span>, <span class=\"hljs-number\">1</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> ans, <span class=\"hljs-string\">&quot;v5&quot;</span>, <span class=\"hljs-string\">&quot;v6&quot;</span>, <span class=\"hljs-number\">1</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> ans, <span class=\"hljs-string\">&quot;v2&quot;</span>, <span class=\"hljs-string\">&quot;v3&quot;</span>, <span class=\"hljs-number\">2</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> ans, <span class=\"hljs-string\">&quot;v3&quot;</span>, <span class=\"hljs-string\">&quot;v6&quot;</span>, <span class=\"hljs-number\">2</span>);\r\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> ans, <span class=\"hljs-string\">&quot;v4&quot;</span>, <span class=\"hljs-string\">&quot;v5&quot;</span>, <span class=\"hljs-number\">2</span>);\r\n\r\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">prim</span>(&amp;graph), ans);\r\n    }\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 1
    },
    {
      "name": "Pierre Gimalac",
      "email": "pierre.gimalac@gmail.com",
      "commits": 1
    },
    {
      "name": "shellhub",
      "email": "shellhub.me@gmail.com",
      "commits": 1
    },
    {
      "name": "Tim Maloney",
      "email": "tmaloney@pdx.edu",
      "commits": 1
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Mansi Mittal",
      "email": "m16mittal@gmail.com",
      "commits": 1
    },
    {
      "name": "Himanshu Airan",
      "email": "62210670+Himanshu-77@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Kyle",
      "email": "40903431+kylepw@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Bruno Santos",
      "email": "7022432+dunderbruno@users.noreply.github.com",
      "commits": 2
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 4
    }
  ],
  "explanationUrl": {}
}