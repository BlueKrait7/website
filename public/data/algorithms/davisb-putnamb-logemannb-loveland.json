{
  "slug": "davisb-putnamb-logemannb-loveland",
  "name": "Davisb Putnamb Logemannb Loveland",
  "categories": [
    "others"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "other\\davisb_putnamb_logemannb_loveland.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/other\\davisb_putnamb_logemannb_loveland.py",
      "code": "<span class=\"hljs-comment\">#!/usr/bin/env python3</span>\r\n\r\n<span class=\"hljs-string\">&quot;&quot;&quot;\r\nDavis–Putnam–Logemann–Loveland (DPLL) algorithm is a complete, backtracking-based\r\nsearch algorithm for deciding the satisfiability of propositional logic formulae in\r\nconjunctive normal form, i.e, for solving the Conjunctive Normal Form SATisfiability\r\n(CNF-SAT) problem.\r\n\r\nFor more information about the algorithm: https://en.wikipedia.org/wiki/DPLL_algorithm\r\n&quot;&quot;&quot;</span>\r\n<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\r\n\r\n<span class=\"hljs-keyword\">import</span> random\r\n<span class=\"hljs-keyword\">from</span> typing <span class=\"hljs-keyword\">import</span> Iterable\r\n\r\n\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Clause</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    A clause represented in Conjunctive Normal Form.\r\n    A clause is a set of literals, either complemented or otherwise.\r\n    For example:\r\n        {A1, A2, A3&#x27;} is the clause (A1 v A2 v A3&#x27;)\r\n        {A5&#x27;, A2&#x27;, A1} is the clause (A5&#x27; v A2&#x27; v A1)\r\n\r\n    Create model\r\n    &gt;&gt;&gt; clause = Clause([&quot;A1&quot;, &quot;A2&#x27;&quot;, &quot;A3&quot;])\r\n    &gt;&gt;&gt; clause.evaluate({&quot;A1&quot;: True})\r\n    True\r\n    &quot;&quot;&quot;</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, literals: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">str</span>]</span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Represent the literals and an assignment in a clause.&quot;\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-comment\"># Assign all literals to None initially</span>\r\n        self.literals: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">bool</span> | <span class=\"hljs-literal\">None</span>] = {literal: <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">for</span> literal <span class=\"hljs-keyword\">in</span> literals}\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__str__</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-built_in\">str</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        To print a clause as in Conjunctive Normal Form.\r\n        &gt;&gt;&gt; str(Clause([&quot;A1&quot;, &quot;A2&#x27;&quot;, &quot;A3&quot;]))\r\n        &quot;{A1 , A2&#x27; , A3}&quot;\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;{&quot;</span> + <span class=\"hljs-string\">&quot; , &quot;</span>.join(self.literals) + <span class=\"hljs-string\">&quot;}&quot;</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__len__</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        To print a clause as in Conjunctive Normal Form.\r\n        &gt;&gt;&gt; len(Clause([]))\r\n        0\r\n        &gt;&gt;&gt; len(Clause([&quot;A1&quot;, &quot;A2&#x27;&quot;, &quot;A3&quot;]))\r\n        3\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(self.literals)\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-params\">self, model: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">bool</span> | <span class=\"hljs-literal\">None</span>]</span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Assign values to literals of the clause as given by model.\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">for</span> literal <span class=\"hljs-keyword\">in</span> self.literals:\r\n            symbol = literal[:<span class=\"hljs-number\">2</span>]\r\n            <span class=\"hljs-keyword\">if</span> symbol <span class=\"hljs-keyword\">in</span> model:\r\n                value = model[symbol]\r\n            <span class=\"hljs-keyword\">else</span>:\r\n                <span class=\"hljs-keyword\">continue</span>\r\n            <span class=\"hljs-keyword\">if</span> value <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span>:\r\n                <span class=\"hljs-comment\"># Complement assignment if literal is in complemented form</span>\r\n                <span class=\"hljs-keyword\">if</span> literal.endswith(<span class=\"hljs-string\">&quot;&#x27;&quot;</span>):\r\n                    value = <span class=\"hljs-keyword\">not</span> value\r\n            self.literals[literal] = value\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">evaluate</span>(<span class=\"hljs-params\">self, model: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">bool</span> | <span class=\"hljs-literal\">None</span>]</span>) -&gt; <span class=\"hljs-built_in\">bool</span> | <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Evaluates the clause with the assignments in model.\r\n        This has the following steps:\r\n        1. Return True if both a literal and its complement exist in the clause.\r\n        2. Return True if a single literal has the assignment True.\r\n        3. Return None(unable to complete evaluation) if a literal has no assignment.\r\n        4. Compute disjunction of all values assigned in clause.\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">for</span> literal <span class=\"hljs-keyword\">in</span> self.literals:\r\n            symbol = literal.rstrip(<span class=\"hljs-string\">&quot;&#x27;&quot;</span>) <span class=\"hljs-keyword\">if</span> literal.endswith(<span class=\"hljs-string\">&quot;&#x27;&quot;</span>) <span class=\"hljs-keyword\">else</span> literal + <span class=\"hljs-string\">&quot;&#x27;&quot;</span>\r\n            <span class=\"hljs-keyword\">if</span> symbol <span class=\"hljs-keyword\">in</span> self.literals:\r\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\r\n\r\n        self.assign(model)\r\n        <span class=\"hljs-keyword\">for</span> value <span class=\"hljs-keyword\">in</span> self.literals.values():\r\n            <span class=\"hljs-keyword\">if</span> value <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-literal\">True</span>, <span class=\"hljs-literal\">None</span>):\r\n                <span class=\"hljs-keyword\">return</span> value\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">any</span>(self.literals.values())\r\n\r\n\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Formula</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    A formula represented in Conjunctive Normal Form.\r\n    A formula is a set of clauses.\r\n    For example,\r\n        {{A1, A2, A3&#x27;}, {A5&#x27;, A2&#x27;, A1}} is ((A1 v A2 v A3&#x27;) and (A5&#x27; v A2&#x27; v A1))\r\n    &quot;&quot;&quot;</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, clauses: Iterable[Clause]</span>) -&gt; <span class=\"hljs-literal\">None</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Represent the number of clauses and the clauses themselves.\r\n        &quot;&quot;&quot;</span>\r\n        self.clauses = <span class=\"hljs-built_in\">list</span>(clauses)\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__str__</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-built_in\">str</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        To print a formula as in Conjunctive Normal Form.\r\n        str(Formula([Clause([&quot;A1&quot;, &quot;A2&#x27;&quot;, &quot;A3&quot;]), Clause([&quot;A5&#x27;&quot;, &quot;A2&#x27;&quot;, &quot;A1&quot;])]))\r\n        &quot;{{A1 , A2&#x27; , A3} , {A5&#x27; , A2&#x27; , A1}}&quot;\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;{&quot;</span> + <span class=\"hljs-string\">&quot; , &quot;</span>.join(<span class=\"hljs-built_in\">str</span>(clause) <span class=\"hljs-keyword\">for</span> clause <span class=\"hljs-keyword\">in</span> self.clauses) + <span class=\"hljs-string\">&quot;}&quot;</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">generate_clause</span>() -&gt; Clause:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Randomly generate a clause.\r\n    All literals have the name Ax, where x is an integer from 1 to 5.\r\n    &quot;&quot;&quot;</span>\r\n    literals = []\r\n    no_of_literals = random.randint(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>)\r\n    base_var = <span class=\"hljs-string\">&quot;A&quot;</span>\r\n    i = <span class=\"hljs-number\">0</span>\r\n    <span class=\"hljs-keyword\">while</span> i &lt; no_of_literals:\r\n        var_no = random.randint(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>)\r\n        var_name = base_var + <span class=\"hljs-built_in\">str</span>(var_no)\r\n        var_complement = random.randint(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>)\r\n        <span class=\"hljs-keyword\">if</span> var_complement == <span class=\"hljs-number\">1</span>:\r\n            var_name += <span class=\"hljs-string\">&quot;&#x27;&quot;</span>\r\n        <span class=\"hljs-keyword\">if</span> var_name <span class=\"hljs-keyword\">in</span> literals:\r\n            i -= <span class=\"hljs-number\">1</span>\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            literals.append(var_name)\r\n        i += <span class=\"hljs-number\">1</span>\r\n    <span class=\"hljs-keyword\">return</span> Clause(literals)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">generate_formula</span>() -&gt; Formula:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Randomly generate a formula.\r\n    &quot;&quot;&quot;</span>\r\n    clauses: <span class=\"hljs-built_in\">set</span>[Clause] = <span class=\"hljs-built_in\">set</span>()\r\n    no_of_clauses = random.randint(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10</span>)\r\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-built_in\">len</span>(clauses) &lt; no_of_clauses:\r\n        clauses.add(generate_clause())\r\n    <span class=\"hljs-keyword\">return</span> Formula(clauses)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">generate_parameters</span>(<span class=\"hljs-params\">formula: Formula</span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">list</span>[Clause], <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">str</span>]]:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Return the clauses and symbols from a formula.\r\n    A symbol is the uncomplemented form of a literal.\r\n    For example,\r\n        Symbol of A3 is A3.\r\n        Symbol of A5&#x27; is A5.\r\n\r\n    &gt;&gt;&gt; formula = Formula([Clause([&quot;A1&quot;, &quot;A2&#x27;&quot;, &quot;A3&quot;]), Clause([&quot;A5&#x27;&quot;, &quot;A2&#x27;&quot;, &quot;A1&quot;])])\r\n    &gt;&gt;&gt; clauses, symbols = generate_parameters(formula)\r\n    &gt;&gt;&gt; clauses_list = [str(i) for i in clauses]\r\n    &gt;&gt;&gt; clauses_list\r\n    [&quot;{A1 , A2&#x27; , A3}&quot;, &quot;{A5&#x27; , A2&#x27; , A1}&quot;]\r\n    &gt;&gt;&gt; symbols\r\n    [&#x27;A1&#x27;, &#x27;A2&#x27;, &#x27;A3&#x27;, &#x27;A5&#x27;]\r\n    &quot;&quot;&quot;</span>\r\n    clauses = formula.clauses\r\n    symbols_set = []\r\n    <span class=\"hljs-keyword\">for</span> clause <span class=\"hljs-keyword\">in</span> formula.clauses:\r\n        <span class=\"hljs-keyword\">for</span> literal <span class=\"hljs-keyword\">in</span> clause.literals:\r\n            symbol = literal[:<span class=\"hljs-number\">2</span>]\r\n            <span class=\"hljs-keyword\">if</span> symbol <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> symbols_set:\r\n                symbols_set.append(symbol)\r\n    <span class=\"hljs-keyword\">return</span> clauses, symbols_set\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">find_pure_symbols</span>(<span class=\"hljs-params\">\r\n    clauses: <span class=\"hljs-built_in\">list</span>[Clause], symbols: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">str</span>], model: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">bool</span> | <span class=\"hljs-literal\">None</span>]\r\n</span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">str</span>], <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">bool</span> | <span class=\"hljs-literal\">None</span>]]:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Return pure symbols and their values to satisfy clause.\r\n    Pure symbols are symbols in a formula that exist only\r\n    in one form, either complemented or otherwise.\r\n    For example,\r\n        { { A4 , A3 , A5&#x27; , A1 , A3&#x27; } , { A4 } , { A3 } } has\r\n        pure symbols A4, A5&#x27; and A1.\r\n    This has the following steps:\r\n    1. Ignore clauses that have already evaluated to be True.\r\n    2. Find symbols that occur only in one form in the rest of the clauses.\r\n    3. Assign value True or False depending on whether the symbols occurs\r\n    in normal or complemented form respectively.\r\n\r\n    &gt;&gt;&gt; formula = Formula([Clause([&quot;A1&quot;, &quot;A2&#x27;&quot;, &quot;A3&quot;]), Clause([&quot;A5&#x27;&quot;, &quot;A2&#x27;&quot;, &quot;A1&quot;])])\r\n    &gt;&gt;&gt; clauses, symbols = generate_parameters(formula)\r\n\r\n    &gt;&gt;&gt; pure_symbols, values = find_pure_symbols(clauses, symbols, {})\r\n    &gt;&gt;&gt; pure_symbols\r\n    [&#x27;A1&#x27;, &#x27;A2&#x27;, &#x27;A3&#x27;, &#x27;A5&#x27;]\r\n    &gt;&gt;&gt; values\r\n    {&#x27;A1&#x27;: True, &#x27;A2&#x27;: False, &#x27;A3&#x27;: True, &#x27;A5&#x27;: False}\r\n    &quot;&quot;&quot;</span>\r\n    pure_symbols = []\r\n    assignment: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">bool</span> | <span class=\"hljs-literal\">None</span>] = <span class=\"hljs-built_in\">dict</span>()\r\n    literals = []\r\n\r\n    <span class=\"hljs-keyword\">for</span> clause <span class=\"hljs-keyword\">in</span> clauses:\r\n        <span class=\"hljs-keyword\">if</span> clause.evaluate(model):\r\n            <span class=\"hljs-keyword\">continue</span>\r\n        <span class=\"hljs-keyword\">for</span> literal <span class=\"hljs-keyword\">in</span> clause.literals:\r\n            literals.append(literal)\r\n\r\n    <span class=\"hljs-keyword\">for</span> s <span class=\"hljs-keyword\">in</span> symbols:\r\n        sym = s + <span class=\"hljs-string\">&quot;&#x27;&quot;</span>\r\n        <span class=\"hljs-keyword\">if</span> (s <span class=\"hljs-keyword\">in</span> literals <span class=\"hljs-keyword\">and</span> sym <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> literals) <span class=\"hljs-keyword\">or</span> (\r\n            s <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> literals <span class=\"hljs-keyword\">and</span> sym <span class=\"hljs-keyword\">in</span> literals\r\n        ):\r\n            pure_symbols.append(s)\r\n    <span class=\"hljs-keyword\">for</span> p <span class=\"hljs-keyword\">in</span> pure_symbols:\r\n        assignment[p] = <span class=\"hljs-literal\">None</span>\r\n    <span class=\"hljs-keyword\">for</span> s <span class=\"hljs-keyword\">in</span> pure_symbols:\r\n        sym = s + <span class=\"hljs-string\">&quot;&#x27;&quot;</span>\r\n        <span class=\"hljs-keyword\">if</span> s <span class=\"hljs-keyword\">in</span> literals:\r\n            assignment[s] = <span class=\"hljs-literal\">True</span>\r\n        <span class=\"hljs-keyword\">elif</span> sym <span class=\"hljs-keyword\">in</span> literals:\r\n            assignment[s] = <span class=\"hljs-literal\">False</span>\r\n    <span class=\"hljs-keyword\">return</span> pure_symbols, assignment\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">find_unit_clauses</span>(<span class=\"hljs-params\">\r\n    clauses: <span class=\"hljs-built_in\">list</span>[Clause], model: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">bool</span> | <span class=\"hljs-literal\">None</span>]\r\n</span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">str</span>], <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">bool</span> | <span class=\"hljs-literal\">None</span>]]:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Returns the unit symbols and their values to satisfy clause.\r\n    Unit symbols are symbols in a formula that are:\r\n    - Either the only symbol in a clause\r\n    - Or all other literals in that clause have been assigned False\r\n    This has the following steps:\r\n    1. Find symbols that are the only occurrences in a clause.\r\n    2. Find symbols in a clause where all other literals are assigned False.\r\n    3. Assign True or False depending on whether the symbols occurs in\r\n    normal or complemented form respectively.\r\n\r\n    &gt;&gt;&gt; clause1 = Clause([&quot;A4&quot;, &quot;A3&quot;, &quot;A5&#x27;&quot;, &quot;A1&quot;, &quot;A3&#x27;&quot;])\r\n    &gt;&gt;&gt; clause2 = Clause([&quot;A4&quot;])\r\n    &gt;&gt;&gt; clause3 = Clause([&quot;A3&quot;])\r\n    &gt;&gt;&gt; clauses, symbols = generate_parameters(Formula([clause1, clause2, clause3]))\r\n\r\n    &gt;&gt;&gt; unit_clauses, values = find_unit_clauses(clauses, {})\r\n    &gt;&gt;&gt; unit_clauses\r\n    [&#x27;A4&#x27;, &#x27;A3&#x27;]\r\n    &gt;&gt;&gt; values\r\n    {&#x27;A4&#x27;: True, &#x27;A3&#x27;: True}\r\n    &quot;&quot;&quot;</span>\r\n    unit_symbols = []\r\n    <span class=\"hljs-keyword\">for</span> clause <span class=\"hljs-keyword\">in</span> clauses:\r\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(clause) == <span class=\"hljs-number\">1</span>:\r\n            unit_symbols.append(<span class=\"hljs-built_in\">list</span>(clause.literals.keys())[<span class=\"hljs-number\">0</span>])\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            Fcount, Ncount = <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>\r\n            <span class=\"hljs-keyword\">for</span> literal, value <span class=\"hljs-keyword\">in</span> clause.literals.items():\r\n                <span class=\"hljs-keyword\">if</span> value <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">False</span>:\r\n                    Fcount += <span class=\"hljs-number\">1</span>\r\n                <span class=\"hljs-keyword\">elif</span> value <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\r\n                    sym = literal\r\n                    Ncount += <span class=\"hljs-number\">1</span>\r\n            <span class=\"hljs-keyword\">if</span> Fcount == <span class=\"hljs-built_in\">len</span>(clause) - <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">and</span> Ncount == <span class=\"hljs-number\">1</span>:\r\n                unit_symbols.append(sym)\r\n    assignment: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">bool</span> | <span class=\"hljs-literal\">None</span>] = <span class=\"hljs-built_in\">dict</span>()\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> unit_symbols:\r\n        symbol = i[:<span class=\"hljs-number\">2</span>]\r\n        assignment[symbol] = <span class=\"hljs-built_in\">len</span>(i) == <span class=\"hljs-number\">2</span>\r\n    unit_symbols = [i[:<span class=\"hljs-number\">2</span>] <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> unit_symbols]\r\n\r\n    <span class=\"hljs-keyword\">return</span> unit_symbols, assignment\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">dpll_algorithm</span>(<span class=\"hljs-params\">\r\n    clauses: <span class=\"hljs-built_in\">list</span>[Clause], symbols: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">str</span>], model: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">bool</span> | <span class=\"hljs-literal\">None</span>]\r\n</span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">bool</span> | <span class=\"hljs-literal\">None</span>, <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">bool</span> | <span class=\"hljs-literal\">None</span>] | <span class=\"hljs-literal\">None</span>]:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Returns the model if the formula is satisfiable, else None\r\n    This has the following steps:\r\n    1. If every clause in clauses is True, return True.\r\n    2. If some clause in clauses is False, return False.\r\n    3. Find pure symbols.\r\n    4. Find unit symbols.\r\n\r\n    &gt;&gt;&gt; formula = Formula([Clause([&quot;A4&quot;, &quot;A3&quot;, &quot;A5&#x27;&quot;, &quot;A1&quot;, &quot;A3&#x27;&quot;]), Clause([&quot;A4&quot;])])\r\n    &gt;&gt;&gt; clauses, symbols = generate_parameters(formula)\r\n\r\n    &gt;&gt;&gt; soln, model = dpll_algorithm(clauses, symbols, {})\r\n    &gt;&gt;&gt; soln\r\n    True\r\n    &gt;&gt;&gt; model\r\n    {&#x27;A4&#x27;: True}\r\n    &quot;&quot;&quot;</span>\r\n    check_clause_all_true = <span class=\"hljs-literal\">True</span>\r\n    <span class=\"hljs-keyword\">for</span> clause <span class=\"hljs-keyword\">in</span> clauses:\r\n        clause_check = clause.evaluate(model)\r\n        <span class=\"hljs-keyword\">if</span> clause_check <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">False</span>:\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>, <span class=\"hljs-literal\">None</span>\r\n        <span class=\"hljs-keyword\">elif</span> clause_check <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\r\n            check_clause_all_true = <span class=\"hljs-literal\">False</span>\r\n            <span class=\"hljs-keyword\">continue</span>\r\n\r\n    <span class=\"hljs-keyword\">if</span> check_clause_all_true:\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>, model\r\n\r\n    <span class=\"hljs-keyword\">try</span>:\r\n        pure_symbols, assignment = find_pure_symbols(clauses, symbols, model)\r\n    <span class=\"hljs-keyword\">except</span> RecursionError:\r\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;raises a RecursionError and is&quot;</span>)\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>, {}\r\n    P = <span class=\"hljs-literal\">None</span>\r\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(pure_symbols) &gt; <span class=\"hljs-number\">0</span>:\r\n        P, value = pure_symbols[<span class=\"hljs-number\">0</span>], assignment[pure_symbols[<span class=\"hljs-number\">0</span>]]\r\n\r\n    <span class=\"hljs-keyword\">if</span> P:\r\n        tmp_model = model\r\n        tmp_model[P] = value\r\n        tmp_symbols = [i <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> symbols]\r\n        <span class=\"hljs-keyword\">if</span> P <span class=\"hljs-keyword\">in</span> tmp_symbols:\r\n            tmp_symbols.remove(P)\r\n        <span class=\"hljs-keyword\">return</span> dpll_algorithm(clauses, tmp_symbols, tmp_model)\r\n\r\n    unit_symbols, assignment = find_unit_clauses(clauses, model)\r\n    P = <span class=\"hljs-literal\">None</span>\r\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(unit_symbols) &gt; <span class=\"hljs-number\">0</span>:\r\n        P, value = unit_symbols[<span class=\"hljs-number\">0</span>], assignment[unit_symbols[<span class=\"hljs-number\">0</span>]]\r\n    <span class=\"hljs-keyword\">if</span> P:\r\n        tmp_model = model\r\n        tmp_model[P] = value\r\n        tmp_symbols = [i <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> symbols]\r\n        <span class=\"hljs-keyword\">if</span> P <span class=\"hljs-keyword\">in</span> tmp_symbols:\r\n            tmp_symbols.remove(P)\r\n        <span class=\"hljs-keyword\">return</span> dpll_algorithm(clauses, tmp_symbols, tmp_model)\r\n    P = symbols[<span class=\"hljs-number\">0</span>]\r\n    rest = symbols[<span class=\"hljs-number\">1</span>:]\r\n    tmp1, tmp2 = model, model\r\n    tmp1[P], tmp2[P] = <span class=\"hljs-literal\">True</span>, <span class=\"hljs-literal\">False</span>\r\n\r\n    <span class=\"hljs-keyword\">return</span> dpll_algorithm(clauses, rest, tmp1) <span class=\"hljs-keyword\">or</span> dpll_algorithm(clauses, rest, tmp2)\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    <span class=\"hljs-keyword\">import</span> doctest\r\n\r\n    doctest.testmod()\r\n\r\n    formula = generate_formula()\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;The formula <span class=\"hljs-subst\">{formula}</span> is&quot;</span>, end=<span class=\"hljs-string\">&quot; &quot;</span>)\r\n\r\n    clauses, symbols = generate_parameters(formula)\r\n    solution, model = dpll_algorithm(clauses, symbols, {})\r\n\r\n    <span class=\"hljs-keyword\">if</span> solution:\r\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;satisfiable with the assignment <span class=\"hljs-subst\">{model}</span>.&quot;</span>)\r\n    <span class=\"hljs-keyword\">else</span>:\r\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;not satisfiable.&quot;</span>)\r\n"
    }
  },
  "contributors": [
    {
      "name": "Andrew Grangaard",
      "email": "granny-github@ofb.net",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}