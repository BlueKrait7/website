{
  "slug": "fcfs-scheduling",
  "name": "Fcfs Scheduling",
  "categories": [
    "cpuschedulingalgorithms"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "cpu_scheduling_algorithms\\fcfs_scheduling.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/cpu_scheduling_algorithms\\fcfs_scheduling.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @brief Implementation of FCFS CPU scheduling algorithm\r\n * @details\r\n * FCFS is a non-preemptive CPU scheduling algorithm in which whichever process\r\n * arrives first, gets executed first. If two or more processes arrive\r\n * simultaneously, the process with smaller process ID gets executed first.\r\n * @link https://bit.ly/3ABNXOC\r\n * @author [Pratyush Vatsa](https://github.com/Pratyush219)\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span>      <span class=\"hljs-comment\">/// for sorting</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>        <span class=\"hljs-comment\">/// for assert</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span>        <span class=\"hljs-comment\">/// random number generation</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ctime&gt;</span>          <span class=\"hljs-comment\">/// for time</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iomanip&gt;</span>        <span class=\"hljs-comment\">/// for formatting the output</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>       <span class=\"hljs-comment\">/// for IO operations</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span>          <span class=\"hljs-comment\">/// for std::priority_queue</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_set&gt;</span>  <span class=\"hljs-comment\">/// for std::unordered_set</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>         <span class=\"hljs-comment\">/// for std::vector</span></span>\r\n\r\n<span class=\"hljs-keyword\">using</span> std::cin;\r\n<span class=\"hljs-keyword\">using</span> std::cout;\r\n<span class=\"hljs-keyword\">using</span> std::endl;\r\n<span class=\"hljs-keyword\">using</span> std::get;\r\n<span class=\"hljs-keyword\">using</span> std::left;\r\n<span class=\"hljs-keyword\">using</span> std::make_tuple;\r\n<span class=\"hljs-keyword\">using</span> std::priority_queue;\r\n<span class=\"hljs-keyword\">using</span> std::rand;\r\n<span class=\"hljs-keyword\">using</span> std::srand;\r\n<span class=\"hljs-keyword\">using</span> std::tuple;\r\n<span class=\"hljs-keyword\">using</span> std::unordered_set;\r\n<span class=\"hljs-keyword\">using</span> std::vector;\r\n<span class=\"hljs-comment\">/**\r\n * @brief Comparator function for sorting a vector\r\n * @tparam S Data type of Process ID\r\n * @tparam T Data type of Arrival time\r\n * @tparam E Data type of Burst time\r\n * @param t1 First tuple\r\n * @param t2 Second tuple\r\n * @returns true if t1 and t2 are in the CORRECT order\r\n * @returns false if t1 and t2 are in the INCORRECT order\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> S, <span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> E&gt;\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">sortcol</span><span class=\"hljs-params\">(tuple&lt;S, T, E&gt;&amp; t1, tuple&lt;S, T, E&gt;&amp; t2)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(t1) &lt; <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(t2)) {\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(t1) == <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(t2) &amp;&amp; <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">0</span>&gt;(t1) &lt; <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">0</span>&gt;(t2)) {\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @class Compare\r\n * @brief Comparator class for priority queue\r\n * @tparam S Data type of Process ID\r\n * @tparam T Data type of Arrival time\r\n * @tparam E Data type of Burst time\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> S, <span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> E&gt;\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Compare</span> {\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-comment\">/**\r\n     * @param t1 First tuple\r\n     * @param t2 Second tuple\r\n     * @brief A comparator function that checks whether to swap the two tuples\r\n     * or not.\r\n     * @link Refer to\r\n     * https://www.geeksforgeeks.org/comparator-class-in-c-with-examples/ for\r\n     * detailed description of comparator\r\n     * @returns true if the tuples SHOULD be swapped\r\n     * @returns false if the tuples SHOULDN&#x27;T be swapped\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(tuple&lt;S, T, E, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>&gt;&amp; t1,\r\n                    tuple&lt;S, T, E, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>&gt;&amp; t2)</span> </span>{\r\n        <span class=\"hljs-comment\">// Compare arrival times</span>\r\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(t2) &lt; <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(t1)) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n        }\r\n        <span class=\"hljs-comment\">// If arrival times are same, then compare Process IDs</span>\r\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(t2) == <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(t1)) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">0</span>&gt;(t2) &lt; <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">0</span>&gt;(t1);\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n    }\r\n};\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @class FCFS\r\n * @brief Class which implements the FCFS scheduling algorithm\r\n * @tparam S Data type of Process ID\r\n * @tparam T Data type of Arrival time\r\n * @tparam E Data type of Burst time\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> S, <span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> E&gt;\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FCFS</span> {\r\n    <span class=\"hljs-comment\">/**\r\n     * Priority queue of schedules(stored as tuples) of processes.\r\n     * In each tuple\r\n     * 1st element: Process ID\r\n     * 2nd element: Arrival Time\r\n     * 3rd element: Burst time\r\n     * 4th element: Completion time\r\n     * 5th element: Turnaround time\r\n     * 6th element: Waiting time\r\n     */</span>\r\n    priority_queue&lt;tuple&lt;S, T, E, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>&gt;,\r\n                   vector&lt;tuple&lt;S, T, E, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>&gt;&gt;,\r\n                   Compare&lt;S, T, E&gt;&gt;\r\n        schedule;\r\n\r\n    <span class=\"hljs-comment\">// Stores final status of all the processes after completing the execution.</span>\r\n    vector&lt;tuple&lt;S, T, E, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>&gt;&gt; result;\r\n\r\n    <span class=\"hljs-comment\">// Stores process IDs. Used for confirming absence of a process while adding</span>\r\n    <span class=\"hljs-comment\">// it.</span>\r\n    unordered_set&lt;S&gt; idList;\r\n\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Adds the process to the ready queue if it isn&#x27;t already there\r\n     * @param id Process ID\r\n     * @param arrival Arrival time of the process\r\n     * @param burst Burst time of the process\r\n     * @returns void\r\n     *\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addProcess</span><span class=\"hljs-params\">(S id, T arrival, E burst)</span> </span>{\r\n        <span class=\"hljs-comment\">// Add if a process with process ID as id is not found in idList.</span>\r\n        <span class=\"hljs-keyword\">if</span> (idList.<span class=\"hljs-built_in\">find</span>(id) == idList.<span class=\"hljs-built_in\">end</span>()) {\r\n            tuple&lt;S, T, E, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>&gt; t =\r\n                <span class=\"hljs-built_in\">make_tuple</span>(id, arrival, burst, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);\r\n            schedule.<span class=\"hljs-built_in\">push</span>(t);\r\n            idList.<span class=\"hljs-built_in\">insert</span>(id);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Algorithm for scheduling CPU processes according to the First Come\r\n     * First Serve(FCFS) scheduling algorithm.\r\n     *\r\n     * @details FCFS is a non-preemptive algorithm in which the process which\r\n     * arrives first gets executed first. If two or more processes arrive\r\n     * together then the process with smaller process ID runs first (each\r\n     * process has a unique proces ID).\r\n     *\r\n     * I used a min priority queue of tuples to accomplish this task. The\r\n     * processes are ordered by their arrival times. If arrival times of some\r\n     * processes are equal, then they are ordered by their process ID.\r\n     *\r\n     * @returns void\r\n     */</span>\r\n    vector&lt;tuple&lt;S, T, E, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">scheduleForFcfs</span>() {\r\n        <span class=\"hljs-comment\">// Variable to keep track of time elapsed so far</span>\r\n        <span class=\"hljs-type\">double</span> timeElapsed = <span class=\"hljs-number\">0</span>;\r\n\r\n        <span class=\"hljs-keyword\">while</span> (!schedule.<span class=\"hljs-built_in\">empty</span>()) {\r\n            tuple&lt;S, T, E, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>&gt; cur = schedule.<span class=\"hljs-built_in\">top</span>();\r\n\r\n            <span class=\"hljs-comment\">// If the current process arrived at time t2, the last process</span>\r\n            <span class=\"hljs-comment\">// completed its execution at time t1, and t2 &gt; t1.</span>\r\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(cur) &gt; timeElapsed) {\r\n                timeElapsed += <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(cur) - timeElapsed;\r\n            }\r\n\r\n            <span class=\"hljs-comment\">// Add Burst time to time elapsed</span>\r\n            timeElapsed += <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">2</span>&gt;(cur);\r\n\r\n            <span class=\"hljs-comment\">// Completion time of the current process will be same as time</span>\r\n            <span class=\"hljs-comment\">// elapsed so far</span>\r\n            <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">3</span>&gt;(cur) = timeElapsed;\r\n\r\n            <span class=\"hljs-comment\">// Turnaround time = Completion time - Arrival time</span>\r\n            <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">4</span>&gt;(cur) = <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">3</span>&gt;(cur) - <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(cur);\r\n\r\n            <span class=\"hljs-comment\">// Waiting time = Turnaround time - Burst time</span>\r\n            <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">5</span>&gt;(cur) = <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">4</span>&gt;(cur) - <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">2</span>&gt;(cur);\r\n\r\n            result.<span class=\"hljs-built_in\">push_back</span>(cur);\r\n            schedule.<span class=\"hljs-built_in\">pop</span>();\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> result;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Utility function for printing the status of each process after\r\n     * execution\r\n     * @returns void\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printResult</span><span class=\"hljs-params\">()</span> </span>{\r\n        cout &lt;&lt; <span class=\"hljs-string\">&quot;Status of all the proceses post completion is as follows:&quot;</span>\r\n             &lt;&lt; endl;\r\n\r\n        cout &lt;&lt; std::<span class=\"hljs-built_in\">setw</span>(<span class=\"hljs-number\">17</span>) &lt;&lt; left &lt;&lt; <span class=\"hljs-string\">&quot;Process ID&quot;</span> &lt;&lt; std::<span class=\"hljs-built_in\">setw</span>(<span class=\"hljs-number\">17</span>) &lt;&lt; left\r\n             &lt;&lt; <span class=\"hljs-string\">&quot;Arrival Time&quot;</span> &lt;&lt; std::<span class=\"hljs-built_in\">setw</span>(<span class=\"hljs-number\">17</span>) &lt;&lt; left &lt;&lt; <span class=\"hljs-string\">&quot;Burst Time&quot;</span>\r\n             &lt;&lt; std::<span class=\"hljs-built_in\">setw</span>(<span class=\"hljs-number\">17</span>) &lt;&lt; left &lt;&lt; <span class=\"hljs-string\">&quot;Completion Time&quot;</span> &lt;&lt; std::<span class=\"hljs-built_in\">setw</span>(<span class=\"hljs-number\">17</span>)\r\n             &lt;&lt; left &lt;&lt; <span class=\"hljs-string\">&quot;Turnaround Time&quot;</span> &lt;&lt; std::<span class=\"hljs-built_in\">setw</span>(<span class=\"hljs-number\">17</span>) &lt;&lt; left\r\n             &lt;&lt; <span class=\"hljs-string\">&quot;Waiting Time&quot;</span> &lt;&lt; endl;\r\n\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i{}; i &lt; result.<span class=\"hljs-built_in\">size</span>(); i++) {\r\n            cout &lt;&lt; std::<span class=\"hljs-built_in\">setprecision</span>(<span class=\"hljs-number\">2</span>) &lt;&lt; std::fixed &lt;&lt; std::<span class=\"hljs-built_in\">setw</span>(<span class=\"hljs-number\">17</span>) &lt;&lt; left\r\n                 &lt;&lt; <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">0</span>&gt;(result[i]) &lt;&lt; std::<span class=\"hljs-built_in\">setw</span>(<span class=\"hljs-number\">17</span>) &lt;&lt; left\r\n                 &lt;&lt; <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(result[i]) &lt;&lt; std::<span class=\"hljs-built_in\">setw</span>(<span class=\"hljs-number\">17</span>) &lt;&lt; left\r\n                 &lt;&lt; <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">2</span>&gt;(result[i]) &lt;&lt; std::<span class=\"hljs-built_in\">setw</span>(<span class=\"hljs-number\">17</span>) &lt;&lt; left\r\n                 &lt;&lt; <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">3</span>&gt;(result[i]) &lt;&lt; std::<span class=\"hljs-built_in\">setw</span>(<span class=\"hljs-number\">17</span>) &lt;&lt; left\r\n                 &lt;&lt; <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">4</span>&gt;(result[i]) &lt;&lt; std::<span class=\"hljs-built_in\">setw</span>(<span class=\"hljs-number\">17</span>) &lt;&lt; left\r\n                 &lt;&lt; <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">5</span>&gt;(result[i]) &lt;&lt; endl;\r\n        }\r\n    }\r\n};\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function to be used for testing purposes. This function guarantees the\r\n * correct solution for FCFS scheduling algorithm.\r\n * @param input the input data\r\n * @details Sorts the input vector according to arrival time. Processes whose\r\n * arrival times are same get sorted according to process ID For each process,\r\n * completion time, turnaround time and completion time are calculated, inserted\r\n * in a tuple, which is added to the vector result.\r\n * @returns A vector of tuples consisting of process ID, arrival time, burst\r\n * time, completion time, turnaround time and waiting time for each process.\r\n */</span>\r\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> S, <span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> E&gt;\r\nvector&lt;tuple&lt;S, T, E, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">get_final_status</span>(\r\n    vector&lt;tuple&lt;<span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-type\">uint32_t</span>&gt;&gt; input) {\r\n    <span class=\"hljs-built_in\">sort</span>(input.<span class=\"hljs-built_in\">begin</span>(), input.<span class=\"hljs-built_in\">end</span>(), sortcol&lt;S, T, E&gt;);\r\n    vector&lt;tuple&lt;S, T, E, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">result</span>(input.<span class=\"hljs-built_in\">size</span>());\r\n    <span class=\"hljs-type\">double</span> timeElapsed = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i{}; i &lt; input.<span class=\"hljs-built_in\">size</span>(); i++) {\r\n        T arrival = <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(input[i]);\r\n        E burst = <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">2</span>&gt;(input[i]);\r\n\r\n        <span class=\"hljs-keyword\">if</span> (arrival &gt; timeElapsed) {\r\n            timeElapsed += arrival - timeElapsed;\r\n        }\r\n        timeElapsed += burst;\r\n        <span class=\"hljs-type\">double</span> completion = timeElapsed;\r\n        <span class=\"hljs-type\">double</span> turnaround = completion - arrival;\r\n        <span class=\"hljs-type\">double</span> waiting = turnaround - burst;\r\n\r\n        <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">0</span>&gt;(result[i]) = <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">0</span>&gt;(input[i]);\r\n        <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(result[i]) = arrival;\r\n        <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">2</span>&gt;(result[i]) = burst;\r\n        <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">3</span>&gt;(result[i]) = completion;\r\n        <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">4</span>&gt;(result[i]) = turnaround;\r\n        <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">5</span>&gt;(result[i]) = waiting;\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> result;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Self-test implementations\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i{}; i &lt; <span class=\"hljs-number\">1000</span>; i++) {\r\n        <span class=\"hljs-built_in\">srand</span>(<span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">nullptr</span>));\r\n        <span class=\"hljs-type\">uint32_t</span> n = <span class=\"hljs-number\">1</span> + <span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">1000</span>;\r\n        FCFS&lt;<span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-type\">uint32_t</span>&gt; readyQueue;\r\n        vector&lt;tuple&lt;<span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-type\">uint32_t</span>&gt;&gt; <span class=\"hljs-built_in\">input</span>(n);\r\n\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> i{}; i &lt; n; i++) {\r\n            <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">0</span>&gt;(input[i]) = i;\r\n            <span class=\"hljs-built_in\">srand</span>(<span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">nullptr</span>));\r\n            <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(input[i]) = <span class=\"hljs-number\">1</span> + <span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">10000</span>;\r\n            <span class=\"hljs-built_in\">srand</span>(<span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">nullptr</span>));\r\n            <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">2</span>&gt;(input[i]) = <span class=\"hljs-number\">1</span> + <span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">10000</span>;\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> i{}; i &lt; n; i++) {\r\n            readyQueue.<span class=\"hljs-built_in\">addProcess</span>(<span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">0</span>&gt;(input[i]), <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">1</span>&gt;(input[i]),\r\n                                  <span class=\"hljs-built_in\">get</span>&lt;<span class=\"hljs-number\">2</span>&gt;(input[i]));\r\n        }\r\n        vector&lt;tuple&lt;<span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>, <span class=\"hljs-type\">double</span>&gt;&gt;\r\n            res = <span class=\"hljs-built_in\">get_final_status</span>&lt;<span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-type\">uint32_t</span>&gt;(input);\r\n        <span class=\"hljs-built_in\">assert</span>(res == readyQueue.<span class=\"hljs-built_in\">scheduleForFcfs</span>());\r\n        <span class=\"hljs-comment\">// readyQueue.printResult();</span>\r\n    }\r\n    cout &lt;&lt; <span class=\"hljs-string\">&quot;All the tests have successfully passed!&quot;</span> &lt;&lt; endl;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Entry point of the program\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// run self-test implementations</span>\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Pratyush219",
      "email": "53852042+Pratyush219@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}