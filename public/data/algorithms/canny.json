{
  "slug": "canny",
  "name": "Canny",
  "categories": [
    "digitalimageprocessing",
    "edgedetection"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "digital_image_processing\\edge_detection\\canny.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/digital_image_processing\\edge_detection\\canny.py",
      "code": "<span class=\"hljs-keyword\">import</span> cv2\r\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\r\n\r\n<span class=\"hljs-keyword\">from</span> digital_image_processing.filters.convolve <span class=\"hljs-keyword\">import</span> img_convolve\r\n<span class=\"hljs-keyword\">from</span> digital_image_processing.filters.sobel_filter <span class=\"hljs-keyword\">import</span> sobel_filter\r\n\r\nPI = <span class=\"hljs-number\">180</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">gen_gaussian_kernel</span>(<span class=\"hljs-params\">k_size, sigma</span>):\r\n    center = k_size // <span class=\"hljs-number\">2</span>\r\n    x, y = np.mgrid[<span class=\"hljs-number\">0</span> - center : k_size - center, <span class=\"hljs-number\">0</span> - center : k_size - center]\r\n    g = (\r\n        <span class=\"hljs-number\">1</span>\r\n        / (<span class=\"hljs-number\">2</span> * np.pi * sigma)\r\n        * np.exp(-(np.square(x) + np.square(y)) / (<span class=\"hljs-number\">2</span> * np.square(sigma)))\r\n    )\r\n    <span class=\"hljs-keyword\">return</span> g\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">canny</span>(<span class=\"hljs-params\">image, threshold_low=<span class=\"hljs-number\">15</span>, threshold_high=<span class=\"hljs-number\">30</span>, weak=<span class=\"hljs-number\">128</span>, strong=<span class=\"hljs-number\">255</span></span>):\r\n    image_row, image_col = image.shape[<span class=\"hljs-number\">0</span>], image.shape[<span class=\"hljs-number\">1</span>]\r\n    <span class=\"hljs-comment\"># gaussian_filter</span>\r\n    gaussian_out = img_convolve(image, gen_gaussian_kernel(<span class=\"hljs-number\">9</span>, sigma=<span class=\"hljs-number\">1.4</span>))\r\n    <span class=\"hljs-comment\"># get the gradient and degree by sobel_filter</span>\r\n    sobel_grad, sobel_theta = sobel_filter(gaussian_out)\r\n    gradient_direction = np.rad2deg(sobel_theta)\r\n    gradient_direction += PI\r\n\r\n    dst = np.zeros((image_row, image_col))\r\n\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Non-maximum suppression. If the edge strength of the current pixel is the largest\r\n    compared to the other pixels in the mask with the same direction, the value will be\r\n    preserved. Otherwise, the value will be suppressed.\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-keyword\">for</span> row <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, image_row - <span class=\"hljs-number\">1</span>):\r\n        <span class=\"hljs-keyword\">for</span> col <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, image_col - <span class=\"hljs-number\">1</span>):\r\n            direction = gradient_direction[row, col]\r\n\r\n            <span class=\"hljs-keyword\">if</span> (\r\n                <span class=\"hljs-number\">0</span> &lt;= direction &lt; <span class=\"hljs-number\">22.5</span>\r\n                <span class=\"hljs-keyword\">or</span> <span class=\"hljs-number\">15</span> * PI / <span class=\"hljs-number\">8</span> &lt;= direction &lt;= <span class=\"hljs-number\">2</span> * PI\r\n                <span class=\"hljs-keyword\">or</span> <span class=\"hljs-number\">7</span> * PI / <span class=\"hljs-number\">8</span> &lt;= direction &lt;= <span class=\"hljs-number\">9</span> * PI / <span class=\"hljs-number\">8</span>\r\n            ):\r\n                W = sobel_grad[row, col - <span class=\"hljs-number\">1</span>]\r\n                E = sobel_grad[row, col + <span class=\"hljs-number\">1</span>]\r\n                <span class=\"hljs-keyword\">if</span> sobel_grad[row, col] &gt;= W <span class=\"hljs-keyword\">and</span> sobel_grad[row, col] &gt;= E:\r\n                    dst[row, col] = sobel_grad[row, col]\r\n\r\n            <span class=\"hljs-keyword\">elif</span> (PI / <span class=\"hljs-number\">8</span> &lt;= direction &lt; <span class=\"hljs-number\">3</span> * PI / <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">or</span> (\r\n                <span class=\"hljs-number\">9</span> * PI / <span class=\"hljs-number\">8</span> &lt;= direction &lt; <span class=\"hljs-number\">11</span> * PI / <span class=\"hljs-number\">8</span>\r\n            ):\r\n                SW = sobel_grad[row + <span class=\"hljs-number\">1</span>, col - <span class=\"hljs-number\">1</span>]\r\n                NE = sobel_grad[row - <span class=\"hljs-number\">1</span>, col + <span class=\"hljs-number\">1</span>]\r\n                <span class=\"hljs-keyword\">if</span> sobel_grad[row, col] &gt;= SW <span class=\"hljs-keyword\">and</span> sobel_grad[row, col] &gt;= NE:\r\n                    dst[row, col] = sobel_grad[row, col]\r\n\r\n            <span class=\"hljs-keyword\">elif</span> (<span class=\"hljs-number\">3</span> * PI / <span class=\"hljs-number\">8</span> &lt;= direction &lt; <span class=\"hljs-number\">5</span> * PI / <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">or</span> (\r\n                <span class=\"hljs-number\">11</span> * PI / <span class=\"hljs-number\">8</span> &lt;= direction &lt; <span class=\"hljs-number\">13</span> * PI / <span class=\"hljs-number\">8</span>\r\n            ):\r\n                N = sobel_grad[row - <span class=\"hljs-number\">1</span>, col]\r\n                S = sobel_grad[row + <span class=\"hljs-number\">1</span>, col]\r\n                <span class=\"hljs-keyword\">if</span> sobel_grad[row, col] &gt;= N <span class=\"hljs-keyword\">and</span> sobel_grad[row, col] &gt;= S:\r\n                    dst[row, col] = sobel_grad[row, col]\r\n\r\n            <span class=\"hljs-keyword\">elif</span> (<span class=\"hljs-number\">5</span> * PI / <span class=\"hljs-number\">8</span> &lt;= direction &lt; <span class=\"hljs-number\">7</span> * PI / <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">or</span> (\r\n                <span class=\"hljs-number\">13</span> * PI / <span class=\"hljs-number\">8</span> &lt;= direction &lt; <span class=\"hljs-number\">15</span> * PI / <span class=\"hljs-number\">8</span>\r\n            ):\r\n                NW = sobel_grad[row - <span class=\"hljs-number\">1</span>, col - <span class=\"hljs-number\">1</span>]\r\n                SE = sobel_grad[row + <span class=\"hljs-number\">1</span>, col + <span class=\"hljs-number\">1</span>]\r\n                <span class=\"hljs-keyword\">if</span> sobel_grad[row, col] &gt;= NW <span class=\"hljs-keyword\">and</span> sobel_grad[row, col] &gt;= SE:\r\n                    dst[row, col] = sobel_grad[row, col]\r\n\r\n            <span class=\"hljs-string\">&quot;&quot;&quot;\r\n            High-Low threshold detection. If an edge pixel’s gradient value is higher\r\n            than the high threshold value, it is marked as a strong edge pixel. If an\r\n            edge pixel’s gradient value is smaller than the high threshold value and\r\n            larger than the low threshold value, it is marked as a weak edge pixel. If\r\n            an edge pixel&#x27;s value is smaller than the low threshold value, it will be\r\n            suppressed.\r\n            &quot;&quot;&quot;</span>\r\n            <span class=\"hljs-keyword\">if</span> dst[row, col] &gt;= threshold_high:\r\n                dst[row, col] = strong\r\n            <span class=\"hljs-keyword\">elif</span> dst[row, col] &lt;= threshold_low:\r\n                dst[row, col] = <span class=\"hljs-number\">0</span>\r\n            <span class=\"hljs-keyword\">else</span>:\r\n                dst[row, col] = weak\r\n\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Edge tracking. Usually a weak edge pixel caused from true edges will be connected\r\n    to a strong edge pixel while noise responses are unconnected. As long as there is\r\n    one strong edge pixel that is involved in its 8-connected neighborhood, that weak\r\n    edge point can be identified as one that should be preserved.\r\n    &quot;&quot;&quot;</span>\r\n    <span class=\"hljs-keyword\">for</span> row <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, image_row):\r\n        <span class=\"hljs-keyword\">for</span> col <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, image_col):\r\n            <span class=\"hljs-keyword\">if</span> dst[row, col] == weak:\r\n                <span class=\"hljs-keyword\">if</span> <span class=\"hljs-number\">255</span> <span class=\"hljs-keyword\">in</span> (\r\n                    dst[row, col + <span class=\"hljs-number\">1</span>],\r\n                    dst[row, col - <span class=\"hljs-number\">1</span>],\r\n                    dst[row - <span class=\"hljs-number\">1</span>, col],\r\n                    dst[row + <span class=\"hljs-number\">1</span>, col],\r\n                    dst[row - <span class=\"hljs-number\">1</span>, col - <span class=\"hljs-number\">1</span>],\r\n                    dst[row + <span class=\"hljs-number\">1</span>, col - <span class=\"hljs-number\">1</span>],\r\n                    dst[row - <span class=\"hljs-number\">1</span>, col + <span class=\"hljs-number\">1</span>],\r\n                    dst[row + <span class=\"hljs-number\">1</span>, col + <span class=\"hljs-number\">1</span>],\r\n                ):\r\n                    dst[row, col] = strong\r\n                <span class=\"hljs-keyword\">else</span>:\r\n                    dst[row, col] = <span class=\"hljs-number\">0</span>\r\n\r\n    <span class=\"hljs-keyword\">return</span> dst\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    <span class=\"hljs-comment\"># read original image in gray mode</span>\r\n    lena = cv2.imread(<span class=\"hljs-string\">r&quot;../image_data/lena.jpg&quot;</span>, <span class=\"hljs-number\">0</span>)\r\n    <span class=\"hljs-comment\"># canny edge detection</span>\r\n    canny_dst = canny(lena)\r\n    cv2.imshow(<span class=\"hljs-string\">&quot;canny&quot;</span>, canny_dst)\r\n    cv2.waitKey(<span class=\"hljs-number\">0</span>)\r\n"
    }
  },
  "contributors": [
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Shoujue Xu",
      "email": "lightxusj@126.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 3
    }
  ],
  "explanationUrl": {}
}