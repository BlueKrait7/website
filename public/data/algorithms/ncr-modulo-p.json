{
  "slug": "ncr-modulo-p",
  "name": "Ncr Modulo P",
  "categories": [
    "math"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "math\\ncr_modulo_p.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/math\\ncr_modulo_p.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @brief This program aims at calculating [nCr modulo\r\n * p](https://cp-algorithms.com/combinatorics/binomial-coefficients.html).\r\n * @details nCr is defined as n! / (r! * (n-r)!) where n! represents factorial\r\n * of n. In many cases, the value of nCr is too large to fit in a 64 bit\r\n * integer. Hence, in competitive programming, there are many problems or\r\n * subproblems to compute nCr modulo p where p is a given number.\r\n * @author [Kaustubh Damania](https://github.com/KaustubhDamania)\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>   <span class=\"hljs-comment\">/// for assert</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">/// for io operations</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>    <span class=\"hljs-comment\">/// for std::vector</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace math\r\n * @brief Mathematical algorithms\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> math {\r\n<span class=\"hljs-comment\">/**\r\n * @namespace ncr_modulo_p\r\n * @brief Functions for [nCr modulo\r\n * p](https://cp-algorithms.com/combinatorics/binomial-coefficients.html)\r\n * implementation.\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> ncr_modulo_p {\r\n<span class=\"hljs-comment\">/**\r\n * @brief Class which contains all methods required for calculating nCr mod p\r\n */</span>\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NCRModuloP</span> {\r\n <span class=\"hljs-keyword\">private</span>:\r\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; fac{};  <span class=\"hljs-comment\">/// stores precomputed factorial(i) % p value</span>\r\n    <span class=\"hljs-type\">uint64_t</span> p = <span class=\"hljs-number\">0</span>;               <span class=\"hljs-comment\">/// the p from (nCr % p)</span>\r\n\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-comment\">/** Constructor which precomputes the values of n! % mod from n=0 to size\r\n     *  and stores them in vector &#x27;fac&#x27;\r\n     *  @params[in] the numbers &#x27;size&#x27;, &#x27;mod&#x27;\r\n     */</span>\r\n    <span class=\"hljs-built_in\">NCRModuloP</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint64_t</span>&amp; size, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint64_t</span>&amp; mod) {\r\n        p = mod;\r\n        fac = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">uint64_t</span>&gt;(size);\r\n        fac[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= size; i++) {\r\n            fac[i] = (fac[i - <span class=\"hljs-number\">1</span>] * i) % p;\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/** Finds the value of x, y such that a*x + b*y = gcd(a,b)\r\n     *\r\n     * @params[in] the numbers &#x27;a&#x27;, &#x27;b&#x27; and address of &#x27;x&#x27; and &#x27;y&#x27; from above\r\n     * equation\r\n     * @returns the gcd of a and b\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">uint64_t</span> <span class=\"hljs-title\">gcdExtended</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint64_t</span>&amp; a, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint64_t</span>&amp; b, <span class=\"hljs-type\">int64_t</span>* x,\r\n                         <span class=\"hljs-type\">int64_t</span>* y)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-number\">0</span>) {\r\n            *x = <span class=\"hljs-number\">0</span>, *y = <span class=\"hljs-number\">1</span>;\r\n            <span class=\"hljs-keyword\">return</span> b;\r\n        }\r\n\r\n        <span class=\"hljs-type\">int64_t</span> x1 = <span class=\"hljs-number\">0</span>, y1 = <span class=\"hljs-number\">0</span>;\r\n        <span class=\"hljs-type\">uint64_t</span> gcd = <span class=\"hljs-built_in\">gcdExtended</span>(b % a, a, &amp;x1, &amp;y1);\r\n\r\n        *x = y1 - (b / a) * x1;\r\n        *y = x1;\r\n        <span class=\"hljs-keyword\">return</span> gcd;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/** Find modular inverse of a with m i.e. a number x such that (a*x)%m = 1\r\n     *\r\n     * @params[in] the numbers &#x27;a&#x27; and &#x27;m&#x27; from above equation\r\n     * @returns the modular inverse of a\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">modInverse</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint64_t</span>&amp; a, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint64_t</span>&amp; m)</span> </span>{\r\n        <span class=\"hljs-type\">int64_t</span> x = <span class=\"hljs-number\">0</span>, y = <span class=\"hljs-number\">0</span>;\r\n        <span class=\"hljs-type\">uint64_t</span> g = <span class=\"hljs-built_in\">gcdExtended</span>(a, m, &amp;x, &amp;y);\r\n        <span class=\"hljs-keyword\">if</span> (g != <span class=\"hljs-number\">1</span>) {  <span class=\"hljs-comment\">// modular inverse doesn&#x27;t exist</span>\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            <span class=\"hljs-type\">int64_t</span> res = ((x + m) % m);\r\n            <span class=\"hljs-keyword\">return</span> res;\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">/** Find nCr % p\r\n     *\r\n     * @params[in] the numbers &#x27;n&#x27;, &#x27;r&#x27; and &#x27;p&#x27;\r\n     * @returns the value nCr % p\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">ncr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint64_t</span>&amp; n, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint64_t</span>&amp; r, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint64_t</span>&amp; p)</span> </span>{\r\n        <span class=\"hljs-comment\">// Base cases</span>\r\n        <span class=\"hljs-keyword\">if</span> (r &gt; n) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (r == <span class=\"hljs-number\">1</span>) {\r\n            <span class=\"hljs-keyword\">return</span> n % p;\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (r == <span class=\"hljs-number\">0</span> || r == n) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\r\n        }\r\n        <span class=\"hljs-comment\">// fac is a global array with fac[r] = (r! % p)</span>\r\n        <span class=\"hljs-type\">int64_t</span> denominator = <span class=\"hljs-built_in\">modInverse</span>(fac[r], p);\r\n        <span class=\"hljs-keyword\">if</span> (denominator &lt; <span class=\"hljs-number\">0</span>) {  <span class=\"hljs-comment\">// modular inverse doesn&#x27;t exist</span>\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\r\n        }\r\n        denominator = (denominator * <span class=\"hljs-built_in\">modInverse</span>(fac[n - r], p)) % p;\r\n        <span class=\"hljs-keyword\">if</span> (denominator &lt; <span class=\"hljs-number\">0</span>) {  <span class=\"hljs-comment\">// modular inverse doesn&#x27;t exist</span>\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> (fac[n] * denominator) % p;\r\n    }\r\n};\r\n}  <span class=\"hljs-comment\">// namespace ncr_modulo_p</span>\r\n}  <span class=\"hljs-comment\">// namespace math</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Test implementations\r\n * @param ncrObj object which contains the precomputed factorial values and\r\n * ncr function\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">tests</span><span class=\"hljs-params\">(math::ncr_modulo_p::NCRModuloP ncrObj)</span> </span>{\r\n    <span class=\"hljs-comment\">// (52323 C 26161) % (1e9 + 7) = 224944353</span>\r\n    <span class=\"hljs-built_in\">assert</span>(ncrObj.<span class=\"hljs-built_in\">ncr</span>(<span class=\"hljs-number\">52323</span>, <span class=\"hljs-number\">26161</span>, <span class=\"hljs-number\">1000000007</span>) == <span class=\"hljs-number\">224944353</span>);\r\n    <span class=\"hljs-comment\">// 6 C 2 = 30, 30%5 = 0</span>\r\n    <span class=\"hljs-built_in\">assert</span>(ncrObj.<span class=\"hljs-built_in\">ncr</span>(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>) == <span class=\"hljs-number\">0</span>);\r\n    <span class=\"hljs-comment\">// 7C3 = 35, 35 % 29 = 8</span>\r\n    <span class=\"hljs-built_in\">assert</span>(ncrObj.<span class=\"hljs-built_in\">ncr</span>(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">29</span>) == <span class=\"hljs-number\">6</span>);\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-comment\">// populate the fac array</span>\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint64_t</span> size = <span class=\"hljs-number\">1e6</span> + <span class=\"hljs-number\">1</span>;\r\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint64_t</span> p = <span class=\"hljs-number\">1e9</span> + <span class=\"hljs-number\">7</span>;\r\n    math::ncr_modulo_p::NCRModuloP ncrObj =\r\n        math::ncr_modulo_p::<span class=\"hljs-built_in\">NCRModuloP</span>(size, p);\r\n    <span class=\"hljs-comment\">// test 6Ci for i=0 to 7</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= <span class=\"hljs-number\">7</span>; i++) {\r\n        std::cout &lt;&lt; <span class=\"hljs-number\">6</span> &lt;&lt; <span class=\"hljs-string\">&quot;C&quot;</span> &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot; = &quot;</span> &lt;&lt; ncrObj.<span class=\"hljs-built_in\">ncr</span>(<span class=\"hljs-number\">6</span>, i, p) &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\r\n    }\r\n    <span class=\"hljs-built_in\">tests</span>(ncrObj);  <span class=\"hljs-comment\">// execute the tests</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Assertions passed\\n&quot;</span>;\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [],
  "explanationUrl": {}
}